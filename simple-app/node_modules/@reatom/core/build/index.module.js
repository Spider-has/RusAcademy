const impossibleValue=Symbol(),callSafely=function(fn){try{return fn(...[].slice.call(arguments,1))}catch(err){return setTimeout(()=>{throw err}),err instanceof Error?err:err=new Error(err)}};function throwReatomError(condition,message){if(condition)throw new Error(`Reatom error: ${message}`)}const isAtom=thing=>void 0!==thing?.__reatom,isAction=thing=>!0===thing?.__reatom?.isAction,isConnected=cache=>cache.subs.size+cache.listeners.size>0,assertFunction=thing=>throwReatomError("function"!=typeof thing,`invalid "${typeof thing}", function expected`),getRootCause=cause=>null===cause.cause?cause:getRootCause(cause.cause);let CTX;const createCtx=function(_temp){let{callLateEffect:callLateEffect=callSafely,callNearEffect:callNearEffect=callSafely}=void 0===_temp?{}:_temp,caches=new WeakMap,read=proto=>caches.get(proto),logsListeners=new Set,nearEffects=[],lateEffects=[],inTr=!1,trError=null,trUpdates=[],trRollbacks=[],trLogs=[],trNearEffectsStart=0,trLateEffectsStart=0,walkNearEffects=()=>{for(let effect of nearEffects)callNearEffect(effect,ctx);nearEffects=[]},walkLateEffects=()=>{if(!(trNearEffectsStart+trLateEffectsStart>0)){walkNearEffects();for(let effect of lateEffects)callLateEffect(effect,ctx),nearEffects.length>0&&walkNearEffects();lateEffects=[],trNearEffectsStart=trLateEffectsStart=0}},addPatch=(_ref,cause)=>{let{state:state,proto:proto,pubs:pubs,subs:subs,listeners:listeners}=_ref;return proto.actual=!1,trLogs.push(proto.patch={state:state,proto:proto,cause:cause,pubs:pubs,subs:subs,listeners:listeners}),proto.patch},enqueueComputers=cache=>{for(let subProto of cache.subs.keys()){let subCache=subProto.patch??read(subProto);subProto.patch&&!subProto.actual||0===addPatch(subCache,cache).listeners.size&&enqueueComputers(subCache)}},disconnect=(proto,pubPatch)=>{if(pubPatch.subs.delete(proto)&&(trRollbacks.push(()=>pubPatch.subs.add(proto)),!isConnected(pubPatch))){null!==pubPatch.proto.disconnectHooks&&nearEffects.push(...pubPatch.proto.disconnectHooks);for(let parentParent of pubPatch.pubs)disconnect(pubPatch.proto,parentParent)}},connect=(proto,pubPatch)=>{if(!pubPatch.subs.has(proto)){let wasConnected=isConnected(pubPatch);if(pubPatch.subs.add(proto),trRollbacks.push(()=>pubPatch.subs.delete(proto)),!wasConnected){null!==pubPatch.proto.connectHooks&&nearEffects.push(...pubPatch.proto.connectHooks);for(let parentParentPatch of pubPatch.pubs)connect(pubPatch.proto,parentParentPatch)}}},actualize=(ctx,proto,updater)=>{let{patch:patch,actual:actual}=proto,updating=void 0!==updater;if(actual&&!updating)return patch;let cache=patch??read(proto),isInt=!cache,cause=updating?ctx.cause:read(__root);if(isInt)cache={state:proto.initState(ctx),proto:proto,cause:cause,pubs:[],subs:new Set,listeners:new Set};else if(null===proto.computer&&!updating)return cache;patch&&!actual||(patch=addPatch(cache,cause));let{state:state}=patch,patchCtx={get:ctx.get,spy:void 0,schedule:ctx.schedule,subscribe:ctx.subscribe,cause:patch};try{proto.computer&&((patchCtx,patch)=>{let{proto:proto,pubs:pubs}=patch,toDisconnect=new Set,toConnect=new Set;if(0===pubs.length||pubs.some(_ref2=>{let{proto:proto,state:state}=_ref2;return!Object.is(state,(patch.cause=actualize(patchCtx,proto)).state)})){let newPubs=[];patchCtx.spy=(_ref3,cb)=>{let{__reatom:depProto}=_ref3;if(patch.pubs===pubs){let depPatch=actualize(patchCtx,depProto),prevDepPatch=newPubs.push(depPatch)<=pubs.length?pubs[newPubs.length-1]:void 0,isDepChanged=prevDepPatch?.proto!==depPatch.proto;isDepChanged&&(prevDepPatch&&toDisconnect.add(prevDepPatch.proto),toConnect.add(depProto));let state=depProto.isAction&&!isDepChanged?depPatch.state.slice(prevDepPatch.state.length):depPatch.state;if(!cb||!isDepChanged&&Object.is(state,prevDepPatch.state))return state;depProto.isAction?state.forEach(call=>cb(call)):cb(state,prevDepPatch?.state)}else throwReatomError(!0,"async spy")},patch.state=patch.proto.computer(patchCtx,patch.state),patch.pubs=newPubs;for(let i=newPubs.length;i<pubs.length;i++)toDisconnect.add(pubs[i].proto);if(toDisconnect.size+toConnect.size&&isConnected(patch)){for(let depProto of toDisconnect)toConnect.has(depProto)||disconnect(proto,depProto.patch??read(depProto));for(let depProto of toConnect)connect(proto,depProto.patch??read(depProto))}}})(patchCtx,patch),updating&&(patch.cause=ctx.cause,updater(patchCtx,patch)),proto.actual=!0}catch(error){throw patch.error=error}return Object.is(state,patch.state)||(patch.subs.size>0&&(updating||patch.listeners.size>0)&&enqueueComputers(patch),proto.updateHooks?.forEach(hook=>trUpdates.push(()=>hook(patchCtx,patch)))),patch},ctx={get(atomOrCb){if(throwReatomError(CTX&&getRootCause(CTX.cause)!==read(__root),"cause collision"),isAtom(atomOrCb)){let proto=atomOrCb.__reatom;if(inTr)return actualize(this,proto).state;let cache=read(proto);return void 0===cache||null!==proto.computer&&!isConnected(cache)?this.get(()=>actualize(this,proto).state):cache.state}if(throwReatomError(null!==trError,"tr failed"),inTr)return atomOrCb(read,actualize);inTr=!0,trNearEffectsStart=nearEffects.length,trLateEffectsStart=lateEffects.length;let start=void 0===CTX;start&&(CTX=this);try{var result=atomOrCb(read,actualize);for(let i=0;i<trLogs.length;i++){let{listeners:listeners,proto:proto}=trLogs[i];if(listeners.size>0&&actualize(this,proto),trUpdates.length>0)for(let commit of trUpdates.splice(0))commit(this)}if(trLogs.length)for(let log of logsListeners)log(trLogs);for(let patch of trLogs){let{proto:proto,state:state}=patch;if(proto.isAction&&(patch.state=[]),patch===proto.patch)if(proto.patch=null,proto.actual=!1,caches.set(proto,patch),proto.isAction){if(0===state.length)continue;for(let cb of patch.listeners)nearEffects.push(()=>cb(state))}else for(let cb of patch.listeners)lateEffects.push(()=>cb(read(proto).state))}}catch(e){trError=e=e instanceof Error?e:new Error(String(e));for(let log of logsListeners)log(trLogs,e);for(let cb of trRollbacks)callSafely(cb,e);for(let{proto:proto}of trLogs)proto.patch=null,proto.actual=!1;throw nearEffects.length=trNearEffectsStart,lateEffects.length=trLateEffectsStart,e}finally{inTr=!1,trError=null,trUpdates=[],trRollbacks=[],trLogs=[],start&&(CTX=void 0)}return walkLateEffects(),result},spy:void 0,schedule(cb,step){return void 0===step&&(step=1),assertFunction(cb),throwReatomError(!this,"missed context"),new Promise((res,rej)=>{-1===step?inTr&&trRollbacks.push(cb):0===step?inTr&&trUpdates.push(()=>cb(this)):((1===step?nearEffects:lateEffects).push(()=>{try{let result=cb(this);return result instanceof Promise?result.then(res,rej):res(result),result}catch(error){throw rej(error),error}}),inTr||walkLateEffects())})},subscribe(atom,cb){if(void 0===cb&&(cb=atom),assertFunction(cb),atom===cb)return logsListeners.add(cb),()=>logsListeners.delete(cb);let{__reatom:proto}=atom,lastState=impossibleValue,listener=state=>Object.is(lastState,state)||cb(lastState=state),cache=read(proto);return void 0!==cache&&isConnected(cache)?cache.listeners.add(listener):this.get(()=>{cache=actualize(this,proto,(patchCtx,patch)=>{}),cache.listeners.add(listener),trRollbacks.push(()=>proto.patch.listeners.delete(listener)),null!==proto.connectHooks&&nearEffects.push(...proto.connectHooks);for(let pubPatch of cache.pubs)connect(proto,pubPatch)}),lastState===impossibleValue&&listener((proto.patch??read(proto)).state),()=>{if(cache.listeners.delete(listener)&&!isConnected(cache)){inTr||(trNearEffectsStart=nearEffects.length,trLateEffectsStart=lateEffects.length),proto.disconnectHooks&&nearEffects.push(...proto.disconnectHooks);for(let pubCache of cache.pubs)disconnect(proto,pubCache);inTr||(trRollbacks.length=0,walkLateEffects())}}},cause:void 0};return(ctx.cause=ctx.get(()=>actualize(ctx,__root))).cause=null,ctx};let i=0,__count=name=>`${name}#${++i}`;function atom(initState,name){void 0===name&&(name=__count("_atom"));let theAtom=(ctx,update)=>ctx.get((read,actualize)=>actualize(ctx,theAtom.__reatom,(patchCtx,patch)=>{patch.state="function"==typeof update?update(patch.state,patchCtx):update}).state),computer=null,initStateResult=initState;return"function"==typeof initState&&(theAtom={},computer=initState,initStateResult=void 0),theAtom.__reatom={name:name,isAction:!1,patch:null,initState:()=>initStateResult,computer:computer,connectHooks:null,disconnectHooks:null,updateHooks:null,actual:!1},theAtom.pipe=function(){return[].slice.call(arguments).reduce((acc,fn)=>fn(acc),this)},theAtom.onChange=function(cb){const hook=(ctx,patch)=>cb(ctx,patch.state);return(this.__reatom.updateHooks??=new Set).add(hook),()=>this.__reatom.updateHooks.delete(hook)},theAtom}const action=(fn,name)=>{void 0!==fn&&"string"!=typeof fn||(name=fn,fn=(ctx,v)=>v),assertFunction(fn);let actionAtom=atom([],name??__count("_action"));return actionAtom.__reatom.isAction=!0,actionAtom.__reatom.unstable_fn=fn,Object.assign(function(){var params=[].slice.call(arguments);let state=actionAtom(params[0],(state,patchCtx)=>(params[0]=patchCtx,[...state,{params:params.slice(1),payload:patchCtx.cause.proto.unstable_fn(...params)}]));return state[state.length-1].payload},actionAtom,{onCall(cb){return this.onChange((ctx,state)=>{const{params:params,payload:payload}=state[state.length-1];cb(ctx,payload,params)})}})},__root=atom(void 0,"root").__reatom;export{__count,__root,action,atom,callSafely,createCtx,isAction,isAtom,throwReatomError};
//# sourceMappingURL=index.module.js.map
