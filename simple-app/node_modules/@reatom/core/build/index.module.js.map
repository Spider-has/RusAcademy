{"version":3,"file":"index.module.js","sources":["../src/atom.ts"],"sourcesContent":["//#region TYPE UTILS\n\nexport interface Rec<Values = any> extends Record<string, Values> {}\n\nexport interface Fn<Args extends any[] = any[], Return = any> {\n  (...a: Args): Return\n}\n\nexport type AllTypes =\n  | undefined\n  | null\n  | boolean\n  | number\n  | string\n  | Record<keyof any, any>\n  | Fn\n  | symbol\n  | bigint\n\nexport interface Pipe<This> {\n  <T1>(operator1: Fn<[This], T1>): T1\n  <T1, T2>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>): T2\n  /* prettier-ignore */ <T1, T2, T3>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>): T3\n  /* prettier-ignore */ <T1, T2, T3, T4>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>): T4\n  /* prettier-ignore */ <T1, T2, T3, T4, T5>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>): T5\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>): T6\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>): T7\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>): T8\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>): T9\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>): T10\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>, operator11: Fn<[T10], T11>): T11\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>, operator11: Fn<[T10], T11>, operator12: Fn<[T11], T12>): T12\n}\n\n//#endregion\n\n//#region UTILS\n\nconst impossibleValue: any = Symbol()\n\nexport const callSafely = <I extends any[], O>(\n  fn: (...a: I) => O,\n  ...args: I\n): O | Error => {\n  try {\n    return fn(...args)\n  } catch (err: any) {\n    setTimeout(() => {\n      throw err\n    })\n    return err instanceof Error ? err : (err = new Error(err))\n  }\n}\n\n//#endregion\n\n//#region DOMAIN TYPES\n\n/** Main context of data storing and effects processing */\nexport interface Ctx {\n  get<T>(atom: Atom<T>): T\n  get<T>(\n    cb: Fn<\n      [\n        read: Fn<[proto: AtomProto], AtomCache<any> | undefined>,\n        // this is `actualize` function and\n        // the types intentionally awkward\n        // coz it only for internal usage\n        fn?: Fn,\n      ],\n      T\n    >,\n  ): T\n  spy?: {\n    <T>(anAtom: Atom<T>): T\n    <Params extends any[] = any[], Payload = any>(\n      anAction: Action<Params, Payload>,\n      cb: Fn<[call: { params: Params; payload: Payload }]>,\n    ): void\n    <T>(atom: Atom<T>, cb: Fn<[newState: T, prevState: undefined | T]>): void\n  }\n\n  schedule<T = void>(\n    cb: Fn<[Ctx], T>,\n    step?: -1 | 0 | 1 | 2,\n  ): Promise<Awaited<T>>\n\n  subscribe<T>(atom: Atom<T>, cb: Fn<[T]>): Unsubscribe\n  subscribe(cb: Fn<[patches: Logs, error?: Error]>): Unsubscribe\n\n  cause: AtomCache\n}\n\nexport interface CtxSpy extends Required<Ctx> {}\n\nexport interface Logs extends Array<AtomCache> {}\n\nexport interface Atom<State = any> {\n  __reatom: AtomProto<State>\n  pipe: Pipe<this>\n\n  onChange: (\n    cb: (\n      ctx: Ctx,\n      newState: State,\n      // TODO there could be different `prevState` for each ctx\n      // prevState: State,\n      // patch: AtomCache<State>,\n    ) => any,\n  ) => Unsubscribe\n}\n\ntype Update<State> = State | Fn<[State, Ctx], State>\nexport interface AtomMut<State = any> extends Atom<State> {\n  (ctx: Ctx, update: Update<State>): State\n}\n\nexport interface AtomProto<State = any> {\n  name: undefined | string\n  isAction: boolean\n  /** temporal cache of the last patch during transaction */\n  patch: null | AtomCache\n  initState: Fn<[Ctx], State>\n  computer: null | Fn<[CtxSpy, unknown], unknown>\n  connectHooks: null | Set<Fn<[Ctx]>>\n  disconnectHooks: null | Set<Fn<[Ctx]>>\n  updateHooks: null | Set<Fn<[Ctx, AtomCache]>>\n  actual: boolean\n}\n\nexport interface AtomCache<State = any> {\n  state: State\n  readonly proto: AtomProto\n  // nullable state mean cache is dirty (has updated pubs, which could produce new state)\n  cause: null | AtomCache\n  pubs: Array<AtomCache>\n  readonly subs: Set<AtomProto>\n  readonly listeners: Set<Fn>\n  error?: unknown\n}\n\nexport interface Action<Params extends any[] = any[], Payload = any>\n  extends Atom<Array<{ params: Params; payload: Payload }>> {\n  (ctx: Ctx, ...params: Params): Payload\n\n  onCall: (\n    cb: (ctx: Ctx, payload: Payload, params: Params) => any,\n  ) => Unsubscribe\n}\n\nexport type AtomState<T> = T extends Atom<infer State> ? State : never\n\nexport type ActionParams<T> = T extends Action<infer Params, any>\n  ? Params\n  : never\nexport type ActionPayload<T> = T extends Action<any, infer Payload>\n  ? Payload\n  : never\n\ntype DefinitelyReturnType<T> = T extends Fn<any[], infer T> ? T : never\nexport type IsAction<T> = T extends Fn &\n  Atom<infer State extends Array<{ payload: DefinitelyReturnType<T> }>>\n  ? true\n  : false\n\nexport type AtomReturn<T extends Atom> = T extends Fn\n  ? ReturnType<T>\n  : AtomState<T>\n\nexport type CtxParams<T, Else = never> = T extends Fn<[Ctx, ...infer Params]>\n  ? Params\n  : T extends [Ctx, ...infer Params]\n  ? Params\n  : Else\n\nexport interface Unsubscribe {\n  (): void\n}\n\n//#endregion\n\n//#region DOMAIN UTILS\n\n// We don't have type literal for NaN but other values are presented here\n// https://stackoverflow.com/a/51390763\ntype Falsy = false | 0 | '' | null | undefined\n// Can't be an arrow function due to\n//    https://github.com/microsoft/TypeScript/issues/34523\n/** Throws `Reatom error: ${message}` */\nexport function throwReatomError(\n  condition: any,\n  message: string,\n): asserts condition is Falsy {\n  if (condition) throw new Error(`Reatom error: ${message}`)\n}\n\nexport const isAtom = (thing: any): thing is Atom => {\n  return thing?.__reatom !== undefined\n}\n\nexport const isAction = (thing: any): thing is Action => {\n  return thing?.__reatom?.isAction === true\n}\n\n// export const getCache = <T>(ctx: Ctx, anAtom: Atom<T>): AtomCache<T> =>\n//   ctx.get((read) => (ctx.get(anAtom), read(anAtom.__reatom)!))\n\nconst isConnected = (cache: AtomCache): boolean => {\n  return cache.subs.size + cache.listeners.size > 0\n}\n\nconst assertFunction = (thing: any) =>\n  throwReatomError(\n    typeof thing !== 'function',\n    `invalid \"${typeof thing}\", function expected`,\n  )\n\n//#endregion\n\nexport interface CtxOptions {\n  /** Use it to delay or track late effects such as subscriptions notification */\n  callLateEffect?: typeof callSafely\n  /** Use it to delay or track near effects such as API calls */\n  callNearEffect?: typeof callSafely\n}\n\nconst getRootCause = (cause: AtomCache): AtomCache =>\n  cause.cause === null ? cause : getRootCause(cause.cause)\n\nlet CTX: undefined | Ctx\n\nexport const createCtx = ({\n  callLateEffect = callSafely,\n  callNearEffect = callSafely,\n}: CtxOptions = {}): Ctx => {\n  let caches = new WeakMap<AtomProto, AtomCache>()\n  let read = (proto: AtomProto): undefined | AtomCache => caches.get(proto)\n  let logsListeners = new Set<Fn<[Logs, Error?]>>()\n\n  let nearEffects: Array<Fn<[Ctx]>> = []\n  let lateEffects: Array<Fn<[Ctx]>> = []\n\n  // 'tr' is short for 'transaction'\n  let inTr = false\n  let trError: null | Error = null\n  let trUpdates: Array<Fn<[Ctx]>> = []\n  let trRollbacks: Array<Fn> = []\n  let trLogs: Array<AtomCache> = []\n  let trNearEffectsStart: typeof nearEffects.length = 0\n  let trLateEffectsStart: typeof lateEffects.length = 0\n\n  let walkNearEffects = () => {\n    for (let effect of nearEffects) callNearEffect(effect, ctx)\n\n    nearEffects = []\n  }\n  let walkLateEffects = () => {\n    if (trNearEffectsStart + trLateEffectsStart > 0) return\n\n    walkNearEffects()\n    for (let effect of lateEffects) {\n      callLateEffect(effect, ctx)\n      if (nearEffects.length > 0) walkNearEffects()\n    }\n\n    lateEffects = []\n\n    trNearEffectsStart = trLateEffectsStart = 0\n  }\n\n  let addPatch = (\n    { state, proto, pubs, subs, listeners }: AtomCache,\n    cause: AtomCache,\n  ) => {\n    proto.actual = false\n    trLogs.push(\n      (proto.patch = {\n        state: state,\n        proto: proto,\n        cause,\n        pubs: pubs,\n        subs: subs,\n        listeners: listeners,\n      }),\n    )\n    return proto.patch\n  }\n\n  let enqueueComputers = (cache: AtomCache) => {\n    for (let subProto of cache.subs.keys()) {\n      let subCache = subProto.patch ?? read(subProto)!\n\n      if (!subProto.patch || subProto.actual) {\n        if (addPatch(subCache, cache).listeners.size === 0) {\n          enqueueComputers(subCache)\n        }\n      }\n    }\n  }\n\n  let disconnect = (proto: AtomProto, pubPatch: AtomCache): void => {\n    if (pubPatch.subs.delete(proto)) {\n      trRollbacks.push(() => pubPatch.subs.add(proto))\n\n      if (!isConnected(pubPatch)) {\n        if (pubPatch.proto.disconnectHooks !== null) {\n          nearEffects.push(...pubPatch.proto.disconnectHooks)\n        }\n\n        for (let parentParent of pubPatch.pubs) {\n          disconnect(pubPatch.proto, parentParent)\n        }\n      }\n    }\n  }\n\n  let connect = (proto: AtomProto, pubPatch: AtomCache) => {\n    if (!pubPatch.subs.has(proto)) {\n      let wasConnected = isConnected(pubPatch)\n      pubPatch.subs.add(proto)\n      trRollbacks.push(() => pubPatch.subs.delete(proto))\n\n      if (!wasConnected) {\n        if (pubPatch.proto.connectHooks !== null) {\n          nearEffects.push(...pubPatch.proto.connectHooks)\n        }\n\n        for (let parentParentPatch of pubPatch.pubs) {\n          connect(pubPatch.proto, parentParentPatch)\n        }\n      }\n    }\n  }\n\n  let actualizePubs = (patchCtx: Ctx, patch: AtomCache) => {\n    let { proto, pubs } = patch\n    let toDisconnect = new Set<AtomProto>()\n    let toConnect = new Set<AtomProto>()\n\n    if (\n      pubs.length === 0 ||\n      pubs.some(\n        ({ proto, state }) =>\n          !Object.is(state, (patch.cause = actualize(patchCtx, proto)).state),\n      )\n    ) {\n      let newPubs: typeof pubs = []\n\n      patchCtx.spy = ({ __reatom: depProto }: Atom, cb?: Fn) => {\n        // this changed after computer exit\n        if (patch.pubs === pubs) {\n          let depPatch = actualize(patchCtx, depProto)\n          let prevDepPatch =\n            newPubs.push(depPatch) <= pubs.length\n              ? pubs[newPubs.length - 1]\n              : undefined\n          let isDepChanged = prevDepPatch?.proto !== depPatch.proto\n\n          if (isDepChanged) {\n            if (prevDepPatch) toDisconnect.add(prevDepPatch.proto)\n            toConnect.add(depProto)\n          }\n\n          let state =\n            depProto.isAction && !isDepChanged\n              ? depPatch.state.slice(prevDepPatch!.state.length)\n              : depPatch.state\n\n          if (cb && (isDepChanged || !Object.is(state, prevDepPatch!.state))) {\n            if (depProto.isAction) (state as any[]).forEach((call) => cb(call))\n            else cb(state, prevDepPatch?.state)\n          } else {\n            return state\n          }\n        } else {\n          throwReatomError(true, 'async spy')\n        }\n      }\n\n      patch.state = patch.proto.computer!(patchCtx as CtxSpy, patch.state)\n      patch.pubs = newPubs\n\n      for (let i = newPubs.length; i < pubs.length; i++) {\n        toDisconnect.add(pubs[i]!.proto)\n      }\n\n      if (toDisconnect.size + toConnect.size && isConnected(patch)) {\n        for (let depProto of toDisconnect) {\n          toConnect.has(depProto) ||\n            disconnect(proto, depProto.patch ?? read(depProto)!)\n        }\n\n        for (let depProto of toConnect) {\n          connect(proto, depProto.patch ?? read(depProto)!)\n        }\n      }\n    }\n  }\n\n  let actualize = (\n    ctx: Ctx,\n    proto: AtomProto,\n    updater?: Fn<[patchCtx: Ctx, patch: AtomCache]>,\n  ): AtomCache => {\n    let { patch, actual } = proto\n    let updating = updater !== undefined\n\n    if (actual && !updating) return patch!\n\n    let cache = patch ?? read(proto)\n    let isInt = !cache\n    let cause = updating ? ctx.cause : read(__root)!\n\n    if (isInt) {\n      cache = {\n        state: proto.initState(ctx),\n        proto,\n        cause,\n        pubs: [],\n        subs: new Set(),\n        listeners: new Set(),\n      }\n    } else if (proto.computer === null && !updating) {\n      return cache!\n    }\n\n    if (!patch || actual) patch = addPatch(cache!, cause)\n\n    let { state } = patch\n    let patchCtx: Ctx = {\n      get: ctx.get,\n      spy: undefined,\n      schedule: ctx.schedule,\n      subscribe: ctx.subscribe,\n      cause: patch,\n    }\n\n    try {\n      if (proto.computer) actualizePubs(patchCtx, patch)\n      if (updating) {\n        // updater's cause is a more important, than computer's cause\n        patch.cause = ctx.cause\n        updater!(patchCtx, patch)\n      }\n      proto.actual = true\n    } catch (error) {\n      throw (patch.error = error)\n    }\n\n    if (!Object.is(state, patch.state)) {\n      if (patch.subs.size > 0 && (updating || patch.listeners.size > 0)) {\n        enqueueComputers(patch)\n      }\n\n      proto.updateHooks?.forEach((hook) =>\n        trUpdates.push(() => hook(patchCtx, patch!)),\n      )\n    }\n\n    return patch\n  }\n\n  let ctx: Ctx = {\n    get(atomOrCb) {\n      throwReatomError(\n        CTX && getRootCause(CTX.cause) !== read(__root),\n        'cause collision',\n      )\n\n      if (isAtom(atomOrCb)) {\n        let proto = atomOrCb.__reatom\n        if (inTr) return actualize(this, proto).state\n        let cache = read(proto)\n\n        return cache !== undefined &&\n          (proto.computer === null || isConnected(cache))\n          ? cache.state\n          : this.get(() => actualize(this, proto).state)\n      }\n\n      throwReatomError(trError !== null, 'tr failed')\n\n      if (inTr) return atomOrCb(read, actualize)\n\n      inTr = true\n      trNearEffectsStart = nearEffects.length\n      trLateEffectsStart = lateEffects.length\n      let start = CTX === undefined\n      if (start) CTX = this\n\n      try {\n        var result = atomOrCb(read, actualize)\n\n        for (let i = 0; i < trLogs.length; i++) {\n          let { listeners, proto } = trLogs[i]!\n          if (listeners.size > 0) actualize(this, proto)\n          if (trUpdates.length > 0 /* TODO `&& trLogs.length === i + 1` */) {\n            for (let commit of trUpdates.splice(0)) commit(this)\n          }\n        }\n\n        if (trLogs.length) for (let log of logsListeners) log(trLogs)\n\n        for (let patch of trLogs) {\n          let { proto, state } = patch\n          if (proto.isAction) patch.state = []\n\n          if (patch === proto.patch) {\n            proto.patch = null\n            proto.actual = false\n\n            caches.set(proto, patch)\n\n            if (proto.isAction) {\n              if (state.length === 0) continue\n              for (let cb of patch.listeners) {\n                nearEffects.push(() => cb(state))\n              }\n            } else {\n              for (let cb of patch.listeners) {\n                lateEffects.push(() => cb(read(proto)!.state))\n              }\n            }\n          }\n        }\n      } catch (e: any) {\n        trError = e = e instanceof Error ? e : new Error(String(e))\n        for (let log of logsListeners) log(trLogs, e)\n        for (let cb of trRollbacks) callSafely(cb, e)\n        for (let { proto } of trLogs) {\n          proto.patch = null\n          proto.actual = false\n        }\n\n        nearEffects.length = trNearEffectsStart\n        lateEffects.length = trLateEffectsStart\n\n        throw e\n      } finally {\n        inTr = false\n        trError = null\n        trUpdates = []\n        trRollbacks = []\n        trLogs = []\n        if (start) CTX = undefined\n      }\n\n      walkLateEffects()\n\n      return result\n    },\n    spy: undefined,\n    schedule(cb, step = 1) {\n      assertFunction(cb)\n      throwReatomError(!this, 'missed context')\n\n      return new Promise<any>((res, rej) => {\n        if (step === -1) inTr && trRollbacks.push(cb)\n        else if (step === 0) inTr && trUpdates.push(() => cb(this))\n        else {\n          let target = step === 1 ? nearEffects : lateEffects\n          target.push(() => {\n            try {\n              let result = cb(this)\n              result instanceof Promise ? result.then(res, rej) : res(result)\n              return result\n            } catch (error) {\n              rej(error)\n              throw error\n            }\n          })\n          inTr || walkLateEffects()\n        }\n      })\n    },\n    // @ts-ignore\n    subscribe(atom, cb = atom) {\n      assertFunction(cb)\n\n      if (atom === cb) {\n        logsListeners.add(cb)\n        return () => logsListeners.delete(cb)\n      }\n\n      let { __reatom: proto } = atom as Atom\n\n      let lastState = impossibleValue\n      let listener = (state: any) =>\n        Object.is(lastState, state) || cb((lastState = state))\n\n      let cache = read(proto)\n\n      if (cache === undefined || !isConnected(cache)) {\n        this.get(() => {\n          cache = actualize(this, proto, (patchCtx, patch) => {})\n          cache.listeners.add(listener)\n          trRollbacks.push(() => proto.patch!.listeners.delete(listener))\n          if (proto.connectHooks !== null) {\n            nearEffects.push(...proto.connectHooks)\n          }\n          for (let pubPatch of cache.pubs) connect(proto, pubPatch)\n        })\n      } else {\n        cache.listeners.add(listener)\n      }\n\n      if (lastState === impossibleValue) {\n        listener((proto.patch ?? read(proto)!).state)\n      }\n\n      return () => {\n        if (cache!.listeners.delete(listener) && !isConnected(cache!)) {\n          if (!inTr) {\n            trNearEffectsStart = nearEffects.length\n            trLateEffectsStart = lateEffects.length\n          }\n          proto.disconnectHooks && nearEffects.push(...proto.disconnectHooks)\n\n          for (let pubCache of cache!.pubs) {\n            disconnect(proto, pubCache)\n          }\n\n          if (!inTr) {\n            trRollbacks.length = 0\n            walkLateEffects()\n          }\n        }\n      }\n    },\n    cause: undefined as any,\n  }\n\n  ;(ctx.cause = ctx.get(() => actualize(ctx, __root))).cause = null\n\n  return ctx\n}\n\nlet i = 0\n/**\n * @internal\n * @deprecated\n */\nexport let __count = (name: string) => `${name}#${++i}`\n\nexport function atom<T>(initState: (ctx: CtxSpy) => T, name?: string): Atom<T>\nexport function atom<T>(initState: T, name?: string): AtomMut<T>\nexport function atom<T>(\n  initState: T | ((ctx: CtxSpy) => T),\n  name = __count('_atom'),\n): Atom<T> | AtomMut<T> {\n  // TODO: it took much longer than expected in profiling\n  let theAtom: any = (ctx: Ctx, update: any) =>\n    ctx.get(\n      (read, actualize) =>\n        actualize!(ctx, theAtom.__reatom, (patchCtx: Ctx, patch: AtomCache) => {\n          patch.state =\n            typeof update === 'function'\n              ? update(patch.state, patchCtx)\n              : update\n        }).state,\n    )\n  let computer = null\n\n  let initStateResult: typeof initState | undefined = initState\n  if (typeof initState === 'function') {\n    theAtom = {}\n    computer = initState\n    initStateResult = undefined\n  }\n\n  theAtom.__reatom = {\n    name,\n    isAction: false,\n    patch: null,\n    initState: () => initStateResult,\n    computer,\n    connectHooks: null,\n    disconnectHooks: null,\n    updateHooks: null,\n    actual: false,\n  }\n\n  theAtom.pipe = function (this: Atom, ...fns: Array<Fn>) {\n    return fns.reduce((acc, fn) => fn(acc), this)\n  }\n  theAtom.onChange = function (this: Atom, cb: Fn) {\n    const hook = (ctx: Ctx, patch: AtomCache) => cb(ctx, patch.state)\n\n    ;(this.__reatom.updateHooks ??= new Set()).add(hook)\n\n    return () => this.__reatom.updateHooks!.delete(hook)\n  }\n\n  return theAtom\n}\n\nexport const action: {\n  (name?: string): Action<[], void>\n\n  <T>(name?: string): Action<[T], T>\n\n  <Params extends any[] = any[], Res = void>(\n    fn: (ctx: Ctx, ...params: Params) => Res,\n    name?: string,\n  ): Action<Params, Res>\n} = (fn?: string | Fn, name?: string): any => {\n  if (fn === undefined || typeof fn === 'string') {\n    name = fn\n    fn = (ctx: Ctx, v?: any) => v\n  }\n\n  assertFunction(fn)\n\n  let actionAtom = atom<Array<any>>([], name ?? __count('_action'))\n  actionAtom.__reatom.isAction = true\n  // @ts-expect-error\n  actionAtom.__reatom.unstable_fn = fn\n\n  return Object.assign(\n    (...params: [Ctx, ...any[]]) => {\n      let state = actionAtom(params[0], (state, patchCtx) => {\n        params[0] = patchCtx\n        return [\n          ...state,\n          {\n            params: params.slice(1),\n            // @ts-expect-error\n            payload: patchCtx.cause.proto.unstable_fn(...params),\n          },\n        ]\n      })\n      return state[state.length - 1]!.payload\n    },\n    actionAtom,\n    {\n      onCall(this: Action, cb: Fn): Unsubscribe {\n        return this.onChange((ctx, state) => {\n          const { params, payload } = state[state.length - 1]!\n          cb(ctx, payload, params)\n        })\n      },\n    },\n  )\n}\n\n/**\n * @internal\n * @deprecated\n */\nexport const __root = atom(undefined, 'root').__reatom\n"],"names":["impossibleValue","Symbol","callSafely","fn","slice","call","arguments","err","setTimeout","Error","throwReatomError","condition","message","isAtom","thing","undefined","__reatom","isAction","isConnected","cache","subs","size","listeners","assertFunction","getRootCause","cause","CTX","createCtx","_temp","callLateEffect","callNearEffect","caches","WeakMap","read","proto","get","logsListeners","Set","nearEffects","lateEffects","inTr","trError","trUpdates","trRollbacks","trLogs","trNearEffectsStart","trLateEffectsStart","walkNearEffects","effect","ctx","walkLateEffects","length","addPatch","_ref","state","pubs","actual","push","patch","enqueueComputers","subProto","keys","subCache","disconnect","pubPatch","delete","add","disconnectHooks","parentParent","connect","has","wasConnected","connectHooks","parentParentPatch","actualize","updater","updating","isInt","__root","initState","computer","patchCtx","spy","schedule","subscribe","actualizePubs","toDisconnect","toConnect","some","_ref2","Object","is","newPubs","_ref3","cb","depProto","depPatch","prevDepPatch","isDepChanged","forEach","i","error","updateHooks","hook","atomOrCb","this","start","result","commit","splice","log","set","e","String","step","Promise","res","rej","then","atom","lastState","listener","pubCache","__count","name","theAtom","update","initStateResult","pipe","reduce","acc","onChange","action","v","actionAtom","unstable_fn","assign","params","payload","onCall"],"mappings":"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"}