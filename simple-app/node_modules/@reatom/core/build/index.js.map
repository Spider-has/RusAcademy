{"version":3,"file":"index.js","sources":["../src/atom.ts"],"sourcesContent":["//#region TYPE UTILS\n\nexport interface Rec<Values = any> extends Record<string, Values> {}\n\nexport interface Fn<Args extends any[] = any[], Return = any> {\n  (...a: Args): Return\n}\n\nexport type AllTypes =\n  | undefined\n  | null\n  | boolean\n  | number\n  | string\n  | Record<keyof any, any>\n  | Fn\n  | symbol\n  | bigint\n\nexport interface Pipe<This> {\n  <T1>(operator1: Fn<[This], T1>): T1\n  <T1, T2>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>): T2\n  /* prettier-ignore */ <T1, T2, T3>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>): T3\n  /* prettier-ignore */ <T1, T2, T3, T4>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>): T4\n  /* prettier-ignore */ <T1, T2, T3, T4, T5>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>): T5\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>): T6\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>): T7\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>): T8\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>): T9\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>): T10\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>, operator11: Fn<[T10], T11>): T11\n  /* prettier-ignore */ <T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(operator1: Fn<[This], T1>, operator2: Fn<[T1], T2>, operator3: Fn<[T2], T3>, operator4: Fn<[T3], T4>, operator5: Fn<[T4], T5>, operator6: Fn<[T5], T6>, operator7: Fn<[T6], T7>, operator8: Fn<[T7], T8>, operator9: Fn<[T8], T9>, operator10: Fn<[T9], T10>, operator11: Fn<[T10], T11>, operator12: Fn<[T11], T12>): T12\n}\n\n//#endregion\n\n//#region UTILS\n\nconst impossibleValue: any = Symbol()\n\nexport const callSafely = <I extends any[], O>(\n  fn: (...a: I) => O,\n  ...args: I\n): O | Error => {\n  try {\n    return fn(...args)\n  } catch (err: any) {\n    setTimeout(() => {\n      throw err\n    })\n    return err instanceof Error ? err : (err = new Error(err))\n  }\n}\n\n//#endregion\n\n//#region DOMAIN TYPES\n\n/** Main context of data storing and effects processing */\nexport interface Ctx {\n  get<T>(atom: Atom<T>): T\n  get<T>(\n    cb: Fn<\n      [\n        read: Fn<[proto: AtomProto], AtomCache<any> | undefined>,\n        // this is `actualize` function and\n        // the types intentionally awkward\n        // coz it only for internal usage\n        fn?: Fn,\n      ],\n      T\n    >,\n  ): T\n  spy?: {\n    <T>(anAtom: Atom<T>): T\n    <Params extends any[] = any[], Payload = any>(\n      anAction: Action<Params, Payload>,\n      cb: Fn<[call: { params: Params; payload: Payload }]>,\n    ): void\n    <T>(atom: Atom<T>, cb: Fn<[newState: T, prevState: undefined | T]>): void\n  }\n\n  schedule<T = void>(\n    cb: Fn<[Ctx], T>,\n    step?: -1 | 0 | 1 | 2,\n  ): Promise<Awaited<T>>\n\n  subscribe<T>(atom: Atom<T>, cb: Fn<[T]>): Unsubscribe\n  subscribe(cb: Fn<[patches: Logs, error?: Error]>): Unsubscribe\n\n  cause: AtomCache\n}\n\nexport interface CtxSpy extends Required<Ctx> {}\n\nexport interface Logs extends Array<AtomCache> {}\n\nexport interface Atom<State = any> {\n  __reatom: AtomProto<State>\n  pipe: Pipe<this>\n\n  onChange: (\n    cb: (\n      ctx: Ctx,\n      newState: State,\n      // TODO there could be different `prevState` for each ctx\n      // prevState: State,\n      // patch: AtomCache<State>,\n    ) => any,\n  ) => Unsubscribe\n}\n\ntype Update<State> = State | Fn<[State, Ctx], State>\nexport interface AtomMut<State = any> extends Atom<State> {\n  (ctx: Ctx, update: Update<State>): State\n}\n\nexport interface AtomProto<State = any> {\n  name: undefined | string\n  isAction: boolean\n  /** temporal cache of the last patch during transaction */\n  patch: null | AtomCache\n  initState: Fn<[Ctx], State>\n  computer: null | Fn<[CtxSpy, unknown], unknown>\n  connectHooks: null | Set<Fn<[Ctx]>>\n  disconnectHooks: null | Set<Fn<[Ctx]>>\n  updateHooks: null | Set<Fn<[Ctx, AtomCache]>>\n  actual: boolean\n}\n\nexport interface AtomCache<State = any> {\n  state: State\n  readonly proto: AtomProto\n  // nullable state mean cache is dirty (has updated pubs, which could produce new state)\n  cause: null | AtomCache\n  pubs: Array<AtomCache>\n  readonly subs: Set<AtomProto>\n  readonly listeners: Set<Fn>\n  error?: unknown\n}\n\nexport interface Action<Params extends any[] = any[], Payload = any>\n  extends Atom<Array<{ params: Params; payload: Payload }>> {\n  (ctx: Ctx, ...params: Params): Payload\n\n  onCall: (\n    cb: (ctx: Ctx, payload: Payload, params: Params) => any,\n  ) => Unsubscribe\n}\n\nexport type AtomState<T> = T extends Atom<infer State> ? State : never\n\nexport type ActionParams<T> = T extends Action<infer Params, any>\n  ? Params\n  : never\nexport type ActionPayload<T> = T extends Action<any, infer Payload>\n  ? Payload\n  : never\n\ntype DefinitelyReturnType<T> = T extends Fn<any[], infer T> ? T : never\nexport type IsAction<T> = T extends Fn &\n  Atom<infer State extends Array<{ payload: DefinitelyReturnType<T> }>>\n  ? true\n  : false\n\nexport type AtomReturn<T extends Atom> = T extends Fn\n  ? ReturnType<T>\n  : AtomState<T>\n\nexport type CtxParams<T, Else = never> = T extends Fn<[Ctx, ...infer Params]>\n  ? Params\n  : T extends [Ctx, ...infer Params]\n  ? Params\n  : Else\n\nexport interface Unsubscribe {\n  (): void\n}\n\n//#endregion\n\n//#region DOMAIN UTILS\n\n// We don't have type literal for NaN but other values are presented here\n// https://stackoverflow.com/a/51390763\ntype Falsy = false | 0 | '' | null | undefined\n// Can't be an arrow function due to\n//    https://github.com/microsoft/TypeScript/issues/34523\n/** Throws `Reatom error: ${message}` */\nexport function throwReatomError(\n  condition: any,\n  message: string,\n): asserts condition is Falsy {\n  if (condition) throw new Error(`Reatom error: ${message}`)\n}\n\nexport const isAtom = (thing: any): thing is Atom => {\n  return thing?.__reatom !== undefined\n}\n\nexport const isAction = (thing: any): thing is Action => {\n  return thing?.__reatom?.isAction === true\n}\n\n// export const getCache = <T>(ctx: Ctx, anAtom: Atom<T>): AtomCache<T> =>\n//   ctx.get((read) => (ctx.get(anAtom), read(anAtom.__reatom)!))\n\nconst isConnected = (cache: AtomCache): boolean => {\n  return cache.subs.size + cache.listeners.size > 0\n}\n\nconst assertFunction = (thing: any) =>\n  throwReatomError(\n    typeof thing !== 'function',\n    `invalid \"${typeof thing}\", function expected`,\n  )\n\n//#endregion\n\nexport interface CtxOptions {\n  /** Use it to delay or track late effects such as subscriptions notification */\n  callLateEffect?: typeof callSafely\n  /** Use it to delay or track near effects such as API calls */\n  callNearEffect?: typeof callSafely\n}\n\nconst getRootCause = (cause: AtomCache): AtomCache =>\n  cause.cause === null ? cause : getRootCause(cause.cause)\n\nlet CTX: undefined | Ctx\n\nexport const createCtx = ({\n  callLateEffect = callSafely,\n  callNearEffect = callSafely,\n}: CtxOptions = {}): Ctx => {\n  let caches = new WeakMap<AtomProto, AtomCache>()\n  let read = (proto: AtomProto): undefined | AtomCache => caches.get(proto)\n  let logsListeners = new Set<Fn<[Logs, Error?]>>()\n\n  let nearEffects: Array<Fn<[Ctx]>> = []\n  let lateEffects: Array<Fn<[Ctx]>> = []\n\n  // 'tr' is short for 'transaction'\n  let inTr = false\n  let trError: null | Error = null\n  let trUpdates: Array<Fn<[Ctx]>> = []\n  let trRollbacks: Array<Fn> = []\n  let trLogs: Array<AtomCache> = []\n  let trNearEffectsStart: typeof nearEffects.length = 0\n  let trLateEffectsStart: typeof lateEffects.length = 0\n\n  let walkNearEffects = () => {\n    for (let effect of nearEffects) callNearEffect(effect, ctx)\n\n    nearEffects = []\n  }\n  let walkLateEffects = () => {\n    if (trNearEffectsStart + trLateEffectsStart > 0) return\n\n    walkNearEffects()\n    for (let effect of lateEffects) {\n      callLateEffect(effect, ctx)\n      if (nearEffects.length > 0) walkNearEffects()\n    }\n\n    lateEffects = []\n\n    trNearEffectsStart = trLateEffectsStart = 0\n  }\n\n  let addPatch = (\n    { state, proto, pubs, subs, listeners }: AtomCache,\n    cause: AtomCache,\n  ) => {\n    proto.actual = false\n    trLogs.push(\n      (proto.patch = {\n        state: state,\n        proto: proto,\n        cause,\n        pubs: pubs,\n        subs: subs,\n        listeners: listeners,\n      }),\n    )\n    return proto.patch\n  }\n\n  let enqueueComputers = (cache: AtomCache) => {\n    for (let subProto of cache.subs.keys()) {\n      let subCache = subProto.patch ?? read(subProto)!\n\n      if (!subProto.patch || subProto.actual) {\n        if (addPatch(subCache, cache).listeners.size === 0) {\n          enqueueComputers(subCache)\n        }\n      }\n    }\n  }\n\n  let disconnect = (proto: AtomProto, pubPatch: AtomCache): void => {\n    if (pubPatch.subs.delete(proto)) {\n      trRollbacks.push(() => pubPatch.subs.add(proto))\n\n      if (!isConnected(pubPatch)) {\n        if (pubPatch.proto.disconnectHooks !== null) {\n          nearEffects.push(...pubPatch.proto.disconnectHooks)\n        }\n\n        for (let parentParent of pubPatch.pubs) {\n          disconnect(pubPatch.proto, parentParent)\n        }\n      }\n    }\n  }\n\n  let connect = (proto: AtomProto, pubPatch: AtomCache) => {\n    if (!pubPatch.subs.has(proto)) {\n      let wasConnected = isConnected(pubPatch)\n      pubPatch.subs.add(proto)\n      trRollbacks.push(() => pubPatch.subs.delete(proto))\n\n      if (!wasConnected) {\n        if (pubPatch.proto.connectHooks !== null) {\n          nearEffects.push(...pubPatch.proto.connectHooks)\n        }\n\n        for (let parentParentPatch of pubPatch.pubs) {\n          connect(pubPatch.proto, parentParentPatch)\n        }\n      }\n    }\n  }\n\n  let actualizePubs = (patchCtx: Ctx, patch: AtomCache) => {\n    let { proto, pubs } = patch\n    let toDisconnect = new Set<AtomProto>()\n    let toConnect = new Set<AtomProto>()\n\n    if (\n      pubs.length === 0 ||\n      pubs.some(\n        ({ proto, state }) =>\n          !Object.is(state, (patch.cause = actualize(patchCtx, proto)).state),\n      )\n    ) {\n      let newPubs: typeof pubs = []\n\n      patchCtx.spy = ({ __reatom: depProto }: Atom, cb?: Fn) => {\n        // this changed after computer exit\n        if (patch.pubs === pubs) {\n          let depPatch = actualize(patchCtx, depProto)\n          let prevDepPatch =\n            newPubs.push(depPatch) <= pubs.length\n              ? pubs[newPubs.length - 1]\n              : undefined\n          let isDepChanged = prevDepPatch?.proto !== depPatch.proto\n\n          if (isDepChanged) {\n            if (prevDepPatch) toDisconnect.add(prevDepPatch.proto)\n            toConnect.add(depProto)\n          }\n\n          let state =\n            depProto.isAction && !isDepChanged\n              ? depPatch.state.slice(prevDepPatch!.state.length)\n              : depPatch.state\n\n          if (cb && (isDepChanged || !Object.is(state, prevDepPatch!.state))) {\n            if (depProto.isAction) (state as any[]).forEach((call) => cb(call))\n            else cb(state, prevDepPatch?.state)\n          } else {\n            return state\n          }\n        } else {\n          throwReatomError(true, 'async spy')\n        }\n      }\n\n      patch.state = patch.proto.computer!(patchCtx as CtxSpy, patch.state)\n      patch.pubs = newPubs\n\n      for (let i = newPubs.length; i < pubs.length; i++) {\n        toDisconnect.add(pubs[i]!.proto)\n      }\n\n      if (toDisconnect.size + toConnect.size && isConnected(patch)) {\n        for (let depProto of toDisconnect) {\n          toConnect.has(depProto) ||\n            disconnect(proto, depProto.patch ?? read(depProto)!)\n        }\n\n        for (let depProto of toConnect) {\n          connect(proto, depProto.patch ?? read(depProto)!)\n        }\n      }\n    }\n  }\n\n  let actualize = (\n    ctx: Ctx,\n    proto: AtomProto,\n    updater?: Fn<[patchCtx: Ctx, patch: AtomCache]>,\n  ): AtomCache => {\n    let { patch, actual } = proto\n    let updating = updater !== undefined\n\n    if (actual && !updating) return patch!\n\n    let cache = patch ?? read(proto)\n    let isInt = !cache\n    let cause = updating ? ctx.cause : read(__root)!\n\n    if (isInt) {\n      cache = {\n        state: proto.initState(ctx),\n        proto,\n        cause,\n        pubs: [],\n        subs: new Set(),\n        listeners: new Set(),\n      }\n    } else if (proto.computer === null && !updating) {\n      return cache!\n    }\n\n    if (!patch || actual) patch = addPatch(cache!, cause)\n\n    let { state } = patch\n    let patchCtx: Ctx = {\n      get: ctx.get,\n      spy: undefined,\n      schedule: ctx.schedule,\n      subscribe: ctx.subscribe,\n      cause: patch,\n    }\n\n    try {\n      if (proto.computer) actualizePubs(patchCtx, patch)\n      if (updating) {\n        // updater's cause is a more important, than computer's cause\n        patch.cause = ctx.cause\n        updater!(patchCtx, patch)\n      }\n      proto.actual = true\n    } catch (error) {\n      throw (patch.error = error)\n    }\n\n    if (!Object.is(state, patch.state)) {\n      if (patch.subs.size > 0 && (updating || patch.listeners.size > 0)) {\n        enqueueComputers(patch)\n      }\n\n      proto.updateHooks?.forEach((hook) =>\n        trUpdates.push(() => hook(patchCtx, patch!)),\n      )\n    }\n\n    return patch\n  }\n\n  let ctx: Ctx = {\n    get(atomOrCb) {\n      throwReatomError(\n        CTX && getRootCause(CTX.cause) !== read(__root),\n        'cause collision',\n      )\n\n      if (isAtom(atomOrCb)) {\n        let proto = atomOrCb.__reatom\n        if (inTr) return actualize(this, proto).state\n        let cache = read(proto)\n\n        return cache !== undefined &&\n          (proto.computer === null || isConnected(cache))\n          ? cache.state\n          : this.get(() => actualize(this, proto).state)\n      }\n\n      throwReatomError(trError !== null, 'tr failed')\n\n      if (inTr) return atomOrCb(read, actualize)\n\n      inTr = true\n      trNearEffectsStart = nearEffects.length\n      trLateEffectsStart = lateEffects.length\n      let start = CTX === undefined\n      if (start) CTX = this\n\n      try {\n        var result = atomOrCb(read, actualize)\n\n        for (let i = 0; i < trLogs.length; i++) {\n          let { listeners, proto } = trLogs[i]!\n          if (listeners.size > 0) actualize(this, proto)\n          if (trUpdates.length > 0 /* TODO `&& trLogs.length === i + 1` */) {\n            for (let commit of trUpdates.splice(0)) commit(this)\n          }\n        }\n\n        if (trLogs.length) for (let log of logsListeners) log(trLogs)\n\n        for (let patch of trLogs) {\n          let { proto, state } = patch\n          if (proto.isAction) patch.state = []\n\n          if (patch === proto.patch) {\n            proto.patch = null\n            proto.actual = false\n\n            caches.set(proto, patch)\n\n            if (proto.isAction) {\n              if (state.length === 0) continue\n              for (let cb of patch.listeners) {\n                nearEffects.push(() => cb(state))\n              }\n            } else {\n              for (let cb of patch.listeners) {\n                lateEffects.push(() => cb(read(proto)!.state))\n              }\n            }\n          }\n        }\n      } catch (e: any) {\n        trError = e = e instanceof Error ? e : new Error(String(e))\n        for (let log of logsListeners) log(trLogs, e)\n        for (let cb of trRollbacks) callSafely(cb, e)\n        for (let { proto } of trLogs) {\n          proto.patch = null\n          proto.actual = false\n        }\n\n        nearEffects.length = trNearEffectsStart\n        lateEffects.length = trLateEffectsStart\n\n        throw e\n      } finally {\n        inTr = false\n        trError = null\n        trUpdates = []\n        trRollbacks = []\n        trLogs = []\n        if (start) CTX = undefined\n      }\n\n      walkLateEffects()\n\n      return result\n    },\n    spy: undefined,\n    schedule(cb, step = 1) {\n      assertFunction(cb)\n      throwReatomError(!this, 'missed context')\n\n      return new Promise<any>((res, rej) => {\n        if (step === -1) inTr && trRollbacks.push(cb)\n        else if (step === 0) inTr && trUpdates.push(() => cb(this))\n        else {\n          let target = step === 1 ? nearEffects : lateEffects\n          target.push(() => {\n            try {\n              let result = cb(this)\n              result instanceof Promise ? result.then(res, rej) : res(result)\n              return result\n            } catch (error) {\n              rej(error)\n              throw error\n            }\n          })\n          inTr || walkLateEffects()\n        }\n      })\n    },\n    // @ts-ignore\n    subscribe(atom, cb = atom) {\n      assertFunction(cb)\n\n      if (atom === cb) {\n        logsListeners.add(cb)\n        return () => logsListeners.delete(cb)\n      }\n\n      let { __reatom: proto } = atom as Atom\n\n      let lastState = impossibleValue\n      let listener = (state: any) =>\n        Object.is(lastState, state) || cb((lastState = state))\n\n      let cache = read(proto)\n\n      if (cache === undefined || !isConnected(cache)) {\n        this.get(() => {\n          cache = actualize(this, proto, (patchCtx, patch) => {})\n          cache.listeners.add(listener)\n          trRollbacks.push(() => proto.patch!.listeners.delete(listener))\n          if (proto.connectHooks !== null) {\n            nearEffects.push(...proto.connectHooks)\n          }\n          for (let pubPatch of cache.pubs) connect(proto, pubPatch)\n        })\n      } else {\n        cache.listeners.add(listener)\n      }\n\n      if (lastState === impossibleValue) {\n        listener((proto.patch ?? read(proto)!).state)\n      }\n\n      return () => {\n        if (cache!.listeners.delete(listener) && !isConnected(cache!)) {\n          if (!inTr) {\n            trNearEffectsStart = nearEffects.length\n            trLateEffectsStart = lateEffects.length\n          }\n          proto.disconnectHooks && nearEffects.push(...proto.disconnectHooks)\n\n          for (let pubCache of cache!.pubs) {\n            disconnect(proto, pubCache)\n          }\n\n          if (!inTr) {\n            trRollbacks.length = 0\n            walkLateEffects()\n          }\n        }\n      }\n    },\n    cause: undefined as any,\n  }\n\n  ;(ctx.cause = ctx.get(() => actualize(ctx, __root))).cause = null\n\n  return ctx\n}\n\nlet i = 0\n/**\n * @internal\n * @deprecated\n */\nexport let __count = (name: string) => `${name}#${++i}`\n\nexport function atom<T>(initState: (ctx: CtxSpy) => T, name?: string): Atom<T>\nexport function atom<T>(initState: T, name?: string): AtomMut<T>\nexport function atom<T>(\n  initState: T | ((ctx: CtxSpy) => T),\n  name = __count('_atom'),\n): Atom<T> | AtomMut<T> {\n  // TODO: it took much longer than expected in profiling\n  let theAtom: any = (ctx: Ctx, update: any) =>\n    ctx.get(\n      (read, actualize) =>\n        actualize!(ctx, theAtom.__reatom, (patchCtx: Ctx, patch: AtomCache) => {\n          patch.state =\n            typeof update === 'function'\n              ? update(patch.state, patchCtx)\n              : update\n        }).state,\n    )\n  let computer = null\n\n  let initStateResult: typeof initState | undefined = initState\n  if (typeof initState === 'function') {\n    theAtom = {}\n    computer = initState\n    initStateResult = undefined\n  }\n\n  theAtom.__reatom = {\n    name,\n    isAction: false,\n    patch: null,\n    initState: () => initStateResult,\n    computer,\n    connectHooks: null,\n    disconnectHooks: null,\n    updateHooks: null,\n    actual: false,\n  }\n\n  theAtom.pipe = function (this: Atom, ...fns: Array<Fn>) {\n    return fns.reduce((acc, fn) => fn(acc), this)\n  }\n  theAtom.onChange = function (this: Atom, cb: Fn) {\n    const hook = (ctx: Ctx, patch: AtomCache) => cb(ctx, patch.state)\n\n    ;(this.__reatom.updateHooks ??= new Set()).add(hook)\n\n    return () => this.__reatom.updateHooks!.delete(hook)\n  }\n\n  return theAtom\n}\n\nexport const action: {\n  (name?: string): Action<[], void>\n\n  <T>(name?: string): Action<[T], T>\n\n  <Params extends any[] = any[], Res = void>(\n    fn: (ctx: Ctx, ...params: Params) => Res,\n    name?: string,\n  ): Action<Params, Res>\n} = (fn?: string | Fn, name?: string): any => {\n  if (fn === undefined || typeof fn === 'string') {\n    name = fn\n    fn = (ctx: Ctx, v?: any) => v\n  }\n\n  assertFunction(fn)\n\n  let actionAtom = atom<Array<any>>([], name ?? __count('_action'))\n  actionAtom.__reatom.isAction = true\n  // @ts-expect-error\n  actionAtom.__reatom.unstable_fn = fn\n\n  return Object.assign(\n    (...params: [Ctx, ...any[]]) => {\n      let state = actionAtom(params[0], (state, patchCtx) => {\n        params[0] = patchCtx\n        return [\n          ...state,\n          {\n            params: params.slice(1),\n            // @ts-expect-error\n            payload: patchCtx.cause.proto.unstable_fn(...params),\n          },\n        ]\n      })\n      return state[state.length - 1]!.payload\n    },\n    actionAtom,\n    {\n      onCall(this: Action, cb: Fn): Unsubscribe {\n        return this.onChange((ctx, state) => {\n          const { params, payload } = state[state.length - 1]!\n          cb(ctx, payload, params)\n        })\n      },\n    },\n  )\n}\n\n/**\n * @internal\n * @deprecated\n */\nexport const __root = atom(undefined, 'root').__reatom\n"],"names":["impossibleValue","Symbol","callSafely","fn","slice","call","arguments","err","setTimeout","Error","throwReatomError","condition","message","isAtom","thing","undefined","__reatom","isConnected","cache","subs","size","listeners","assertFunction","getRootCause","cause","CTX","i","__count","name","atom","initState","theAtom","ctx","update","get","read","actualize","patchCtx","patch","state","computer","initStateResult","isAction","connectHooks","disconnectHooks","updateHooks","actual","pipe","reduce","acc","this","onChange","cb","hook","Set","add","delete","__root","action","v","actionAtom","unstable_fn","Object","assign","params","payload","proto","length","onCall","_temp","callLateEffect","callNearEffect","caches","WeakMap","logsListeners","nearEffects","lateEffects","inTr","trError","trUpdates","trRollbacks","trLogs","trNearEffectsStart","trLateEffectsStart","walkNearEffects","effect","walkLateEffects","addPatch","_ref","pubs","push","enqueueComputers","subProto","keys","subCache","disconnect","pubPatch","parentParent","connect","has","wasConnected","parentParentPatch","updater","updating","isInt","spy","schedule","subscribe","actualizePubs","toDisconnect","toConnect","some","_ref2","is","newPubs","_ref3","depProto","depPatch","prevDepPatch","isDepChanged","forEach","error","atomOrCb","start","result","commit","splice","log","set","e","String","step","Promise","res","rej","then","lastState","listener","pubCache"],"mappings":"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"}