{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  action,\n  Action,\n  atom,\n  Atom,\n  AtomCache,\n  AtomState,\n  Ctx,\n  CtxSpy,\n  Fn,\n  throwReatomError,\n  Unsubscribe,\n} from '@reatom/core'\nimport { noop, toAbortError, isAbort, merge } from '@reatom/utils'\n\nexport const getRootCause = (cause: AtomCache): AtomCache =>\n  cause.cause === null ? cause : getRootCause(cause.cause)\n\nexport const isSameCtx = (ctx1: Ctx, ctx2: Ctx) =>\n  getRootCause(ctx1.cause) === getRootCause(ctx2.cause)\n\nexport const addOnConnect = (anAtom: Atom, cb: Fn<[Ctx]>) =>\n  (anAtom.__reatom.connectHooks ??= new Set()).add(cb)\n\nexport const addOnDisconnect = (anAtom: Atom, cb: Fn<[Ctx]>) =>\n  (anAtom.__reatom.disconnectHooks ??= new Set()).add(cb)\n\nexport const addOnUpdate = <T extends Atom>(\n  anAtom: T,\n  cb: Fn<[Ctx, AtomCache<AtomState<T>>]>,\n) => (anAtom.__reatom.updateHooks ??= new Set()).add(cb)\n\nexport const withInit =\n  <T extends Atom>(\n    createState: Fn<[Ctx, T['__reatom']['initState']], AtomState<T>>,\n  ): Fn<[T], T> =>\n  (anAtom) => {\n    const { initState, isAction } = anAtom.__reatom\n\n    throwReatomError(isAction, 'action state is not manageable')\n\n    anAtom.__reatom.initState = (ctx) => createState(ctx, initState)\n\n    return anAtom\n  }\n\nexport const onConnect = (\n  anAtom: Atom,\n  cb: Fn<[Ctx & { controller: AbortController; isConnected(): boolean }]>,\n): Unsubscribe => {\n  const connectHook = (ctx: Ctx) => {\n    const controller = new AbortController()\n    const cleanup = cb(\n      merge(ctx, {\n        // TODO: how to do it more performant\n        cause: merge(\n          ctx.get((read) => read(anAtom.__reatom)!),\n          { controller },\n        ),\n        controller,\n        isConnected: () => isConnected(ctx, anAtom),\n      }),\n    )\n\n    if (cleanup instanceof Promise) {\n      cleanup.catch((error) => {\n        if (!isAbort(error)) throw error\n      })\n    }\n\n    // TODO: abort on `connectHooks.delete`?\n    const cleanupHook = (_ctx: Ctx) => {\n      if (\n        isSameCtx(ctx, _ctx) &&\n        disconnectHooks.delete(cleanupHook) &&\n        connectHooks.has(connectHook)\n      ) {\n        controller.abort(toAbortError(`${anAtom.__reatom.name} disconnect`))\n        typeof cleanup === 'function' && cleanup()\n      }\n    }\n\n    const disconnectHooks = addOnDisconnect(anAtom, cleanupHook)\n  }\n\n  const connectHooks = addOnConnect(anAtom, connectHook)\n\n  return () => connectHooks.delete(connectHook)\n}\n\nexport const onDisconnect = (anAtom: Atom, cb: Fn<[Ctx]>): Unsubscribe =>\n  onConnect(anAtom, (ctx) => () => cb(ctx))\n\n// @ts-expect-error\nconst _onUpdate: {\n  <Params extends any[], Payload>(\n    anAction: Action<Params, Payload> & { deps?: Array<Atom> },\n    cb?: Fn<\n      [\n        Ctx,\n        Payload,\n        AtomCache<AtomState<Action<Params, Payload>>> & { params: Params },\n      ]\n    >,\n  ): Unsubscribe\n  <T>(\n    anAtom: Atom<T> & { deps?: Array<Atom> },\n    cb?: Fn<[Ctx, T, AtomCache<T>]>,\n  ): Unsubscribe\n} = <T>(\n  anAtom: Action<any[], T> | Atom<T>,\n  cb: Fn<[Ctx, T, AtomCache<T>]> = noop,\n) => {\n  const hook = (ctx: Ctx, patch: AtomCache & { params?: unknown[] }) => {\n    let { state } = patch\n    if (anAtom.__reatom.isAction) {\n      if (patch.state.length === 0) return\n      const call = state.at(-1)!\n      state = call.payload\n      patch.params = call.params\n    }\n    cb(ctx, state, patch)\n  }\n\n  const hooks = addOnUpdate(anAtom, hook)\n\n  return () => hooks.delete(hook)\n}\n\nexport const onUpdate: typeof _onUpdate = (anAtom: Atom, cb = noop) =>\n  ((anAtom as Atom & { deps?: Array<Atom> }).deps ?? []).reduce((acc, dep) => {\n    const un = onUpdate(dep, (ctx) => ctx.get(anAtom))\n    return () => {\n      un()\n      acc()\n    }\n  }, _onUpdate(anAtom, cb) as Unsubscribe)\n\n/** @deprecated use the second parameter of `ctx.spy` instead */\n// @ts-ignore\nexport const spyChange: {\n  <Params extends any[], Payload>(\n    ctx: CtxSpy,\n    anAction: Action<Params, Payload>,\n    handler?: Fn<[{ params: Params; payload: Payload }]>,\n  ): boolean\n  <T>(ctx: CtxSpy, anAtom: Atom<T>, handler?: Fn<[T, T?]>): boolean\n} = (ctx: CtxSpy, anAtom: Atom, handler?: Fn) => {\n  let isChanged = false\n  ctx.spy(anAtom, (newState, prevState) => {\n    isChanged = true\n    handler?.(newState, prevState)\n  })\n  return isChanged\n}\n\nexport const controlConnection =\n  <T>(\n    initState = true,\n    name?: string,\n  ): Fn<\n    [Atom<T>],\n    Atom<T> & { toggleConnection: Action<[boolean?], boolean> }\n  > =>\n  (anAtom) => {\n    name ??= `${anAtom.__reatom.name}.controlConnection`\n\n    const isActiveAtom = atom(initState, `${name}._isActiveAtom`)\n\n    return Object.assign(\n      {\n        toggleConnection: action(\n          (ctx, value) => isActiveAtom(ctx, (state) => value ?? !state),\n          `${name}.toggleConnection`,\n        ),\n      },\n      atom(\n        (ctx, state?: any) => (ctx.spy(isActiveAtom) ? ctx.spy(anAtom) : state),\n        name,\n      ),\n    )\n  }\n\nexport const isConnected = (ctx: Ctx, { __reatom: proto }: Atom) =>\n  ctx.get((read) => {\n    const cache = proto.patch ?? read(proto)\n    return !!cache && cache.subs.size + cache.listeners.size > 0\n  })\n"],"names":["getRootCause","cause","isSameCtx","ctx1","ctx2","addOnConnect","anAtom","cb","__reatom","connectHooks","Set","add","addOnDisconnect","disconnectHooks","addOnUpdate","updateHooks","withInit","createState","initState","isAction","throwReatomError","ctx","onConnect","connectHook","controller","AbortController","cleanup","merge","get","read","isConnected","Promise","catch","error","isAbort","cleanupHook","_ctx","delete","has","abort","toAbortError","name","onDisconnect","onUpdate","noop","deps","reduce","acc","dep","un","hook","patch","state","length","call","at","payload","params","hooks","_onUpdate","spyChange","handler","isChanged","spy","newState","prevState","controlConnection","isActiveAtom","atom","Object","assign","toggleConnection","action","value","_ref","proto","cache","subs","size","listeners"],"mappings":"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"}