var core=require("@reatom/core"),utils=require("@reatom/utils");const getRootCause=cause=>null===cause.cause?cause:getRootCause(cause.cause),isSameCtx=(ctx1,ctx2)=>getRootCause(ctx1.cause)===getRootCause(ctx2.cause),addOnConnect=(anAtom,cb)=>(anAtom.__reatom.connectHooks??=new Set).add(cb),addOnDisconnect=(anAtom,cb)=>(anAtom.__reatom.disconnectHooks??=new Set).add(cb),addOnUpdate=(anAtom,cb)=>(anAtom.__reatom.updateHooks??=new Set).add(cb),onConnect=(anAtom,cb)=>{const connectHook=ctx=>{const controller=new AbortController,cleanup=cb(utils.merge(ctx,{cause:utils.merge(ctx.get(read=>read(anAtom.__reatom)),{controller:controller}),controller:controller,isConnected:()=>isConnected(ctx,anAtom)}));cleanup instanceof Promise&&cleanup.catch(error=>{if(!utils.isAbort(error))throw error});const cleanupHook=_ctx=>{isSameCtx(ctx,_ctx)&&disconnectHooks.delete(cleanupHook)&&connectHooks.has(connectHook)&&(controller.abort(utils.toAbortError(`${anAtom.__reatom.name} disconnect`)),"function"==typeof cleanup&&cleanup())},disconnectHooks=addOnDisconnect(anAtom,cleanupHook)},connectHooks=addOnConnect(anAtom,connectHook);return()=>connectHooks.delete(connectHook)},onUpdate=function(anAtom,cb){return void 0===cb&&(cb=utils.noop),(anAtom.deps??[]).reduce((acc,dep)=>{const un=onUpdate(dep,ctx=>ctx.get(anAtom));return()=>{un(),acc()}},function(anAtom,cb){void 0===cb&&(cb=utils.noop);const hook=(ctx,patch)=>{let{state:state}=patch;if(anAtom.__reatom.isAction){if(0===patch.state.length)return;const call=state.at(-1);state=call.payload,patch.params=call.params}cb(ctx,state,patch)},hooks=addOnUpdate(anAtom,hook);return()=>hooks.delete(hook)}(anAtom,cb))},isConnected=(ctx,_ref)=>{let{__reatom:proto}=_ref;return ctx.get(read=>{const cache=proto.patch??read(proto);return!!cache&&cache.subs.size+cache.listeners.size>0})};exports.addOnConnect=addOnConnect,exports.addOnDisconnect=addOnDisconnect,exports.addOnUpdate=addOnUpdate,exports.controlConnection=function(initState,name){return void 0===initState&&(initState=!0),anAtom=>{name??=`${anAtom.__reatom.name}.controlConnection`;const isActiveAtom=core.atom(initState,`${name}._isActiveAtom`);return Object.assign({toggleConnection:core.action((ctx,value)=>isActiveAtom(ctx,state=>value??!state),`${name}.toggleConnection`)},core.atom((ctx,state)=>ctx.spy(isActiveAtom)?ctx.spy(anAtom):state,name))}},exports.getRootCause=getRootCause,exports.isConnected=isConnected,exports.isSameCtx=isSameCtx,exports.onConnect=onConnect,exports.onDisconnect=(anAtom,cb)=>onConnect(anAtom,ctx=>()=>cb(ctx)),exports.onUpdate=onUpdate,exports.spyChange=(ctx,anAtom,handler)=>{let isChanged=!1;return ctx.spy(anAtom,(newState,prevState)=>{isChanged=!0,handler?.(newState,prevState)}),isChanged},exports.withInit=createState=>anAtom=>{const{initState:initState,isAction:isAction}=anAtom.__reatom;return core.throwReatomError(isAction,"action state is not manageable"),anAtom.__reatom.initState=ctx=>createState(ctx,initState),anAtom};
//# sourceMappingURL=index.js.map
