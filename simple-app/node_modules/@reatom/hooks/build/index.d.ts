import { Action, Atom, AtomCache, AtomState, Ctx, CtxSpy, Fn, Unsubscribe } from '@reatom/core';
export declare const getRootCause: (cause: AtomCache) => AtomCache;
export declare const isSameCtx: (ctx1: Ctx, ctx2: Ctx) => boolean;
export declare const addOnConnect: (anAtom: Atom, cb: Fn<[Ctx]>) => Set<Fn<[Ctx], any>>;
export declare const addOnDisconnect: (anAtom: Atom, cb: Fn<[Ctx]>) => Set<Fn<[Ctx], any>>;
export declare const addOnUpdate: <T extends Atom<any>>(anAtom: T, cb: Fn<[Ctx, AtomCache<AtomState<T>>], any>) => Set<Fn<[Ctx, AtomCache<any>], any>>;
export declare const withInit: <T extends Atom<any>>(createState: Fn<[Ctx, T["__reatom"]["initState"]], AtomState<T>>) => Fn<[T], T>;
export declare const onConnect: (anAtom: Atom, cb: Fn<[Ctx & {
    controller: AbortController;
    isConnected(): boolean;
}]>) => Unsubscribe;
export declare const onDisconnect: (anAtom: Atom, cb: Fn<[Ctx]>) => Unsubscribe;
declare const _onUpdate: {
    <Params extends any[], Payload>(anAction: Action<Params, Payload> & {
        deps?: Array<Atom>;
    }, cb?: Fn<[
        Ctx,
        Payload,
        AtomCache<AtomState<Action<Params, Payload>>> & {
            params: Params;
        }
    ]>): Unsubscribe;
    <T>(anAtom: Atom<T> & {
        deps?: Array<Atom>;
    }, cb?: Fn<[Ctx, T, AtomCache<T>]>): Unsubscribe;
};
export declare const onUpdate: typeof _onUpdate;
/** @deprecated use the second parameter of `ctx.spy` instead */
export declare const spyChange: {
    <Params extends any[], Payload>(ctx: CtxSpy, anAction: Action<Params, Payload>, handler?: Fn<[{
        params: Params;
        payload: Payload;
    }]>): boolean;
    <T>(ctx: CtxSpy, anAtom: Atom<T>, handler?: Fn<[T, T?]>): boolean;
};
export declare const controlConnection: <T>(initState?: boolean, name?: string) => Fn<[Atom<T>], Atom<T> & {
    toggleConnection: Action<[boolean?], boolean>;
}>;
export declare const isConnected: (ctx: Ctx, { __reatom: proto }: Atom) => boolean;
export {};
//# sourceMappingURL=index.d.ts.map