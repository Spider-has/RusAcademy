{"version":3,"file":"index.js","sources":["../src/withReducers.ts","../src/reatomArray.ts","../src/reatomBoolean.ts","../src/reatomEnum.ts","../src/reatomMap.ts","../src/reatomNumber.ts","../src/reatomRecord.ts","../src/reatomSet.ts","../src/reatomString.ts"],"sourcesContent":["import { action, Action, AtomMut, AtomState, Fn, Rec } from '@reatom/core'\n\ninterface Reducers<A extends AtomMut>\n  extends Rec<(state: AtomState<A>, ...args: Array<any>) => AtomState<A>> {}\n\nexport type WithReducers<A extends AtomMut, R extends Reducers<A>> = A & {\n  [K in keyof R]: R[K] extends Fn<[any, ...infer Args]>\n    ? Action<Args, AtomState<A>>\n    : never\n}\n\nexport const withReducers =\n  <A extends AtomMut, R extends Reducers<A>>(reducers: R) =>\n  (anAtom: A): WithReducers<A, R> =>\n    Object.keys(reducers).reduce((anAtom, k) => {\n      // @ts-expect-error\n      anAtom[k] = action(\n        (ctx, ...args) => anAtom(ctx, reducers[k]!(ctx.get(anAtom), ...args)),\n        `${anAtom.__reatom.name}._${k}`,\n      )\n      return anAtom\n    }, anAtom) as any\n","import { atom, AtomMut } from '@reatom/core'\r\nimport { withReducers, WithReducers } from './withReducers'\r\n\r\nexport type ArrayAtom<T> = WithReducers<\r\n  AtomMut<Array<T>>,\r\n  {\r\n    toReversed(state: Array<T>): Array<T>\r\n    toSorted(state: Array<T>, compareFn?: (a: T, b: T) => number): Array<T>\r\n    toSpliced(\r\n      state: Array<T>,\r\n      start: number,\r\n      deleteCount: number,\r\n      ...items: T[]\r\n    ): Array<T>\r\n    with(state: Array<T>, index: number, value: T): Array<T>\r\n  }\r\n>\r\n\r\nexport const reatomArray = <T>(\r\n  initState = new Array<T>(),\r\n  name?: string,\r\n): ArrayAtom<T> => {\r\n  return atom(initState, name).pipe(\r\n    withReducers({\r\n      toReversed: (state) => state.slice(0).reverse(),\r\n      toSorted: (state, compareFn) => state.slice(0).sort(compareFn),\r\n      toSpliced: (state, start, deleteCount, ...items) => {\r\n        state = state.slice(0)\r\n        state.splice(start, deleteCount, ...items)\r\n\r\n        return state\r\n      },\r\n      with: (state, index, value) => {\r\n        if (Object.is(state.at(index), value)) return state\r\n\r\n        state = state.slice(0)\r\n        state[index] = value\r\n\r\n        return state\r\n      },\r\n    }),\r\n  )\r\n}\r\n","import { atom, AtomMut } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\nexport type BooleanReducers = {\n  toggle: () => boolean\n  setTrue: () => boolean\n  setFalse: () => boolean\n  reset: () => boolean\n}\n\nexport type BooleanAtom = WithReducers<AtomMut<boolean>, BooleanReducers>\n\nexport const reatomBoolean = (initState = false, name?: string): BooleanAtom =>\n  atom(initState, name).pipe(\n    withReducers({\n      toggle: (state) => !state,\n      setTrue: () => true,\n      setFalse: () => false,\n      reset: () => initState,\n    }),\n  )\n","import { atom, AtomMut, Rec } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\nexport type EnumAtom<\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n> = WithReducers<\n  AtomMut<T>,\n  {\n    [K in T as Format extends 'camelCase'\n      ? `set${Capitalize<K>}`\n      : Format extends 'snake_case'\n      ? `set_${K}`\n      : never]: () => K\n  } & {\n    reset: () => T\n  }\n> & {\n  enum: { [K in T]: K }\n}\n\nexport type EnumAtomOptions<\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n> = {\n  name?: string\n  format?: Format\n  initState?: T extends any ? T : never\n}\n\nexport const reatomEnum = <\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n>(\n  variants: ReadonlyArray<T>,\n  options: string | EnumAtomOptions<T, Format> = {},\n): EnumAtom<T, Format> => {\n  const {\n    name,\n    format = 'camelCase' as Format,\n    initState = variants[0],\n  }: EnumAtomOptions<T, Format> = typeof options === 'string'\n    ? { name: options }\n    : options\n  const cases = {} as Rec\n  const reducers = {} as Rec\n\n  for (const variant of variants) {\n    cases[variant] = variant\n\n    const reducerName = variant.replace(\n      /^./,\n      (firstLetter) =>\n        'set' +\n        (format === 'camelCase'\n          ? firstLetter.toUpperCase()\n          : `_${firstLetter}`),\n    )\n    reducers[reducerName] = () => variant\n  }\n\n  reducers.reset = () => initState\n\n  // @ts-expect-error\n  return Object.assign(atom(initState, name).pipe(withReducers(reducers)), {\n    enum: cases,\n  })\n}\n","import { Action, atom, AtomMut, Ctx, Fn } from '@reatom/core'\nimport { assign } from '@reatom/utils'\nimport { withReducers } from './withReducers'\n\nexport interface MapAtomReducers<Key, Element> {\n  set(state: Map<Key, Element>, key: Key, el: Element): Map<Key, Element>\n  delete(state: Map<Key, Element>, key: Key): Map<Key, Element>\n  clear(): Map<Key, Element>\n  reset(): Map<Key, Element>\n}\n\nexport interface MapAtom<Key, Element> extends AtomMut<Map<Key, Element>> {\n  set: Action<[key: Key, el: Element], Map<Key, Element>>\n  delete: Action<[key: Key], Map<Key, Element>>\n  clear: Action<[], Map<Key, Element>>\n  reset: Action<[], Map<Key, Element>>\n  get: Fn<[Ctx, Key], Element | undefined>\n  has: Fn<[Ctx, Key], boolean>\n}\n\nexport const reatomMap = <Key, Element>(\n  initState = new Map<Key, Element>(),\n  name?: string,\n): MapAtom<Key, Element> => {\n  const theAtom = atom(initState, name).pipe(\n    withReducers({\n      set: (state, key, el) => {\n        const prevEl = state.get(key)\n\n        if (Object.is(prevEl, el) && (el !== undefined || state.has(key))) {\n          return state\n        }\n\n        return new Map(state).set(key, el)\n      },\n      delete: (state, key) => {\n        if (!state.has(key)) return state\n        const newState = new Map(state)\n        newState.delete(key)\n        return newState\n      },\n      clear: () => new Map(),\n      reset: () => initState,\n    }),\n  )\n\n  return assign(theAtom, {\n    get: (ctx: Ctx, key: any) => ctx.get(theAtom).get(key),\n    has: (ctx: Ctx, key: any) => ctx.get(theAtom).has(key),\n  })\n}\n","import { atom, AtomMut } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\n// it would be better for semantic use additional `add` and `subtract`\n// but is it really needed to take slow down creation and increase mem usage?\nexport type NumberAtomReducers = {\n  increment(state: number, value?: number): number\n  decrement(state: number, value?: number): number\n  random(): number\n  reset(): number\n}\n\nexport type NumberAtom = WithReducers<AtomMut<number>, NumberAtomReducers>\n\nexport const reatomNumber = (initState = 0, name?: string): NumberAtom =>\n  atom(initState, name).pipe(\n    withReducers({\n      increment: (state, value = 1) => state + value,\n      decrement: (state, value = 1) => state - value,\n      random: Math.random,\n      reset: () => initState,\n    }),\n  )\n","import { atom, AtomMut, Rec } from '@reatom/core'\r\nimport { omit } from '@reatom/utils'\r\nimport { withReducers, WithReducers } from './withReducers'\r\n\r\nexport type RecordAtom<T extends Rec> = WithReducers<\r\n  AtomMut<T>,\r\n  {\r\n    merge(state: T, slice: Partial<T>): T\r\n    omit(state: T, ...keys: Array<keyof T>): T\r\n    reset(state: T, ...keys: Array<keyof T>): T\r\n  }\r\n>\r\n\r\nexport const reatomRecord = <T extends Rec>(\r\n  initState: T,\r\n  name?: string,\r\n): RecordAtom<T> => {\r\n  return atom(initState, name).pipe(\r\n    withReducers({\r\n      merge: (state, slice: Partial<T>) => {\r\n        for (const key in slice) {\r\n          if (!Object.is(slice[key], state[key])) {\r\n            return Object.assign({}, state, slice)\r\n          }\r\n        }\r\n\r\n        return state\r\n      },\r\n      omit: (state, ...keys) =>\r\n        keys.some((k) => k in state)\r\n          ? // @ts-expect-error\r\n            (omit(state, keys) as typeof state)\r\n          : state,\r\n      reset: (state, ...keys) => {\r\n        if (keys.length === 0) return initState\r\n\r\n        const newState: T = {} as T\r\n        let changed = false\r\n        for (const key in state) {\r\n          if (keys.includes(key)) {\r\n            if (key in initState) {\r\n              newState[key] = initState[key]\r\n              changed ||= !Object.is(state[key], initState[key])\r\n            } else {\r\n              changed ||= key in state\r\n            }\r\n          } else {\r\n            newState[key] = state[key]\r\n          }\r\n        }\r\n        return changed ? newState : state\r\n      },\r\n    }),\r\n  )\r\n}\r\n","import { Action, atom, AtomMut, Ctx, Fn } from '@reatom/core'\nimport { assign } from '@reatom/utils'\nimport { withReducers } from './withReducers'\n\nexport interface SetAtom<T> extends AtomMut<Set<T>> {\n  set: Action<[el: T], Set<T>>\n  delete: Action<[el: T], Set<T>>\n  clear: Action<[], Set<T>>\n  reset: Action<[], Set<T>>\n  has: Fn<[Ctx, T], boolean>\n}\n\nexport const reatomSet = <T>(\n  initState = new Set<T>(),\n  name?: string,\n): SetAtom<T> => {\n  const theAtom = atom(initState, name).pipe(\n    withReducers({\n      set: (state, el) => (state.has(el) ? state : new Set(state).add(el)),\n      delete: (state, el) => {\n        if (!state.has(el)) return state\n        const newState = new Set(state)\n        newState.delete(el)\n        return newState\n      },\n      clear: () => new Set(),\n      reset: () => initState,\n    }),\n  )\n\n  return assign(theAtom, {\n    has: (ctx: Ctx, el: T) => ctx.get(theAtom).has(el),\n  })\n}\n","import { atom, AtomMut } from '@reatom/core'\nimport { WithReducers, withReducers } from './withReducers'\n\nexport type StringAtom<State extends string = string> = WithReducers<\n  AtomMut<State>,\n  {\n    reset: () => State\n  }\n>\n\nexport const reatomString: {\n  (initState?: string, name?: string): StringAtom\n  <T extends string>(initState: T, name?: string): StringAtom<T>\n} = (initState = '' as string, name?: string) =>\n  atom(initState, name).pipe(withReducers({ reset: () => initState }))\n"],"names":["withReducers","reducers","anAtom","Object","keys","reduce","k","action","ctx","get","slice","call","arguments","__reatom","name","initState","Array","atom","pipe","toReversed","state","reverse","toSorted","compareFn","sort","toSpliced","start","deleteCount","splice","with","index","value","is","at","toggle","setTrue","setFalse","reset","variants","options","format","cases","variant","replace","firstLetter","toUpperCase","assign","enum","Map","theAtom","set","key","el","prevEl","undefined","has","delete","newState","clear","increment","decrement","random","Math","reatomRecord","merge","omit","some","length","changed","includes","Set","add"],"mappings":"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"}