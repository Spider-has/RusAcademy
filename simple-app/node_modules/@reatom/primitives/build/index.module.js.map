{"version":3,"file":"index.module.js","sources":["../src/withReducers.ts","../src/reatomArray.ts","../src/reatomBoolean.ts","../src/reatomEnum.ts","../src/reatomMap.ts","../src/reatomNumber.ts","../src/reatomRecord.ts","../src/reatomSet.ts","../src/reatomString.ts"],"sourcesContent":["import { action, Action, AtomMut, AtomState, Fn, Rec } from '@reatom/core'\n\ninterface Reducers<A extends AtomMut>\n  extends Rec<(state: AtomState<A>, ...args: Array<any>) => AtomState<A>> {}\n\nexport type WithReducers<A extends AtomMut, R extends Reducers<A>> = A & {\n  [K in keyof R]: R[K] extends Fn<[any, ...infer Args]>\n    ? Action<Args, AtomState<A>>\n    : never\n}\n\nexport const withReducers =\n  <A extends AtomMut, R extends Reducers<A>>(reducers: R) =>\n  (anAtom: A): WithReducers<A, R> =>\n    Object.keys(reducers).reduce((anAtom, k) => {\n      // @ts-expect-error\n      anAtom[k] = action(\n        (ctx, ...args) => anAtom(ctx, reducers[k]!(ctx.get(anAtom), ...args)),\n        `${anAtom.__reatom.name}._${k}`,\n      )\n      return anAtom\n    }, anAtom) as any\n","import { atom, AtomMut } from '@reatom/core'\r\nimport { withReducers, WithReducers } from './withReducers'\r\n\r\nexport type ArrayAtom<T> = WithReducers<\r\n  AtomMut<Array<T>>,\r\n  {\r\n    toReversed(state: Array<T>): Array<T>\r\n    toSorted(state: Array<T>, compareFn?: (a: T, b: T) => number): Array<T>\r\n    toSpliced(\r\n      state: Array<T>,\r\n      start: number,\r\n      deleteCount: number,\r\n      ...items: T[]\r\n    ): Array<T>\r\n    with(state: Array<T>, index: number, value: T): Array<T>\r\n  }\r\n>\r\n\r\nexport const reatomArray = <T>(\r\n  initState = new Array<T>(),\r\n  name?: string,\r\n): ArrayAtom<T> => {\r\n  return atom(initState, name).pipe(\r\n    withReducers({\r\n      toReversed: (state) => state.slice(0).reverse(),\r\n      toSorted: (state, compareFn) => state.slice(0).sort(compareFn),\r\n      toSpliced: (state, start, deleteCount, ...items) => {\r\n        state = state.slice(0)\r\n        state.splice(start, deleteCount, ...items)\r\n\r\n        return state\r\n      },\r\n      with: (state, index, value) => {\r\n        if (Object.is(state.at(index), value)) return state\r\n\r\n        state = state.slice(0)\r\n        state[index] = value\r\n\r\n        return state\r\n      },\r\n    }),\r\n  )\r\n}\r\n","import { atom, AtomMut } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\nexport type BooleanReducers = {\n  toggle: () => boolean\n  setTrue: () => boolean\n  setFalse: () => boolean\n  reset: () => boolean\n}\n\nexport type BooleanAtom = WithReducers<AtomMut<boolean>, BooleanReducers>\n\nexport const reatomBoolean = (initState = false, name?: string): BooleanAtom =>\n  atom(initState, name).pipe(\n    withReducers({\n      toggle: (state) => !state,\n      setTrue: () => true,\n      setFalse: () => false,\n      reset: () => initState,\n    }),\n  )\n","import { atom, AtomMut, Rec } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\nexport type EnumAtom<\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n> = WithReducers<\n  AtomMut<T>,\n  {\n    [K in T as Format extends 'camelCase'\n      ? `set${Capitalize<K>}`\n      : Format extends 'snake_case'\n      ? `set_${K}`\n      : never]: () => K\n  } & {\n    reset: () => T\n  }\n> & {\n  enum: { [K in T]: K }\n}\n\nexport type EnumAtomOptions<\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n> = {\n  name?: string\n  format?: Format\n  initState?: T extends any ? T : never\n}\n\nexport const reatomEnum = <\n  T extends string,\n  Format extends 'camelCase' | 'snake_case' = 'camelCase',\n>(\n  variants: ReadonlyArray<T>,\n  options: string | EnumAtomOptions<T, Format> = {},\n): EnumAtom<T, Format> => {\n  const {\n    name,\n    format = 'camelCase' as Format,\n    initState = variants[0],\n  }: EnumAtomOptions<T, Format> = typeof options === 'string'\n    ? { name: options }\n    : options\n  const cases = {} as Rec\n  const reducers = {} as Rec\n\n  for (const variant of variants) {\n    cases[variant] = variant\n\n    const reducerName = variant.replace(\n      /^./,\n      (firstLetter) =>\n        'set' +\n        (format === 'camelCase'\n          ? firstLetter.toUpperCase()\n          : `_${firstLetter}`),\n    )\n    reducers[reducerName] = () => variant\n  }\n\n  reducers.reset = () => initState\n\n  // @ts-expect-error\n  return Object.assign(atom(initState, name).pipe(withReducers(reducers)), {\n    enum: cases,\n  })\n}\n","import { Action, atom, AtomMut, Ctx, Fn } from '@reatom/core'\nimport { assign } from '@reatom/utils'\nimport { withReducers } from './withReducers'\n\nexport interface MapAtomReducers<Key, Element> {\n  set(state: Map<Key, Element>, key: Key, el: Element): Map<Key, Element>\n  delete(state: Map<Key, Element>, key: Key): Map<Key, Element>\n  clear(): Map<Key, Element>\n  reset(): Map<Key, Element>\n}\n\nexport interface MapAtom<Key, Element> extends AtomMut<Map<Key, Element>> {\n  set: Action<[key: Key, el: Element], Map<Key, Element>>\n  delete: Action<[key: Key], Map<Key, Element>>\n  clear: Action<[], Map<Key, Element>>\n  reset: Action<[], Map<Key, Element>>\n  get: Fn<[Ctx, Key], Element | undefined>\n  has: Fn<[Ctx, Key], boolean>\n}\n\nexport const reatomMap = <Key, Element>(\n  initState = new Map<Key, Element>(),\n  name?: string,\n): MapAtom<Key, Element> => {\n  const theAtom = atom(initState, name).pipe(\n    withReducers({\n      set: (state, key, el) => {\n        const prevEl = state.get(key)\n\n        if (Object.is(prevEl, el) && (el !== undefined || state.has(key))) {\n          return state\n        }\n\n        return new Map(state).set(key, el)\n      },\n      delete: (state, key) => {\n        if (!state.has(key)) return state\n        const newState = new Map(state)\n        newState.delete(key)\n        return newState\n      },\n      clear: () => new Map(),\n      reset: () => initState,\n    }),\n  )\n\n  return assign(theAtom, {\n    get: (ctx: Ctx, key: any) => ctx.get(theAtom).get(key),\n    has: (ctx: Ctx, key: any) => ctx.get(theAtom).has(key),\n  })\n}\n","import { atom, AtomMut } from '@reatom/core'\nimport { withReducers, WithReducers } from './withReducers'\n\n// it would be better for semantic use additional `add` and `subtract`\n// but is it really needed to take slow down creation and increase mem usage?\nexport type NumberAtomReducers = {\n  increment(state: number, value?: number): number\n  decrement(state: number, value?: number): number\n  random(): number\n  reset(): number\n}\n\nexport type NumberAtom = WithReducers<AtomMut<number>, NumberAtomReducers>\n\nexport const reatomNumber = (initState = 0, name?: string): NumberAtom =>\n  atom(initState, name).pipe(\n    withReducers({\n      increment: (state, value = 1) => state + value,\n      decrement: (state, value = 1) => state - value,\n      random: Math.random,\n      reset: () => initState,\n    }),\n  )\n","import { atom, AtomMut, Rec } from '@reatom/core'\r\nimport { omit } from '@reatom/utils'\r\nimport { withReducers, WithReducers } from './withReducers'\r\n\r\nexport type RecordAtom<T extends Rec> = WithReducers<\r\n  AtomMut<T>,\r\n  {\r\n    merge(state: T, slice: Partial<T>): T\r\n    omit(state: T, ...keys: Array<keyof T>): T\r\n    reset(state: T, ...keys: Array<keyof T>): T\r\n  }\r\n>\r\n\r\nexport const reatomRecord = <T extends Rec>(\r\n  initState: T,\r\n  name?: string,\r\n): RecordAtom<T> => {\r\n  return atom(initState, name).pipe(\r\n    withReducers({\r\n      merge: (state, slice: Partial<T>) => {\r\n        for (const key in slice) {\r\n          if (!Object.is(slice[key], state[key])) {\r\n            return Object.assign({}, state, slice)\r\n          }\r\n        }\r\n\r\n        return state\r\n      },\r\n      omit: (state, ...keys) =>\r\n        keys.some((k) => k in state)\r\n          ? // @ts-expect-error\r\n            (omit(state, keys) as typeof state)\r\n          : state,\r\n      reset: (state, ...keys) => {\r\n        if (keys.length === 0) return initState\r\n\r\n        const newState: T = {} as T\r\n        let changed = false\r\n        for (const key in state) {\r\n          if (keys.includes(key)) {\r\n            if (key in initState) {\r\n              newState[key] = initState[key]\r\n              changed ||= !Object.is(state[key], initState[key])\r\n            } else {\r\n              changed ||= key in state\r\n            }\r\n          } else {\r\n            newState[key] = state[key]\r\n          }\r\n        }\r\n        return changed ? newState : state\r\n      },\r\n    }),\r\n  )\r\n}\r\n","import { Action, atom, AtomMut, Ctx, Fn } from '@reatom/core'\nimport { assign } from '@reatom/utils'\nimport { withReducers } from './withReducers'\n\nexport interface SetAtom<T> extends AtomMut<Set<T>> {\n  set: Action<[el: T], Set<T>>\n  delete: Action<[el: T], Set<T>>\n  clear: Action<[], Set<T>>\n  reset: Action<[], Set<T>>\n  has: Fn<[Ctx, T], boolean>\n}\n\nexport const reatomSet = <T>(\n  initState = new Set<T>(),\n  name?: string,\n): SetAtom<T> => {\n  const theAtom = atom(initState, name).pipe(\n    withReducers({\n      set: (state, el) => (state.has(el) ? state : new Set(state).add(el)),\n      delete: (state, el) => {\n        if (!state.has(el)) return state\n        const newState = new Set(state)\n        newState.delete(el)\n        return newState\n      },\n      clear: () => new Set(),\n      reset: () => initState,\n    }),\n  )\n\n  return assign(theAtom, {\n    has: (ctx: Ctx, el: T) => ctx.get(theAtom).has(el),\n  })\n}\n","import { atom, AtomMut } from '@reatom/core'\nimport { WithReducers, withReducers } from './withReducers'\n\nexport type StringAtom<State extends string = string> = WithReducers<\n  AtomMut<State>,\n  {\n    reset: () => State\n  }\n>\n\nexport const reatomString: {\n  (initState?: string, name?: string): StringAtom\n  <T extends string>(initState: T, name?: string): StringAtom<T>\n} = (initState = '' as string, name?: string) =>\n  atom(initState, name).pipe(withReducers({ reset: () => initState }))\n"],"names":["withReducers","reducers","anAtom","Object","keys","reduce","k","action","ctx","get","slice","call","arguments","__reatom","name","reatomArray","initState","Array","atom","pipe","toReversed","state","reverse","toSorted","compareFn","sort","toSpliced","start","deleteCount","splice","with","index","value","is","at","reatomBoolean","toggle","setTrue","setFalse","reset","reatomEnum","variants","options","format","cases","variant","replace","firstLetter","toUpperCase","assign","enum","reatomMap","Map","theAtom","set","key","el","prevEl","undefined","has","delete","newState","clear","reatomNumber","increment","decrement","random","Math","reatomRecord","merge","omit","some","length","changed","includes","reatomSet","Set","add","reatomString"],"mappings":"6EAWa,MAAAA,aACgCC,UAC1CC,QACCC,OAAOC,KAAKH,UAAUI,OAAO,CAACH,OAAQI,KAEpCJ,OAAOI,GAAKC,OACV,SAACC,KAAG,OAAcN,OAAOM,IAAKP,SAASK,GAAIE,IAAIC,IAAIP,WAAS,GAAAQ,MAAAC,KAAAC,UAAA,IAAS,EAClE,GAAAV,OAAOW,SAASC,SAASR,KAEvBJ,QACNA,QCHMa,YAAc,SACzBC,UACAF,MAEA,YAHAE,IAAAA,YAAAA,UAAY,IAAIC,OAGTC,KAAKF,UAAWF,MAAMK,KAC3BnB,aAAa,CACXoB,WAAaC,OAAUA,MAAMX,MAAM,GAAGY,UACtCC,SAAUA,CAACF,MAAOG,YAAcH,MAAMX,MAAM,GAAGe,KAAKD,WACpDE,UAAW,SAACL,MAAOM,MAAOC,aAIxB,OAHAP,MAAQA,MAAMX,MAAM,IACdmB,OAAOF,MAAOC,eAAalB,GAAAA,MAAAC,KAAAC,UAAA,IAE1BS,KACT,EACAS,KAAMA,CAACT,MAAOU,MAAOC,SACf7B,OAAO8B,GAAGZ,MAAMa,GAAGH,OAAQC,UAE/BX,MAAQA,MAAMX,MAAM,IACdqB,OAASC,OAH+BX,SAStD,EC9Bac,cAAgB,SAACnB,UAAmBF,MAC/C,YAD4BE,IAAAA,YAAAA,WAAY,GACxCE,KAAKF,UAAWF,MAAMK,KACpBnB,aAAa,CACXoC,OAASf,QAAWA,MACpBgB,QAASA,KAAM,EACfC,SAAUA,KAAM,EAChBC,MAAOA,IAAMvB,YAEhB,ECUUwB,WAAa,SAIxBC,SACAC,cAAA,IAAAA,UAAAA,QAA+C,CAAA,GAE/C,MAAM5B,KACJA,KAAI6B,OACJA,OAAS,YAAqB3B,UAC9BA,UAAYyB,SAAS,IAC4B,iBAAZC,QACnC,CAAE5B,KAAM4B,SACRA,QACEE,MAAQ,CAAA,EACR3C,SAAW,CAAS,EAE1B,IAAK,MAAM4C,WAAWJ,SACpBG,MAAMC,SAAWA,QAUjB5C,SARoB4C,QAAQC,QAC1B,KACCC,aACC,OACY,cAAXJ,OACGI,YAAYC,cACR,IAAAD,iBAEY,IAAMF,QAMhC,OAHA5C,SAASsC,MAAQ,IAAMvB,UAGhBb,OAAO8C,OAAO/B,KAAKF,UAAWF,MAAMK,KAAKnB,aAAaC,WAAY,CACvEiD,KAAMN,OAEV,EC/CaO,UAAY,SACvBnC,UACAF,WADAE,IAAAA,YAAAA,UAAY,IAAIoC,KAGhB,MAAMC,QAAUnC,KAAKF,UAAWF,MAAMK,KACpCnB,aAAa,CACXsD,IAAKA,CAACjC,MAAOkC,IAAKC,MAChB,MAAMC,OAASpC,MAAMZ,IAAI8C,KAEzB,OAAIpD,OAAO8B,GAAGwB,OAAQD,WAAeE,IAAPF,IAAoBnC,MAAMsC,IAAIJ,MACnDlC,MAGE,IAAA+B,IAAI/B,OAAOiC,IAAIC,IAAKC,GAAE,EAEnCI,OAAQA,CAACvC,MAAOkC,OACd,IAAKlC,MAAMsC,IAAIJ,KAAM,OAAOlC,MAC5B,MAAMwC,SAAW,IAAIT,IAAI/B,OAEzB,OADAwC,SAASD,OAAOL,KACTM,UAETC,MAAOA,IAAM,IAAIV,IACjBb,MAAOA,IAAMvB,aAIjB,OAAOiC,OAAOI,QAAS,CACrB5C,IAAKA,CAACD,IAAU+C,MAAa/C,IAAIC,IAAI4C,SAAS5C,IAAI8C,KAClDI,IAAKA,CAACnD,IAAU+C,MAAa/C,IAAIC,IAAI4C,SAASM,IAAIJ,MAEtD,ECpCaQ,aAAe,SAAC/C,UAAeF,MAC1C,gBAD2BE,YAAAA,UAAY,GACvCE,KAAKF,UAAWF,MAAMK,KACpBnB,aAAa,CACXgE,UAAW,SAAC3C,MAAOW,OAAS,YAATA,IAAAA,QAAAA,MAAQ,GAAMX,MAAQW,KAAK,EAC9CiC,UAAW,SAAC5C,MAAOW,mBAAK,IAALA,QAAAA,MAAQ,GAAMX,MAAQW,KAAK,EAC9CkC,OAAQC,KAAKD,OACb3B,MAAOA,IAAMvB,YAEhB,ECTUoD,aAAeA,CAC1BpD,UACAF,OAEOI,KAAKF,UAAWF,MAAMK,KAC3BnB,aAAa,CACXqE,MAAOA,CAAChD,MAAOX,SACb,IAAK,MAAM6C,OAAO7C,MAChB,IAAKP,OAAO8B,GAAGvB,MAAM6C,KAAMlC,MAAMkC,MAC/B,OAAOpD,OAAO8C,OAAO,CAAA,EAAI5B,MAAOX,OAIpC,OAAOW,OAETiD,KAAM,SAACjD,OAAK,IAAKjB,KAAIM,GAAAA,MAAAC,KAAAC,UACnB,GAAA,OAAAR,KAAKmE,KAAMjE,GAAMA,KAAKe,OAEjBiD,KAAKjD,MAAOjB,MACbiB,KAAK,EACXkB,MAAO,SAAClB,OAAU,IAAAjB,KAAI,GAAAM,MAAAC,KAAAC,UAAA,GACpB,GAAoB,IAAhBR,KAAKoE,OAAc,OAAOxD,UAE9B,MAAM6C,SAAc,GACpB,IAAIY,SAAU,EACd,IAAK,MAAMlB,OAAOlC,MACZjB,KAAKsE,SAASnB,KACZA,OAAOvC,WACT6C,SAASN,KAAOvC,UAAUuC,KAC1BkB,WAAatE,OAAO8B,GAAGZ,MAAMkC,KAAMvC,UAAUuC,OAE7CkB,UAAYlB,OAAOlC,MAGrBwC,SAASN,KAAOlC,MAAMkC,KAG1B,OAAOkB,QAAUZ,SAAWxC,KAC9B,KCvCOsD,UAAY,SACvB3D,UACAF,WADAE,IAAAA,YAAAA,UAAY,IAAI4D,KAGhB,MAAMvB,QAAUnC,KAAKF,UAAWF,MAAMK,KACpCnB,aAAa,CACXsD,IAAKA,CAACjC,MAAOmC,KAAQnC,MAAMsC,IAAIH,IAAMnC,MAAQ,IAAIuD,IAAIvD,OAAOwD,IAAIrB,IAChEI,OAAQA,CAACvC,MAAOmC,MACd,IAAKnC,MAAMsC,IAAIH,IAAK,OAAOnC,MAC3B,MAAMwC,SAAW,IAAIe,IAAIvD,OAEzB,OADAwC,SAASD,OAAOJ,IACTK,UAETC,MAAOA,IAAM,IAAIc,IACjBrC,MAAOA,IAAMvB,aAIjB,OAAOiC,OAAOI,QAAS,CACrBM,IAAKA,CAACnD,IAAUgD,KAAUhD,IAAIC,IAAI4C,SAASM,IAAIH,KAEnD,ECvBasB,aAGT,SAAC9D,UAA0BF,MAAF,YAAxBE,IAAAA,YAAAA,UAAY,IACfE,KAAKF,UAAWF,MAAMK,KAAKnB,aAAa,CAAEuC,MAAOA,IAAMvB,YAAa"}