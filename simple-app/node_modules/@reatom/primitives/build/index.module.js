import{action,atom}from"@reatom/core";import{assign,omit}from"@reatom/utils";const withReducers=reducers=>anAtom=>Object.keys(reducers).reduce((anAtom,k)=>(anAtom[k]=action(function(ctx){return anAtom(ctx,reducers[k](ctx.get(anAtom),...[].slice.call(arguments,1)))},`${anAtom.__reatom.name}._${k}`),anAtom),anAtom),reatomArray=function(initState,name){return void 0===initState&&(initState=new Array),atom(initState,name).pipe(withReducers({toReversed:state=>state.slice(0).reverse(),toSorted:(state,compareFn)=>state.slice(0).sort(compareFn),toSpliced:function(state,start,deleteCount){return(state=state.slice(0)).splice(start,deleteCount,...[].slice.call(arguments,3)),state},with:(state,index,value)=>(Object.is(state.at(index),value)||((state=state.slice(0))[index]=value),state)}))},reatomBoolean=function(initState,name){return void 0===initState&&(initState=!1),atom(initState,name).pipe(withReducers({toggle:state=>!state,setTrue:()=>!0,setFalse:()=>!1,reset:()=>initState}))},reatomEnum=function(variants,options){void 0===options&&(options={});const{name:name,format:format="camelCase",initState:initState=variants[0]}="string"==typeof options?{name:options}:options,cases={},reducers={};for(const variant of variants)cases[variant]=variant,reducers[variant.replace(/^./,firstLetter=>"set"+("camelCase"===format?firstLetter.toUpperCase():`_${firstLetter}`))]=()=>variant;return reducers.reset=()=>initState,Object.assign(atom(initState,name).pipe(withReducers(reducers)),{enum:cases})},reatomMap=function(initState,name){void 0===initState&&(initState=new Map);const theAtom=atom(initState,name).pipe(withReducers({set:(state,key,el)=>{const prevEl=state.get(key);return Object.is(prevEl,el)&&(void 0!==el||state.has(key))?state:new Map(state).set(key,el)},delete:(state,key)=>{if(!state.has(key))return state;const newState=new Map(state);return newState.delete(key),newState},clear:()=>new Map,reset:()=>initState}));return assign(theAtom,{get:(ctx,key)=>ctx.get(theAtom).get(key),has:(ctx,key)=>ctx.get(theAtom).has(key)})},reatomNumber=function(initState,name){return void 0===initState&&(initState=0),atom(initState,name).pipe(withReducers({increment:function(state,value){return void 0===value&&(value=1),state+value},decrement:function(state,value){return void 0===value&&(value=1),state-value},random:Math.random,reset:()=>initState}))},reatomRecord=(initState,name)=>atom(initState,name).pipe(withReducers({merge:(state,slice)=>{for(const key in slice)if(!Object.is(slice[key],state[key]))return Object.assign({},state,slice);return state},omit:function(state){var keys=[].slice.call(arguments,1);return keys.some(k=>k in state)?omit(state,keys):state},reset:function(state){var keys=[].slice.call(arguments,1);if(0===keys.length)return initState;const newState={};let changed=!1;for(const key in state)keys.includes(key)?key in initState?(newState[key]=initState[key],changed||=!Object.is(state[key],initState[key])):changed||=key in state:newState[key]=state[key];return changed?newState:state}})),reatomSet=function(initState,name){void 0===initState&&(initState=new Set);const theAtom=atom(initState,name).pipe(withReducers({set:(state,el)=>state.has(el)?state:new Set(state).add(el),delete:(state,el)=>{if(!state.has(el))return state;const newState=new Set(state);return newState.delete(el),newState},clear:()=>new Set,reset:()=>initState}));return assign(theAtom,{has:(ctx,el)=>ctx.get(theAtom).has(el)})},reatomString=function(initState,name){return void 0===initState&&(initState=""),atom(initState,name).pipe(withReducers({reset:()=>initState}))};export{reatomArray,reatomBoolean,reatomEnum,reatomMap,reatomNumber,reatomRecord,reatomSet,reatomString,withReducers};
//# sourceMappingURL=index.module.js.map
