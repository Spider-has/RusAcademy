{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  Atom,\n  AtomCache,\n  AtomReturn,\n  Ctx,\n  Fn,\n  throwReatomError,\n  Unsubscribe,\n} from '@reatom/core'\nimport { AbortError, noop, toAbortError } from '@reatom/utils'\n\nexport const getTopController = (\n  patch: AtomCache & { controller?: AbortController },\n): null | AbortController =>\n  patch.controller ?? (patch.cause && getTopController(patch.cause))\n\n/** Handle abort signal from a cause */\nexport const onCtxAbort = (ctx: Ctx, cb: Fn<[AbortError]>) => {\n  const controller = getTopController(ctx.cause)\n\n  if (controller) {\n    const handler = () => cb(toAbortError(controller.signal.reason))\n\n    if (controller.signal.aborted) handler()\n    else {\n      controller.signal.addEventListener('abort', handler)\n      ctx.schedule(\n        () => controller.signal.removeEventListener('abort', handler),\n        -1,\n      )\n    }\n  }\n}\n\nconst CHAINS = new WeakMap<\n  Promise<any>,\n  {\n    promise: Promise<any>\n    then: Array<Fn>\n    catch: Array<Fn>\n  }\n>()\n// TODO `reatomPromise`\n/**\n * Subscribe to promise result with batching\n * @internal\n * @deprecated\n */\nexport const __thenReatomed = <T>(\n  ctx: Ctx,\n  origin: Promise<T>,\n  onFulfill?: Fn<[value: T, read: Fn, actualize: Fn]>,\n  onReject?: Fn<[error: unknown, read: Fn, actualize: Fn]>,\n): Promise<T> => {\n  let chain = CHAINS.get(origin)\n  if (!chain) {\n    const promise = origin.then(\n      (value: any) => {\n        ctx.get((read, actualize) =>\n          chain!.then.forEach((cb) => cb(value, read, actualize)),\n        )\n        return value\n      },\n      (error: any) => {\n        ctx.get((read, actualize) =>\n          chain!.catch.forEach((cb) => cb(error, read, actualize)),\n        )\n        throw error\n      },\n    )\n\n    CHAINS.set(origin, (chain = { promise, then: [], catch: [] }))\n    CHAINS.set(promise, chain)\n  }\n\n  onFulfill && chain.then.push(onFulfill)\n  onReject && chain.catch.push(onReject)\n\n  return chain.promise\n}\n\n/** @deprecated use `ctx.controller` which is AbortController instead */\nexport const disposable = (\n  ctx: Ctx,\n): Ctx & {\n  dispose: Unsubscribe\n} => {\n  const _ctx = Object.assign({}, ctx)\n  let isDisposed = false\n\n  for (const key in ctx) {\n    // @ts-expect-error\n    const value = ctx[key]\n\n    if (typeof value !== 'function') continue\n\n    Object.assign(_ctx, {\n      [key](...a: Array<any>) {\n        throwReatomError(isDisposed, 'access to disposed context branch')\n\n        if (key === 'schedule') {\n          const [effect] = a\n          a[0] = (...a: Array<any>) => {\n            try {\n              var promise = Promise.resolve(effect(...a))\n            } catch (error) {\n              promise = Promise.reject(error)\n            }\n\n            return promise.finally(() => {\n              // stack it forever\n              if (isDisposed) return new Promise(() => {})\n            })\n          }\n        }\n\n        return value.apply(this, a)\n      },\n    })\n  }\n\n  return Object.assign(_ctx, {\n    dispose() {\n      isDisposed = true\n    },\n  })\n}\n\nexport const take = <T extends Atom, Res = AtomReturn<T>>(\n  ctx: Ctx & { controller?: AbortController },\n  anAtom: T,\n  mapper: Fn<[Ctx, Awaited<AtomReturn<T>>], Res> = (ctx, v: any) => v,\n): Promise<Awaited<Res>> =>\n  new Promise<Awaited<Res>>((res: Fn, rej) => {\n    onCtxAbort(ctx, rej)\n\n    let skipFirst = true,\n      un = ctx.subscribe(anAtom, (state) => {\n        if (skipFirst) return (skipFirst = false)\n        un()\n        if (anAtom.__reatom.isAction) state = state[0].payload\n        if (state instanceof Promise) {\n          state.then((v) => res(mapper(ctx, v)), rej)\n        } else {\n          res(mapper(ctx, state))\n        }\n      })\n    ctx.schedule(un, -1)\n  })\n\nexport const takeNested = <I extends any[]>(\n  ctx: Ctx & { controller?: AbortController },\n  cb: Fn<[Ctx, ...I]>,\n  ...params: I\n): Promise<void> =>\n  new Promise<void>((resolve, reject) => {\n    onCtxAbort(ctx, reject)\n\n    let i = 1 // one for extra check\n    const { schedule } = ctx\n    const check = () => {\n      if (i === 0) resolve()\n\n      // add extra tick to make shure there is no microtask races\n      if (--i === 0) Promise.resolve().then(check)\n    }\n\n    const result = cb(\n      Object.assign({}, ctx, {\n        schedule(this: Ctx, cb: Fn, step?: -1 | 0 | 1 | 2) {\n          return schedule.call<Ctx, Parameters<Ctx['schedule']>, Promise<any>>(\n            this,\n            (ctx) => {\n              const result = cb(ctx)\n              if (result instanceof Promise) {\n                ++i\n                result.finally(check).catch(noop)\n              }\n              return result\n            },\n            step,\n          )\n        },\n      }),\n      ...params,\n    )\n\n    check()\n\n    return result\n  })\n"],"names":["getTopController","patch","controller","cause","onCtxAbort","ctx","cb","handler","toAbortError","signal","reason","aborted","addEventListener","schedule","removeEventListener","CHAINS","WeakMap","__thenReatomed","origin","onFulfill","onReject","chain","get","promise","then","value","read","actualize","forEach","error","catch","set","push","_ctx","Object","assign","isDisposed","key","a","slice","call","arguments","throwReatomError","effect","Promise","resolve","reject","finally","apply","this","dispose","anAtom","mapper","v","res","rej","skipFirst","un","subscribe","state","__reatom","isAction","payload","i","check","result","step","noop"],"mappings":"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"}