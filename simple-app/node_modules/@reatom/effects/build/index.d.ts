import { Atom, AtomCache, AtomReturn, Ctx, Fn, Unsubscribe } from '@reatom/core';
import { AbortError } from '@reatom/utils';
export declare const getTopController: (patch: AtomCache & {
    controller?: AbortController;
}) => null | AbortController;
/** Handle abort signal from a cause */
export declare const onCtxAbort: (ctx: Ctx, cb: Fn<[AbortError]>) => void;
/**
 * Subscribe to promise result with batching
 * @internal
 * @deprecated
 */
export declare const __thenReatomed: <T>(ctx: Ctx, origin: Promise<T>, onFulfill?: Fn<[value: T, read: Fn<any[], any>, actualize: Fn<any[], any>], any> | undefined, onReject?: Fn<[error: unknown, read: Fn, actualize: Fn]>) => Promise<T>;
/** @deprecated use `ctx.controller` which is AbortController instead */
export declare const disposable: (ctx: Ctx) => Ctx & {
    dispose: Unsubscribe;
};
export declare const take: <T extends Atom<any>, Res = AtomReturn<T>>(ctx: Ctx & {
    controller?: AbortController;
}, anAtom: T, mapper?: Fn<[Ctx, Awaited<AtomReturn<T>>], Res>) => Promise<Awaited<Res>>;
export declare const takeNested: <I extends any[]>(ctx: Ctx & {
    controller?: AbortController;
}, cb: Fn<[Ctx, ...I], any>, ...params: I) => Promise<void>;
//# sourceMappingURL=index.d.ts.map