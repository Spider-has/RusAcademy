var core=require("@reatom/core"),utils=require("@reatom/utils");const getTopController=patch=>patch.controller??(patch.cause&&getTopController(patch.cause)),onCtxAbort=(ctx,cb)=>{const controller=getTopController(ctx.cause);if(controller){const handler=()=>cb(utils.toAbortError(controller.signal.reason));controller.signal.aborted?handler():(controller.signal.addEventListener("abort",handler),ctx.schedule(()=>controller.signal.removeEventListener("abort",handler),-1))}},CHAINS=new WeakMap;exports.__thenReatomed=(ctx,origin,onFulfill,onReject)=>{let chain=CHAINS.get(origin);if(!chain){const promise=origin.then(value=>(ctx.get((read,actualize)=>chain.then.forEach(cb=>cb(value,read,actualize))),value),error=>{throw ctx.get((read,actualize)=>chain.catch.forEach(cb=>cb(error,read,actualize))),error});CHAINS.set(origin,chain={promise:promise,then:[],catch:[]}),CHAINS.set(promise,chain)}return onFulfill&&chain.then.push(onFulfill),onReject&&chain.catch.push(onReject),chain.promise},exports.disposable=ctx=>{const _ctx=Object.assign({},ctx);let isDisposed=!1;for(const key in ctx){const value=ctx[key];"function"==typeof value&&Object.assign(_ctx,{[key](){var a=[].slice.call(arguments);if(core.throwReatomError(isDisposed,"access to disposed context branch"),"schedule"===key){const[effect]=a;a[0]=function(){try{var promise=Promise.resolve(effect(...[].slice.call(arguments)))}catch(error){promise=Promise.reject(error)}return promise.finally(()=>{if(isDisposed)return new Promise(()=>{})})}}return value.apply(this,a)}})}return Object.assign(_ctx,{dispose(){isDisposed=!0}})},exports.getTopController=getTopController,exports.onCtxAbort=onCtxAbort,exports.take=function(ctx,anAtom,mapper){return void 0===mapper&&(mapper=(ctx,v)=>v),new Promise((res,rej)=>{onCtxAbort(ctx,rej);let skipFirst=!0,un=ctx.subscribe(anAtom,state=>{if(skipFirst)return skipFirst=!1;un(),anAtom.__reatom.isAction&&(state=state[0].payload),state instanceof Promise?state.then(v=>res(mapper(ctx,v)),rej):res(mapper(ctx,state))});ctx.schedule(un,-1)})},exports.takeNested=function(ctx,cb){return new Promise((resolve,reject)=>{onCtxAbort(ctx,reject);let i=1;const{schedule:schedule}=ctx,check=()=>{0===i&&resolve(),0==--i&&Promise.resolve().then(check)},result=cb(Object.assign({},ctx,{schedule(cb,step){return schedule.call(this,ctx=>{const result=cb(ctx);return result instanceof Promise&&(++i,result.finally(check).catch(utils.noop)),result},step)}}),...[].slice.call(arguments,2));return check(),result})};
//# sourceMappingURL=index.js.map
