{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["// TODO infer `Atom` and `AtomMut` signature\n/** Remove named generics, show plain type. */\nexport type Plain<Intersection> = Intersection extends (\n  ...a: infer I\n) => infer O\n  ? ((...a: I) => O) & {\n      [Key in keyof Intersection]: Intersection[Key]\n    }\n  : Intersection extends new (...a: any[]) => any\n  ? Intersection\n  : Intersection extends object\n  ? {\n      [Key in keyof Intersection]: Intersection[Key]\n    }\n  : Intersection\n\nexport type Values<T> = T[keyof T]\n\nexport type OmitValuesKeys<T, V> = Values<{\n  [K in keyof T]: T[K] extends V ? never : K\n}>\nexport type OmitValues<T, V> = {\n  [K in OmitValuesKeys<T, V>]: T[K]\n}\n\nexport type PickValuesKeys<T, V> = Values<{\n  [K in keyof T]: T[K] extends V ? K : never\n}>\nexport type PickValues<T, V> = {\n  [K in PickValuesKeys<T, V>]: T[K]\n}\n\nexport const noop: (...a: any[]) => any = () => {}\n\nexport const sleep = (ms = 0) => new Promise((r) => setTimeout(r, ms))\n\n/** Extract Object type or intersect the thing with `Record<string | number | symbol, unknown>` */\nexport const isObject = <T>(\n  thing: T,\n  // @ts-expect-error\n): thing is T extends Record<string | number | symbol, unknown>\n  ? T\n  : Record<string | number | symbol, unknown> =>\n  typeof thing === 'object' && thing !== null\n\n// TODO infer `b` too\n// export const is: {\n//   <A, B>(a: A, b: B): a is B\n// } = Object.is\n\n/** Shallow compare of primitives, objects and dates, arrays, maps, sets. */\nexport const isShallowEqual = (a: any, b: any, is = Object.is) => {\n  if (Object.is(a, b)) return true\n\n  if (\n    !isObject(a) ||\n    !isObject(b) ||\n    a.__proto__ !== b.__proto__ ||\n    a instanceof Error\n  ) {\n    return false\n  }\n\n  if (Symbol.iterator in a) {\n    let equal: typeof is =\n      a instanceof Map ? (a, b) => is(a[0], b[0]) && is(a[1], b[1]) : is\n    let aIter = a[Symbol.iterator]()\n    let bIter = b[Symbol.iterator]()\n    while (1) {\n      let aNext = aIter.next()\n      let bNext = bIter.next()\n      if (aNext.done || bNext.done || !equal(aNext.value, bNext.value)) {\n        return aNext.done && bNext.done\n      }\n    }\n  }\n\n  if (a instanceof Date) return a.getTime() === b.getTime()\n  if (a instanceof RegExp) return String(a) === String(b)\n\n  for (let k in a) {\n    if (k in b === false || !is(a[k], b[k])) {\n      return false\n    }\n  }\n\n  // let aSymbols = Object.getOwnPropertySymbols(a)\n  // let bSymbols = Object.getOwnPropertySymbols(b)\n\n  return (\n    // aSymbols.length === bSymbols.length &&\n    // aSymbols.every((s) => s in b && is(a[s], b[s])) &&\n    Object.keys(a).length === Object.keys(b).length\n  )\n}\n\n/** Recursive compare of primitives, objects and dates, arrays, maps, sets. Cyclic references supported */\nexport const isDeepEqual = (a: any, b: any) => {\n  const visited = new WeakMap()\n\n  const is = (a: any, b: any) => {\n    if (isObject(a)) {\n      if (visited.has(a)) return visited.get(a) === b\n      visited.set(a, b)\n    }\n    return isShallowEqual(a, b, is)\n  }\n\n  return isShallowEqual(a, b, is)\n}\n\nexport type Assign<T1, T2, T3 = {}, T4 = {}> = Plain<\n  (T1 extends (...a: infer I) => infer O ? (...a: I) => O : {}) &\n    Omit<T1, keyof T2 | keyof T3 | keyof T4> &\n    Omit<T2, keyof T3 | keyof T4> &\n    Omit<T3, keyof T4> &\n    T4\n>\n\n/** `Object.assign` with fixed types, equal properties replaced instead of changed to a union */\nexport const assign: {\n  <T1, T2, T3 = {}, T4 = {}>(a1: T1, a2: T2, a3?: T3, a4?: T4): Assign<\n    T1,\n    T2,\n    T3,\n    T4\n  >\n} = Object.assign\n\n/** `Object.assign` which set an empty object to the first argument */\nexport const merge: typeof assign = (...a) => Object.assign({}, ...a)\n\n/** Get a new object only with the passed keys*/\nexport const pick = <T, K extends keyof T>(\n  target: T,\n  keys: Array<K>,\n): Plain<Pick<T, K>> => {\n  const result: any = {}\n  for (const key of keys) result[key] = target[key]\n  return result\n}\n\n/** Get a new object without the passed keys*/\nexport const omit = <T, K extends keyof T>(\n  target: T,\n  keys: Array<K>,\n): Plain<Omit<T, K>> => {\n  const result: any = {}\n  for (const key in target) {\n    if (!keys.includes(key as any)) result[key] = target[key]\n  }\n  return result\n}\n\n/** Typesafe shortcut to `JSON.parse(JSON.stringify(value))`.\n * `structuredClone` is a better solution\n * https://developer.mozilla.org/en-US/docs/Web/API/structuredClone\n */\nexport const jsonClone = <T>(value: T): T => JSON.parse(JSON.stringify(value))\n\n/** Get random integer. Parameters should be integers too. */\nexport const random = (min = 0, max = Number.MAX_SAFE_INTEGER - 1) =>\n  Math.floor(Math.random() * (max - min + 1)) + min\n\n/**\n * Returns non nullable type of value\n */\nexport const nonNullable = <T>(value: T, message?: string): NonNullable<T> => {\n  if (value != null) return value as NonNullable<T>\n  throw new TypeError(message || 'Value is null or undefined')\n}\n\nconst { toString } = Object.prototype\nconst visited = new WeakMap<{}, string>()\n/** Stringify any kind of data with some sort of stability.\n * Support: an object keys sorting, `Map`, `Set`, circular references, custom classes, functions and symbols.\n * The optional `immutable` could memoize the result for complex objects if you think it will never change\n */\nexport const toStringKey = (thing: any, immutable = true): string => {\n  var tag = typeof thing\n  var isNominal = tag === 'function' || tag === 'symbol'\n\n  if (\n    !isNominal &&\n    (tag !== 'object' ||\n      thing === null ||\n      thing instanceof Date ||\n      thing instanceof RegExp)\n  ) {\n    return tag + thing\n  }\n\n  if (visited.has(thing)) return visited.get(thing)!\n\n  // get a unique prefix for each type to separate same array / map\n  var result = toString.call(thing)\n  var unique = result + random()\n  // thing could be a circular or not stringifiable object from a userspace\n  visited.set(thing, unique)\n\n  if (\n    isNominal ||\n    (thing.constructor !== Object && Symbol.iterator in thing === false)\n  ) {\n    return unique\n  }\n\n  for (let item of Symbol.iterator in thing\n    ? thing\n    : Object.entries(thing).sort(([a], [b]) => a.localeCompare(b)))\n    result += toStringKey(item, immutable)\n\n  immutable ? visited.set(thing, result) : visited.delete(thing)\n\n  return result\n}\n\nexport interface AbortError extends DOMException {\n  name: 'AbortError'\n}\n\nexport const toAbortError = (reason: any): AbortError => {\n  if (reason instanceof Error === false || reason.name !== 'AbortError') {\n    if (reason instanceof Error) {\n      var options: undefined | ErrorOptions = { cause: reason }\n      reason = reason.message\n    } else {\n      reason = isObject(reason) ? toString.call(reason) : String(reason)\n    }\n\n    if (typeof DOMException === 'undefined') {\n      reason = new Error(reason, options)\n      reason.name = 'AbortError'\n    } else {\n      reason = assign(new DOMException(reason, 'AbortError'), options)\n    }\n  }\n\n  return reason as AbortError\n}\n\nexport const throwIfAborted = (controller?: void | AbortController) => {\n  if (controller?.signal.aborted) {\n    throw toAbortError(controller.signal.reason)\n  }\n}\n\nexport const isAbort = (thing: any): thing is AbortError =>\n  thing instanceof Error && thing.name === 'AbortError'\n\n/** @link https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value */\nexport const MAX_SAFE_TIMEOUT = 2 ** 31 - 1\n"],"names":["isObject","thing","isShallowEqual","a","b","is","Object","__proto__","Error","Symbol","iterator","equal","Map","aIter","bIter","aNext","next","bNext","done","value","Date","getTime","RegExp","String","k","keys","length","assign","random","min","max","Number","MAX_SAFE_INTEGER","Math","floor","toString","prototype","visited","WeakMap","toStringKey","immutable","tag","isNominal","has","get","result","call","unique","set","constructor","item","entries","sort","_ref","_ref2","localeCompare","delete","toAbortError","reason","name","options","cause","message","DOMException","isDeepEqual","JSON","parse","stringify","slice","arguments","nonNullable","TypeError","noop","omit","target","key","includes","pick","ms","Promise","r","setTimeout","controller","signal","aborted"],"mappings":"AAgCa,MAKAA,SACXC,OAKiB,iBAAVA,OAAgC,OAAVA,MAQlBC,eAAiB,SAACC,EAAQC,EAAQC,IAC7C,QAD+C,IAAFA,KAAAA,GAAKC,OAAOD,IACrDC,OAAOD,GAAGF,EAAGC,GAAI,OAAO,EAE5B,IACGJ,SAASG,KACTH,SAASI,IACVD,EAAEI,YAAcH,EAAEG,WAClBJ,aAAaK,MAEb,OAAO,EAGT,GAAIC,OAAOC,YAAYP,EAAG,CACxB,IAAIQ,MACFR,aAAaS,IAAM,CAACT,EAAGC,IAAMC,GAAGF,EAAE,GAAIC,EAAE,KAAOC,GAAGF,EAAE,GAAIC,EAAE,IAAMC,GAC9DQ,MAAQV,EAAEM,OAAOC,YACjBI,MAAQV,EAAEK,OAAOC,YACrB,OAAU,CACR,IAAIK,MAAQF,MAAMG,OACdC,MAAQH,MAAME,OAClB,GAAID,MAAMG,MAAQD,MAAMC,OAASP,MAAMI,MAAMI,MAAOF,MAAME,OACxD,OAAOJ,MAAMG,MAAQD,MAAMC,IAE9B,CACF,CAED,GAAIf,aAAaiB,KAAM,OAAOjB,EAAEkB,YAAcjB,EAAEiB,UAChD,GAAIlB,aAAamB,OAAQ,OAAOC,OAAOpB,KAAOoB,OAAOnB,GAErD,IAAK,IAAIoB,KAAKrB,EACZ,GAAIqB,KAAKpB,GAAM,IAAUC,GAAGF,EAAEqB,GAAIpB,EAAEoB,IAClC,OACD,EAMH,OAGElB,OAAOmB,KAAKtB,GAAGuB,SAAWpB,OAAOmB,KAAKrB,GAAGsB,MAE7C,EA0BaC,OAOTrB,OAAOqB,OAkCEC,OAAS,SAACC,IAASC,KAAiC,YAA1CD,IAAAA,MAAAA,IAAM,QAAM,IAAHC,MAAAA,IAAMC,OAAOC,iBAAmB,GAC9DC,KAAKC,MAAMD,KAAKL,UAAYE,IAAMD,IAAM,IAAMA,GAAG,GAU7CM,SAAEA,UAAa7B,OAAO8B,UACtBC,QAAU,IAAIC,QAKPC,YAAc,SAACtC,MAAYuC,gBAAS,IAATA,YAAAA,WAAY,GAClD,IAAIC,WAAaxC,MACbyC,UAAoB,aAARD,KAA8B,WAARA,IAEtC,IACGC,YACQ,WAARD,KACW,OAAVxC,OACAA,iBAAiBmB,MACjBnB,iBAAiBqB,QAEnB,OAAOmB,IAAMxC,MAGf,GAAIoC,QAAQM,IAAI1C,OAAQ,OAAOoC,QAAQO,IAAI3C,OAG3C,IAAI4C,OAASV,SAASW,KAAK7C,OACvB8C,OAASF,OAASjB,SAItB,GAFAS,QAAQW,IAAI/C,MAAO8C,QAGjBL,WACCzC,MAAMgD,cAAgB3C,QAAUG,OAAOC,YAAYT,OAAU,EAE9D,OAAO8C,OAGT,IAAK,IAAIG,QAAQzC,OAAOC,YAAYT,MAChCA,MACAK,OAAO6C,QAAQlD,OAAOmD,KAAK,CAAAC,KAAAC,SAAC,IAACnD,GAAEkD,MAAGjD,GAAEkD,MAAA,OAAKnD,EAAEoD,cAAcnD,EAAC,GAC5DyC,QAAUN,YAAYW,KAAMV,WAI9B,OAFAA,UAAYH,QAAQW,IAAI/C,MAAO4C,QAAUR,QAAQmB,OAAOvD,OAEjD4C,MACT,EAMaY,aAAgBC,SAC3B,GAAIA,kBAAkBlD,OAAU,GAAyB,eAAhBkD,OAAOC,KAAuB,CACrE,GAAID,kBAAkBlD,MAAO,CAC3B,IAAIoD,QAAoC,CAAEC,MAAOH,QACjDA,OAASA,OAAOI,OACjB,MACCJ,OAAS1D,SAAS0D,QAAUvB,SAASW,KAAKY,QAAUnC,OAAOmC,QAGjC,oBAAjBK,cACTL,OAAS,IAAIlD,MAAMkD,OAAQE,UACpBD,KAAO,aAEdD,OAAS/B,OAAO,IAAIoC,aAAaL,OAAQ,cAAeE,QAE3D,CAED,OAAOF,iCAauB,GAAK,GAAK,wCAJlBzD,OACtBA,iBAAiBO,OAAwB,eAAfP,MAAM0D,yBAvJPK,CAAC7D,EAAQC,KAClC,MAAMiC,QAAU,IAAIC,QAEdjC,GAAKA,CAACF,EAAQC,KAClB,GAAIJ,SAASG,GAAI,CACf,GAAIkC,QAAQM,IAAIxC,GAAI,OAAOkC,QAAQO,IAAIzC,KAAOC,EAC9CiC,QAAQW,IAAI7C,EAAGC,EAChB,CACD,OAAOF,eAAeC,EAAGC,EAAGC,GAAE,EAGhC,OAAOH,eAAeC,EAAGC,EAAGC,GAAE,oFAkDHc,OAAgB8C,KAAKC,MAAMD,KAAKE,UAAUhD,sBA5BnC,WAAU,OAAAb,OAAOqB,OAAO,CAAE,KAAE,GAAAyC,MAAAtB,KAAAuB,WAAK,sBAqC1CC,CAAInD,MAAU2C,WACvC,GAAa,MAAT3C,MAAe,OAAOA,MAC1B,MAAU,IAAAoD,UAAUT,SAAW,6BAA4B,eAzInBU,oBA+GtBC,CAClBC,OACAjD,QAEA,MAAMoB,OAAc,CAAE,EACtB,IAAK,MAAM8B,OAAOD,OACXjD,KAAKmD,SAASD,OAAa9B,OAAO8B,KAAOD,OAAOC,MAEvD,OAAO9B,qBAlBWgC,CAClBH,OACAjD,QAEA,MAAMoB,OAAc,CAAE,EACtB,IAAK,MAAM8B,OAAOlD,KAAMoB,OAAO8B,KAAOD,OAAOC,KAC7C,OAAO9B,4CAzGY,SAACiC,IAAM,YAAJ,IAAFA,KAAAA,GAAK,GAAU,IAAAC,QAASC,GAAMC,WAAWD,EAAGF,IAAI,yBA+MvCI,aAC7B,GAAIA,YAAYC,OAAOC,QACrB,MAAM3B,aAAayB,WAAWC,OAAOzB,OACtC"}