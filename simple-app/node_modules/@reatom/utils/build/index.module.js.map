{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["// TODO infer `Atom` and `AtomMut` signature\n/** Remove named generics, show plain type. */\nexport type Plain<Intersection> = Intersection extends (\n  ...a: infer I\n) => infer O\n  ? ((...a: I) => O) & {\n      [Key in keyof Intersection]: Intersection[Key]\n    }\n  : Intersection extends new (...a: any[]) => any\n  ? Intersection\n  : Intersection extends object\n  ? {\n      [Key in keyof Intersection]: Intersection[Key]\n    }\n  : Intersection\n\nexport type Values<T> = T[keyof T]\n\nexport type OmitValuesKeys<T, V> = Values<{\n  [K in keyof T]: T[K] extends V ? never : K\n}>\nexport type OmitValues<T, V> = {\n  [K in OmitValuesKeys<T, V>]: T[K]\n}\n\nexport type PickValuesKeys<T, V> = Values<{\n  [K in keyof T]: T[K] extends V ? K : never\n}>\nexport type PickValues<T, V> = {\n  [K in PickValuesKeys<T, V>]: T[K]\n}\n\nexport const noop: (...a: any[]) => any = () => {}\n\nexport const sleep = (ms = 0) => new Promise((r) => setTimeout(r, ms))\n\n/** Extract Object type or intersect the thing with `Record<string | number | symbol, unknown>` */\nexport const isObject = <T>(\n  thing: T,\n  // @ts-expect-error\n): thing is T extends Record<string | number | symbol, unknown>\n  ? T\n  : Record<string | number | symbol, unknown> =>\n  typeof thing === 'object' && thing !== null\n\n// TODO infer `b` too\n// export const is: {\n//   <A, B>(a: A, b: B): a is B\n// } = Object.is\n\n/** Shallow compare of primitives, objects and dates, arrays, maps, sets. */\nexport const isShallowEqual = (a: any, b: any, is = Object.is) => {\n  if (Object.is(a, b)) return true\n\n  if (\n    !isObject(a) ||\n    !isObject(b) ||\n    a.__proto__ !== b.__proto__ ||\n    a instanceof Error\n  ) {\n    return false\n  }\n\n  if (Symbol.iterator in a) {\n    let equal: typeof is =\n      a instanceof Map ? (a, b) => is(a[0], b[0]) && is(a[1], b[1]) : is\n    let aIter = a[Symbol.iterator]()\n    let bIter = b[Symbol.iterator]()\n    while (1) {\n      let aNext = aIter.next()\n      let bNext = bIter.next()\n      if (aNext.done || bNext.done || !equal(aNext.value, bNext.value)) {\n        return aNext.done && bNext.done\n      }\n    }\n  }\n\n  if (a instanceof Date) return a.getTime() === b.getTime()\n  if (a instanceof RegExp) return String(a) === String(b)\n\n  for (let k in a) {\n    if (k in b === false || !is(a[k], b[k])) {\n      return false\n    }\n  }\n\n  // let aSymbols = Object.getOwnPropertySymbols(a)\n  // let bSymbols = Object.getOwnPropertySymbols(b)\n\n  return (\n    // aSymbols.length === bSymbols.length &&\n    // aSymbols.every((s) => s in b && is(a[s], b[s])) &&\n    Object.keys(a).length === Object.keys(b).length\n  )\n}\n\n/** Recursive compare of primitives, objects and dates, arrays, maps, sets. Cyclic references supported */\nexport const isDeepEqual = (a: any, b: any) => {\n  const visited = new WeakMap()\n\n  const is = (a: any, b: any) => {\n    if (isObject(a)) {\n      if (visited.has(a)) return visited.get(a) === b\n      visited.set(a, b)\n    }\n    return isShallowEqual(a, b, is)\n  }\n\n  return isShallowEqual(a, b, is)\n}\n\nexport type Assign<T1, T2, T3 = {}, T4 = {}> = Plain<\n  (T1 extends (...a: infer I) => infer O ? (...a: I) => O : {}) &\n    Omit<T1, keyof T2 | keyof T3 | keyof T4> &\n    Omit<T2, keyof T3 | keyof T4> &\n    Omit<T3, keyof T4> &\n    T4\n>\n\n/** `Object.assign` with fixed types, equal properties replaced instead of changed to a union */\nexport const assign: {\n  <T1, T2, T3 = {}, T4 = {}>(a1: T1, a2: T2, a3?: T3, a4?: T4): Assign<\n    T1,\n    T2,\n    T3,\n    T4\n  >\n} = Object.assign\n\n/** `Object.assign` which set an empty object to the first argument */\nexport const merge: typeof assign = (...a) => Object.assign({}, ...a)\n\n/** Get a new object only with the passed keys*/\nexport const pick = <T, K extends keyof T>(\n  target: T,\n  keys: Array<K>,\n): Plain<Pick<T, K>> => {\n  const result: any = {}\n  for (const key of keys) result[key] = target[key]\n  return result\n}\n\n/** Get a new object without the passed keys*/\nexport const omit = <T, K extends keyof T>(\n  target: T,\n  keys: Array<K>,\n): Plain<Omit<T, K>> => {\n  const result: any = {}\n  for (const key in target) {\n    if (!keys.includes(key as any)) result[key] = target[key]\n  }\n  return result\n}\n\n/** Typesafe shortcut to `JSON.parse(JSON.stringify(value))`.\n * `structuredClone` is a better solution\n * https://developer.mozilla.org/en-US/docs/Web/API/structuredClone\n */\nexport const jsonClone = <T>(value: T): T => JSON.parse(JSON.stringify(value))\n\n/** Get random integer. Parameters should be integers too. */\nexport const random = (min = 0, max = Number.MAX_SAFE_INTEGER - 1) =>\n  Math.floor(Math.random() * (max - min + 1)) + min\n\n/**\n * Returns non nullable type of value\n */\nexport const nonNullable = <T>(value: T, message?: string): NonNullable<T> => {\n  if (value != null) return value as NonNullable<T>\n  throw new TypeError(message || 'Value is null or undefined')\n}\n\nconst { toString } = Object.prototype\nconst visited = new WeakMap<{}, string>()\n/** Stringify any kind of data with some sort of stability.\n * Support: an object keys sorting, `Map`, `Set`, circular references, custom classes, functions and symbols.\n * The optional `immutable` could memoize the result for complex objects if you think it will never change\n */\nexport const toStringKey = (thing: any, immutable = true): string => {\n  var tag = typeof thing\n  var isNominal = tag === 'function' || tag === 'symbol'\n\n  if (\n    !isNominal &&\n    (tag !== 'object' ||\n      thing === null ||\n      thing instanceof Date ||\n      thing instanceof RegExp)\n  ) {\n    return tag + thing\n  }\n\n  if (visited.has(thing)) return visited.get(thing)!\n\n  // get a unique prefix for each type to separate same array / map\n  var result = toString.call(thing)\n  var unique = result + random()\n  // thing could be a circular or not stringifiable object from a userspace\n  visited.set(thing, unique)\n\n  if (\n    isNominal ||\n    (thing.constructor !== Object && Symbol.iterator in thing === false)\n  ) {\n    return unique\n  }\n\n  for (let item of Symbol.iterator in thing\n    ? thing\n    : Object.entries(thing).sort(([a], [b]) => a.localeCompare(b)))\n    result += toStringKey(item, immutable)\n\n  immutable ? visited.set(thing, result) : visited.delete(thing)\n\n  return result\n}\n\nexport interface AbortError extends DOMException {\n  name: 'AbortError'\n}\n\nexport const toAbortError = (reason: any): AbortError => {\n  if (reason instanceof Error === false || reason.name !== 'AbortError') {\n    if (reason instanceof Error) {\n      var options: undefined | ErrorOptions = { cause: reason }\n      reason = reason.message\n    } else {\n      reason = isObject(reason) ? toString.call(reason) : String(reason)\n    }\n\n    if (typeof DOMException === 'undefined') {\n      reason = new Error(reason, options)\n      reason.name = 'AbortError'\n    } else {\n      reason = assign(new DOMException(reason, 'AbortError'), options)\n    }\n  }\n\n  return reason as AbortError\n}\n\nexport const throwIfAborted = (controller?: void | AbortController) => {\n  if (controller?.signal.aborted) {\n    throw toAbortError(controller.signal.reason)\n  }\n}\n\nexport const isAbort = (thing: any): thing is AbortError =>\n  thing instanceof Error && thing.name === 'AbortError'\n\n/** @link https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value */\nexport const MAX_SAFE_TIMEOUT = 2 ** 31 - 1\n"],"names":["noop","sleep","ms","Promise","r","setTimeout","isObject","thing","isShallowEqual","a","b","is","Object","__proto__","Error","Symbol","iterator","equal","Map","aIter","bIter","aNext","next","bNext","done","value","Date","getTime","RegExp","String","k","keys","length","isDeepEqual","visited","WeakMap","has","get","set","assign","merge","slice","call","arguments","pick","target","result","key","omit","includes","jsonClone","JSON","parse","stringify","random","min","max","Number","MAX_SAFE_INTEGER","Math","floor","nonNullable","message","TypeError","toString","prototype","toStringKey","immutable","tag","isNominal","unique","constructor","item","entries","sort","_ref","_ref2","localeCompare","delete","toAbortError","reason","name","options","cause","DOMException","throwIfAborted","controller","signal","aborted","isAbort","MAX_SAFE_TIMEOUT"],"mappings":"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"}