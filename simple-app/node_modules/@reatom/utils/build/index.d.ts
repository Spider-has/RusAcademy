/** Remove named generics, show plain type. */
export type Plain<Intersection> = Intersection extends (...a: infer I) => infer O ? ((...a: I) => O) & {
    [Key in keyof Intersection]: Intersection[Key];
} : Intersection extends new (...a: any[]) => any ? Intersection : Intersection extends object ? {
    [Key in keyof Intersection]: Intersection[Key];
} : Intersection;
export type Values<T> = T[keyof T];
export type OmitValuesKeys<T, V> = Values<{
    [K in keyof T]: T[K] extends V ? never : K;
}>;
export type OmitValues<T, V> = {
    [K in OmitValuesKeys<T, V>]: T[K];
};
export type PickValuesKeys<T, V> = Values<{
    [K in keyof T]: T[K] extends V ? K : never;
}>;
export type PickValues<T, V> = {
    [K in PickValuesKeys<T, V>]: T[K];
};
export declare const noop: (...a: any[]) => any;
export declare const sleep: (ms?: number) => Promise<unknown>;
/** Extract Object type or intersect the thing with `Record<string | number | symbol, unknown>` */
export declare const isObject: <T>(thing: T) => thing is T extends Record<string | number | symbol, unknown> ? T : Record<string | number | symbol, unknown>;
/** Shallow compare of primitives, objects and dates, arrays, maps, sets. */
export declare const isShallowEqual: (a: any, b: any, is?: (value1: any, value2: any) => boolean) => any;
/** Recursive compare of primitives, objects and dates, arrays, maps, sets. Cyclic references supported */
export declare const isDeepEqual: (a: any, b: any) => any;
export type Assign<T1, T2, T3 = {}, T4 = {}> = Plain<(T1 extends (...a: infer I) => infer O ? (...a: I) => O : {}) & Omit<T1, keyof T2 | keyof T3 | keyof T4> & Omit<T2, keyof T3 | keyof T4> & Omit<T3, keyof T4> & T4>;
/** `Object.assign` with fixed types, equal properties replaced instead of changed to a union */
export declare const assign: {
    <T1, T2, T3 = {}, T4 = {}>(a1: T1, a2: T2, a3?: T3, a4?: T4): Assign<T1, T2, T3, T4>;
};
/** `Object.assign` which set an empty object to the first argument */
export declare const merge: typeof assign;
/** Get a new object only with the passed keys*/
export declare const pick: <T, K extends keyof T>(target: T, keys: K[]) => Plain<Pick<T, K>>;
/** Get a new object without the passed keys*/
export declare const omit: <T, K extends keyof T>(target: T, keys: K[]) => Plain<Omit<T, K>>;
/** Typesafe shortcut to `JSON.parse(JSON.stringify(value))`.
 * `structuredClone` is a better solution
 * https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
 */
export declare const jsonClone: <T>(value: T) => T;
/** Get random integer. Parameters should be integers too. */
export declare const random: (min?: number, max?: number) => number;
/**
 * Returns non nullable type of value
 */
export declare const nonNullable: <T>(value: T, message?: string) => NonNullable<T>;
/** Stringify any kind of data with some sort of stability.
 * Support: an object keys sorting, `Map`, `Set`, circular references, custom classes, functions and symbols.
 * The optional `immutable` could memoize the result for complex objects if you think it will never change
 */
export declare const toStringKey: (thing: any, immutable?: boolean) => string;
export interface AbortError extends DOMException {
    name: 'AbortError';
}
export declare const toAbortError: (reason: any) => AbortError;
export declare const throwIfAborted: (controller?: void | AbortController | undefined) => void;
export declare const isAbort: (thing: any) => thing is AbortError;
/** @link https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value */
export declare const MAX_SAFE_TIMEOUT: number;
//# sourceMappingURL=index.d.ts.map