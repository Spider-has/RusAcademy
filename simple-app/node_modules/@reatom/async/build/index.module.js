import{action,atom,__count,throwReatomError}from"@reatom/core";import{__thenReatomed,onCtxAbort}from"@reatom/effects";import{throwIfAborted,toAbortError,assign,isAbort,isDeepEqual,MAX_SAFE_TIMEOUT,isShallowEqual,sleep,noop}from"@reatom/utils";import{reatomMap}from"@reatom/primitives";import{onConnect}from"@reatom/hooks";const handleEffect=function(anAsync,params,_temp){let{shouldPending:shouldPending=!0,shouldFulfill:shouldFulfill=!0,shouldReject:shouldReject=!0,effect:effect=anAsync.__reatom.unstable_fn}=void 0===_temp?{}:_temp;const pendingAtom=anAsync.pendingAtom,[ctx]=params;shouldPending&&pendingAtom(ctx,s=>++s);const origin=ctx.schedule(()=>new Promise((res,rej)=>{throwIfAborted(ctx.controller),effect(...params).then(res,rej),ctx.controller.signal.addEventListener("abort",e=>rej(toAbortError(ctx.controller.signal.reason)))}));return assign(__thenReatomed(ctx,origin,v=>{shouldFulfill&&anAsync.onFulfill(ctx,v),shouldPending&&pendingAtom(ctx,s=>--s)},e=>{shouldReject&&!isAbort(e)&&anAsync.onReject(ctx,e),shouldPending&&pendingAtom(ctx,s=>--s)}),{controller:ctx.controller})},NOOP_TIMEOUT_ID=-1,withCache=function(_temp){let{ignoreAbort:ignoreAbort=!0,length:length=5,paramsLength:paramsLength,staleTime:staleTime=3e5,swr:swrOptions=!0,withPersist:withPersist,paramsToKey:paramsToKey,isEqual:isEqual=((ctx,a,b)=>isDeepEqual(a,b))}=void 0===_temp?{}:_temp;return anAsync=>{if(!anAsync.cacheAtom){const swr=!!swrOptions,{shouldFulfill:shouldFulfill=swr,shouldReject:shouldReject=swr}=swrOptions;Infinity!==staleTime&&(staleTime=Math.min(MAX_SAFE_TIMEOUT,staleTime));const find=paramsToKey?function(ctx,params,state){void 0===state&&(state=ctx.get(cacheAtom));const key=paramsToKey(ctx,params);return{cached:state.get(key),key:key}}:function(ctx,params,state){void 0===state&&(state=ctx.get(cacheAtom));for(const[key,cached]of state)if(isEqual(ctx,key,params))return{cached:cached,key:key};return{cached:void 0,key:params}},findLatestWithValue=function(ctx,state){void 0===state&&(state=ctx.get(cacheAtom));for(const cached of state.values())if(cached.version>0&&(!latestCached||cached.lastUpdate>latestCached.lastUpdate))var latestCached=cached;return latestCached},deleteOldest=cache=>{for(const[key,cached]of cache)if(!oldestCached||oldestCached.lastUpdate>cached.lastUpdate)var oldestKey=key,oldestCached=cached;oldestCached&&cache.delete(oldestKey)},planCleanup=function(ctx,key,time){void 0===time&&(time=staleTime);const clearTimeoutId=Infinity===staleTime?NOOP_TIMEOUT_ID:setTimeout(()=>{cacheAtom.get(ctx,key)?.clearTimeoutId===clearTimeoutId&&cacheAtom.delete(ctx,key)},time);return clearTimeoutId.unref?.(),ctx.schedule(()=>clearTimeout(clearTimeoutId),-1),clearTimeoutId},cacheAtom=anAsync.cacheAtom=reatomMap(new Map,`${anAsync.__reatom.name}._cacheAtom`);cacheAtom.invalidate=action(ctx=>{const latest=findLatestWithValue(ctx);return cacheAtom.clear(ctx),latest?anAsync(ctx,...latest.params):null},`${cacheAtom.__reatom.name}.invalidate`),withPersist&&cacheAtom.pipe(withPersist({key:cacheAtom.__reatom.name,fromSnapshot:function(ctx,snapshot,state){if(void 0===state&&(state=new Map),snapshot.length<=state?.size&&snapshot.every(_ref=>{let[,{params:params,value:value}]=_ref;const{cached:cached}=find(ctx,params,state);return!!cached&&isDeepEqual(cached.value,value)}))return state;const newState=new Map(snapshot);for(const[key,rec]of newState)staleTime-(Date.now()-rec.lastUpdate)<=0?newState.delete(key):rec.clearTimeoutId=planCleanup(ctx,key,staleTime-(Date.now()-rec.lastUpdate));for(const[key,rec]of state)if(rec.promise){const{cached:cached}=find(ctx,rec.params,newState);cached?cached.promise=rec.promise:newState.set(key,rec)}return newState},time:Math.min(staleTime,MAX_SAFE_TIMEOUT),toSnapshot:(ctx,cache)=>[...cache].filter(_ref2=>{let[,rec]=_ref2;return!rec.promise})}));const handlePromise=(ctx,key,cached)=>{cached.clearTimeoutId=planCleanup(ctx,key);const isSame=()=>cacheAtom.get(ctx,key)?.clearTimeoutId===cached.clearTimeoutId,{unstable_fn:unstable_fn}=anAsync.__reatom;let res,rej;return cached.promise=new Promise(function(){return[res,rej]=[].slice.call(arguments)}),function(){try{function _temp3(){return cached.promise}var a=[].slice.call(arguments);ignoreAbort&&(a[0]=unstable_dropController(a[0]));const _temp2=function(body,recover){try{var result=Promise.resolve(unstable_fn(...a)).then(function(value){res(value),isSame()&&cacheAtom.set(ctx,key,{...cached,promise:void 0,value:value,version:cached.version+1})})}catch(e){return recover(e)}return result&&result.then?result.then(void 0,recover):result}(0,function(error){rej(error),isSame()&&(cached.version>0?cacheAtom.set(ctx,key,{...cached,promise:void 0}):cacheAtom.delete(ctx,key))});return Promise.resolve(_temp2&&_temp2.then?_temp2.then(_temp3):_temp3())}catch(e){return Promise.reject(e)}}};if(anAsync._handleCache=action(function(){var params=[].slice.call(arguments);const[ctx]=params,{controller:controller}=ctx.cause.cause;ctx.controller=ctx.cause.controller=controller;const paramsKey=params.slice(1,1+(paramsLength??params.length));let{cached:cached={clearTimeoutId:NOOP_TIMEOUT_ID,promise:void 0,value:void 0,version:0,lastUpdate:-1,params:[]},key:key}=find(ctx,paramsKey);cached={...cached,lastUpdate:Date.now(),params:paramsKey};const cache=cacheAtom.set(ctx,key,cached);return cache.size>length&&deleteOldest(cache),0!==cached.version||cached.promise?(cached.version>0&&anAsync.onFulfill(ctx,cached.value),handleEffect(anAsync,params,cached.promise||!swr?{effect:function(){try{return Promise.resolve(cached.promise??cached.value)}catch(e){return Promise.reject(e)}},shouldPending:!1,shouldFulfill:shouldFulfill,shouldReject:shouldReject}:{effect:handlePromise(ctx,key,cached),shouldPending:!1,shouldFulfill:shouldFulfill,shouldReject:shouldReject})):handleEffect(anAsync,params,{effect:handlePromise(ctx,key,cached)})},`${anAsync.__reatom.name}._handleCache`),"dataAtom"in anAsync){const{initState:initState}=anAsync.dataAtom.__reatom;anAsync.dataAtom.__reatom.initState=ctx=>{const cached=findLatestWithValue(ctx);return cached?cached.value:initState(ctx)}}"dataAtom"in anAsync&&onConnect(anAsync.dataAtom,ctx=>ctx.subscribe(cacheAtom,()=>{}))}return anAsync}},memo=reducer=>state=>{const newState=reducer(state);return isShallowEqual(state,newState)?state:newState},withStatusesAtom=()=>anAsync=>{if(!anAsync.statusesAtom){const statusesAtom=anAsync.statusesAtom=atom({isPending:!1,isFulfilled:!1,isRejected:!1,isSettled:!1,isFirstPending:!1,isEverPending:!1,isEverSettled:!1},`${anAsync.__reatom.name}.statusesAtom`);anAsync.onCall((ctx,payload)=>{statusesAtom(ctx,memo(statuses=>({isPending:ctx.get(anAsync.pendingAtom)>0,isFulfilled:!1,isRejected:!1,isSettled:!1,isFirstPending:!statuses.isEverSettled,isEverPending:!0,isEverSettled:statuses.isEverSettled}))),__thenReatomed(ctx,payload,()=>statusesAtom(ctx,memo(()=>{const isPending=ctx.get(anAsync.pendingAtom)>0;return{isPending:isPending,isFulfilled:!isPending,isRejected:!1,isSettled:!isPending,isFirstPending:!1,isEverPending:!0,isEverSettled:!0}})),()=>statusesAtom(ctx,memo(()=>{const isPending=ctx.get(anAsync.pendingAtom)>0;return{isPending:isPending,isFulfilled:!1,isRejected:!isPending,isSettled:!isPending,isFirstPending:!1,isEverPending:!0,isEverSettled:!0}})))})}return anAsync},isAbortError=isAbort,getCache=(ctx,anAtom)=>(ctx.get(anAtom),anAtom.__reatom.patch??ctx.get(read=>read(anAtom.__reatom))),unstable_dropController=ctx=>{const controller=new AbortController;return{...ctx,cause:{...ctx.cause,controller:controller},controller:controller}},reatomAsync=function(effect,options){void 0===options&&(options={});const{name:name=__count("async"),onEffect:onEffectHook,onFulfill:onFulfillHook,onReject:onRejectHook,onSettle:onSettleHook}="string"==typeof options?{name:options}:options,pendingAtom=atom(0,`${name}.pendingAtom`),onEffect=Object.assign(function(){var params=[].slice.call(arguments);return params[0].get((read,actualize)=>{const{state:state}=actualize(params[0],onEffect.__reatom,(ctx,patch)=>{ctx.controller=ctx.cause.controller=new AbortController,onCtxAbort(params[0],error=>ctx.controller.abort(error)),params[0]=ctx,patch.state=[...patch.state,{params:params.slice(1),payload:onEffect._handleCache?onEffect._handleCache(...params):handleEffect(onEffect,params)}]});return state[state.length-1].payload})},action(effect,name)),onFulfill=action(`${name}.onFulfill`),onReject=action(`${name}.onReject`),onSettle=action(`${name}._onSettle`);return onFulfill.onCall(ctx=>onSettle(ctx)),onReject.onCall(ctx=>onSettle(ctx)),onEffectHook&&onEffect.onCall((ctx,promise,params)=>onEffectHook(ctx,params,promise)),onFulfillHook&&onFulfill.onCall(onFulfillHook),onRejectHook&&onReject.onCall(onRejectHook),onSettleHook&&onSettle.onCall(onSettleHook),assign(onEffect,{onFulfill:onFulfill,onReject:onReject,onSettle:onSettle,pendingAtom:pendingAtom})};reatomAsync.from=function(effect,options){return void 0===options&&(options={}),effect.name.length>2&&("object"==typeof options?options.name??=effect.name:options??=effect.name),reatomAsync(function(ctx){return effect(...[].slice.call(arguments,1))},options)};const withDataAtom=(initState,map)=>anAsync=>{if(!anAsync.dataAtom){const dataAtom=anAsync.dataAtom=Object.assign(atom(initState,`${anAsync.__reatom.name}.dataAtom`),{reset:action(ctx=>{dataAtom(ctx,initState)},`${anAsync.__reatom.name}.dataAtom.reset`)});anAsync.onFulfill.onCall((ctx,payload)=>dataAtom(ctx,state=>map?map(ctx,payload,state):payload))}return anAsync},withErrorAtom=function(parseError,_temp){void 0===parseError&&(parseError=(ctx,e)=>e instanceof Error?e:new Error(String(e)));let{resetTrigger:resetTrigger}=void 0===_temp?{resetTrigger:"onEffect"}:_temp;return anAsync=>{if(!anAsync.errorAtom){const errorAtomName=`${anAsync.__reatom.name}.errorAtom`,errorAtom=anAsync.errorAtom=assign(atom(void 0,errorAtomName),{reset:action(ctx=>{errorAtom(ctx,void 0)},`${errorAtomName}.reset`)});anAsync.onReject.onCall((ctx,payload)=>errorAtom(ctx,parseError(ctx,payload))),resetTrigger&&{...anAsync,onEffect:anAsync}[resetTrigger].onChange(ctx=>{void 0!==ctx.get(errorAtom)&&errorAtom.reset(ctx)})}return anAsync}},withAbort=function(_temp2){let{strategy:strategy="last-in-win"}=void 0===_temp2?{}:_temp2;return anAsync=>{if(!anAsync.abort){const abortControllerAtom=anAsync.abortControllerAtom=atom(function(ctx,state){return void 0===state&&(state=new AbortController),ctx.spy(anAsync,_ref=>{let{payload:promise}=_ref;if("last-in-win"===strategy&&state){const controller=state;ctx.schedule(()=>{controller.abort(toAbortError("concurrent request (last-in-win)"))})}if("first-in-win"===strategy&&state&&!state.settled)return void promise.controller.abort(toAbortError("concurrent request (first-in-win)"));const handleAbort=()=>{state.settled=!0,anAsync.onAbort(ctx,toAbortError(state.signal.reason))};(state=promise.controller).signal.addEventListener("abort",handleAbort);const removeAbortHandler=()=>state.signal.removeEventListener("abort",handleAbort);__thenReatomed(ctx,promise,removeAbortHandler,removeAbortHandler)}),state},`${anAsync.__reatom.name}._abortControllerAtom`);anAsync.onCall(ctx=>{ctx.get(abortControllerAtom)}),anAsync.abort=action((ctx,reason)=>{const controller=ctx.get(abortControllerAtom);if(controller){const error=toAbortError(reason);ctx.schedule(()=>controller.abort(error))}},`${anAsync.__reatom.name}.abort`),anAsync.onAbort=action(`${anAsync.__reatom.name}.onAbort`)}return anAsync}},withRetry=function(_temp3){let{fallbackParams:fallbackParams,onReject:onReject}=void 0===_temp3?{}:_temp3;return anAsync=>{if(!anAsync.paramsAtom){const paramsAtom=anAsync.paramsAtom=atom(fallbackParams,`${anAsync.__reatom.name}._paramsAtom`);anAsync.onCall((ctx,payload,params)=>paramsAtom(ctx,params)),anAsync.retry=action(function(ctx,after){void 0===after&&(after=0),throwReatomError(after<0,"wrong timeout");const params=ctx.get(anAsync.paramsAtom);throwReatomError(!params,"no cached params");const asyncSnapshot=getCache(ctx,anAsync);return retriesAtom(ctx,s=>s+1),ctx.schedule(function(){try{function _temp5(){if(asyncSnapshot!==getCache(ctx,anAsync))throw toAbortError("outdated retry");return Promise.resolve(anAsync(ctx,...params))}const _temp4=function(){if(after>0)return Promise.resolve(sleep(after)).then(function(){})}();return Promise.resolve(_temp4&&_temp4.then?_temp4.then(_temp5):_temp5())}catch(e){return Promise.reject(e)}})},`${anAsync.__reatom.name}.retry`);const retriesAtom=anAsync.retriesAtom=atom(0,`${anAsync.__reatom.name}.retriesAtom`);onReject&&anAsync.onCall((ctx,payload)=>{__thenReatomed(ctx,payload,()=>retriesAtom(ctx,0),error=>{if(isAbort(error))return;const timeout=onReject(ctx,error,ctx.get(retriesAtom))??-1;timeout<0||anAsync.retry(unstable_dropController(ctx),timeout).catch(noop)})})}return anAsync}},withRetryAction=withRetry;function mapToAsync(effect,options){return void 0===options&&(options={}),sourceAtom=>{const asyncAction=reatomAsync(effect,{...options,name:options.name??`${sourceAtom.__reatom.name}.mapToAsync`});return asyncAction.unstable_unhook=sourceAtom.onChange(asyncAction),asyncAction}}export{isAbortError,mapToAsync,reatomAsync,unstable_dropController,withAbort,withCache,withDataAtom,withErrorAtom,withRetry,withRetryAction,withStatusesAtom};
//# sourceMappingURL=index.module.js.map
