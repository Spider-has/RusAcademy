{"version":3,"file":"index.module.js","sources":["../src/handleEffect.ts","../src/withCache.ts","../src/withStatusesAtom.ts","../src/index.ts"],"sourcesContent":["import { AtomMut, Fn } from '@reatom/core'\nimport { AsyncAction, AsyncCtx, ControlledPromise } from '.'\nimport { assign, isAbort, throwIfAborted, toAbortError } from '@reatom/utils'\nimport { __thenReatomed } from '@reatom/effects'\n\nexport const handleEffect = (\n  anAsync: AsyncAction,\n  params: readonly [AsyncCtx, ...any[]],\n  {\n    shouldPending = true,\n    shouldFulfill = true,\n    shouldReject = true,\n    // @ts-expect-error could be reassigned by the testing package\n    effect = anAsync.__reatom.unstable_fn as Fn,\n  } = {},\n): ControlledPromise => {\n  const pendingAtom = anAsync.pendingAtom as AtomMut<number>\n  const [ctx] = params\n\n  if (shouldPending) pendingAtom(ctx, (s) => ++s)\n\n  const origin = ctx.schedule(\n    () =>\n      new Promise((res, rej) => {\n        throwIfAborted(ctx.controller)\n        effect(...params).then(res, rej)\n        ctx.controller.signal.addEventListener('abort', (e) =>\n          rej(toAbortError(ctx.controller.signal.reason)),\n        )\n      }),\n  )\n\n  return assign(\n    __thenReatomed(\n      ctx,\n      origin,\n      (v) => {\n        if (shouldFulfill) anAsync.onFulfill(ctx, v)\n        if (shouldPending) pendingAtom(ctx, (s) => --s)\n      },\n      (e) => {\n        if (shouldReject && !isAbort(e)) anAsync.onReject(ctx, e)\n        if (shouldPending) pendingAtom(ctx, (s) => --s)\n      },\n    ),\n    { controller: ctx.controller },\n  )\n}\n","import {\n  Action,\n  action,\n  ActionParams,\n  AtomMut,\n  AtomState,\n  Ctx,\n  Fn,\n} from '@reatom/core'\nimport { MapAtom, reatomMap } from '@reatom/primitives'\nimport { isDeepEqual, MAX_SAFE_TIMEOUT } from '@reatom/utils'\nimport { type WithPersistOptions } from '@reatom/persist'\n\nimport {\n  AsyncAction,\n  AsyncCause,\n  AsyncCtx,\n  AsyncResp,\n  ControlledPromise,\n  unstable_dropController,\n} from '.'\nimport { handleEffect } from './handleEffect'\nimport { onConnect } from '@reatom/hooks'\n\nexport interface CacheRecord<T = any, Params extends any[] = unknown[]> {\n  clearTimeoutId: ReturnType<typeof setTimeout>\n  /** It is more like **\"lastRequest\"**,\n   * which is expected for failed fetching,\n   * we don't want to remove the cache,\n   * if we couldn't fetch new one. */\n  lastUpdate: number\n  params: Params\n  promise: undefined | Promise<T>\n  value: undefined | T\n  /** value version */\n  version: number\n}\n\nexport interface CacheAtom<T = any, Params extends any[] = unknown[]>\n  extends MapAtom<unknown, CacheRecord<T, Params>> {\n  /** Clear all records and call the effect with the last params. */\n  invalidate: Action<[], null | ControlledPromise<T>>\n  // setWithParams: Action<[params: Params, value: T]>\n  // deleteWithParams: Action<[params: Params]>\n}\n\ntype CacheMapRecord<T extends AsyncAction = AsyncAction> =\n  | undefined\n  | CacheRecord<AsyncResp<T>, ActionParams<T>>\n\nexport type WithCacheOptions<T extends AsyncAction = AsyncAction> = {\n  /** Define if the effect should be prevented from abort.\n   * The outer abort strategy is not affected, which means that all hooks and returned promise will behave the same.\n   * But the effect execution could be continued even if abort appears, to save the result in the cache.\n   * @default true\n   */\n  ignoreAbort?: boolean\n\n  // TODO how to handle if `withDataAtom` defined after `withCache`?\n  // /** Define if the last cache should be used as init state of `dataAtom`.\n  //  * Useful when `withPersist` defined.\n  //  * @default true\n  //  */\n  // initData?: boolean\n\n  /** Maximum amount of cache records.\n   * @default 5\n   */\n  length?: number\n\n  /** The number of excepted parameters, which will used as a cache key.\n   * @default undefined (all)\n   */\n  paramsLength?: number\n\n  /** The amount of milliseconds after which a cache record cleanups.\n   * @default 5 * 60 * 1000 ms (5 minutes)\n   */\n  staleTime?: number\n\n  /** (stale while revalidate) Define if fetching should be triggered even if the cache is exists.\n   * A boolean value applies to all options\n   * @default true\n   */\n  swr?:\n    | boolean\n    | {\n        /** success revalidation should trigger `onFulfill` to notify about the fresh data\n         * @default true\n         */\n        shouldFulfill?: boolean\n        /** error revalidation trigger `onReject` to notify about the error\n         * @default true\n         */\n        shouldReject?: boolean\n      }\n\n  /** Persist adapter, which will used with predefined optimal parameters */\n  withPersist?: (\n    options: WithPersistOptions<\n      AtomState<CacheAtom<AsyncResp<T>, ActionParams<T>>>\n    >,\n  ) => (\n    anAsync: CacheAtom<AsyncResp<T>, ActionParams<T>>,\n  ) => CacheAtom<AsyncResp<T>, ActionParams<T>>\n} & (\n  | {\n      /** Convert params to stable string and use as a map key.\n       * Alternative to `isEqual`.\n       * Disabled by default.\n       */\n      paramsToKey?: (ctx: Ctx, params: ActionParams<T>) => string\n    }\n  | {\n      /** Check the equality of a cache record and passed params to find the cache.\n       * Alternative to `paramsToKey`.\n       * @default `isDeepEqual` from @reatom/utils\n       */\n      isEqual?: (\n        ctx: Ctx,\n        prev: ActionParams<T>,\n        next: ActionParams<T>,\n      ) => boolean\n    }\n)\n\ntype Find<T extends AsyncAction> = Fn<\n  [\n    ctx: Ctx,\n    params: ActionParams<T>,\n    state?: AtomState<CacheAtom<AsyncResp<T>, ActionParams<T>>>,\n  ],\n  { cached?: CacheMapRecord<T>; key: unknown }\n>\n\nconst NOOP_TIMEOUT_ID = -1 as unknown as ReturnType<typeof setTimeout>\n\nexport const withCache =\n  <\n    T extends AsyncAction & {\n      dataAtom?: AtomMut\n      cacheAtom?: CacheAtom<AsyncResp<T>, ActionParams<T>>\n    },\n  >({\n    ignoreAbort = true,\n    // initData = true,\n    length = 5,\n    paramsLength,\n    staleTime = 5 * 60 * 1000,\n    swr: swrOptions = true,\n    withPersist,\n    // @ts-expect-error\n    paramsToKey,\n    // @ts-expect-error\n    isEqual = (ctx: Ctx, a: any, b: any) => isDeepEqual(a, b),\n  }: WithCacheOptions<T> = {}): Fn<\n    [T],\n    T & {\n      cacheAtom: CacheAtom<AsyncResp<T>, ActionParams<T>>\n    }\n  > =>\n  // @ts-ignore\n  (anAsync) => {\n    if (!anAsync.cacheAtom) {\n      type ThisParams = ActionParams<T>\n      type ThisCacheAtom = CacheAtom<AsyncResp<T>, ThisParams>\n      type ThisCacheRecord = CacheRecord<AsyncResp<T>, ThisParams>\n\n      const swr = !!swrOptions\n      // @ts-expect-error valid and correct JS\n      const { shouldFulfill = swr, shouldReject = swr } = swrOptions\n      if (staleTime !== Infinity)\n        staleTime = Math.min(MAX_SAFE_TIMEOUT, staleTime)\n\n      const find: Find<T> = paramsToKey\n        ? (ctx, params, state = ctx.get(cacheAtom)) => {\n            const key = paramsToKey(ctx, params)\n            return { cached: state.get(key), key }\n          }\n        : (ctx, params, state = ctx.get(cacheAtom)) => {\n            for (const [key, cached] of state) {\n              if (isEqual(ctx, key, params)) return { cached, key }\n            }\n            return { cached: undefined, key: params }\n          }\n\n      const findLatestWithValue = (ctx: Ctx, state = ctx.get(cacheAtom)) => {\n        for (const cached of state.values()) {\n          if (\n            cached.version > 0 &&\n            (!latestCached || cached.lastUpdate > latestCached.lastUpdate)\n          ) {\n            var latestCached: undefined | ThisCacheRecord = cached\n          }\n        }\n        return latestCached\n      }\n\n      const deleteOldest = (cache: Map<unknown, ThisCacheRecord>) => {\n        for (const [key, cached] of cache) {\n          if (!oldestCached || oldestCached.lastUpdate > cached.lastUpdate) {\n            var oldestKey = key\n            var oldestCached: undefined | ThisCacheRecord = cached\n          }\n        }\n        // it is ok to mutate the cache,\n        // as it was just created from the set method\n        // and wasn't touched by anything.\n        if (oldestCached) cache.delete(oldestKey)\n      }\n\n      const planCleanup = (ctx: Ctx, key: unknown, time = staleTime) => {\n        const clearTimeoutId =\n          staleTime === Infinity\n            ? NOOP_TIMEOUT_ID\n            : setTimeout(() => {\n                if (\n                  cacheAtom.get(ctx, key)?.clearTimeoutId === clearTimeoutId\n                ) {\n                  cacheAtom.delete(ctx, key)\n                }\n              }, time)\n\n        clearTimeoutId.unref?.()\n        ctx.schedule(() => clearTimeout(clearTimeoutId), -1)\n\n        return clearTimeoutId\n      }\n\n      const cacheAtom = (anAsync.cacheAtom = reatomMap(\n        new Map(),\n        `${anAsync.__reatom.name}._cacheAtom`,\n      ) as ThisCacheAtom)\n\n      cacheAtom.invalidate = action((ctx) => {\n        const latest = findLatestWithValue(ctx)\n\n        cacheAtom.clear(ctx)\n\n        return latest ? anAsync(ctx, ...latest.params) : null\n      }, `${cacheAtom.__reatom.name}.invalidate`)\n\n      if (withPersist) {\n        // TODO the key could be provided by a decorator function\n        // like `withPersist: options => withLocalStorage({ ...options, key: 'key' })`\n        // how to check it??\n        // throwReatomError(\n        //   anAsync.__reatom.name!.includes('#'),\n        //   'the async name is not unique',\n        // )\n\n        cacheAtom.pipe(\n          withPersist({\n            key: cacheAtom.__reatom.name!,\n            // @ts-expect-error snapshot unknown type\n            fromSnapshot: (\n              ctx,\n              snapshot: Array<[unknown, ThisCacheRecord]>,\n              state = new Map(),\n            ) => {\n              if (\n                snapshot.length <= state?.size &&\n                snapshot.every(([, { params, value }]) => {\n                  const { cached } = find(ctx, params, state)\n                  return !!cached && isDeepEqual(cached.value, value)\n                })\n              ) {\n                return state\n              }\n\n              const newState = new Map(snapshot)\n\n              for (const [key, rec] of newState) {\n                const restStaleTime = staleTime - (Date.now() - rec.lastUpdate)\n                if (restStaleTime <= 0) {\n                  newState.delete(key)\n                } else {\n                  rec.clearTimeoutId = planCleanup(\n                    ctx,\n                    key,\n                    staleTime - (Date.now() - rec.lastUpdate),\n                  )\n                }\n              }\n\n              for (const [key, rec] of state) {\n                if (rec.promise) {\n                  const { cached } = find(ctx, rec.params, newState)\n                  if (cached) {\n                    cached.promise = rec.promise\n                  } else {\n                    newState.set(key, rec)\n                  }\n                }\n              }\n\n              return newState\n            },\n            time: Math.min(staleTime, MAX_SAFE_TIMEOUT),\n            toSnapshot: (ctx, cache) =>\n              [...cache].filter(([, rec]) => !rec.promise),\n          }),\n        )\n      }\n\n      const handlePromise = (\n        ctx: Ctx,\n        key: unknown,\n        cached: ThisCacheRecord,\n      ) => {\n        cached.clearTimeoutId = planCleanup(ctx, key)\n        // the case: the whole cache was cleared and a new fetching was started\n        const isSame = () =>\n          cacheAtom.get(ctx, key)?.clearTimeoutId === cached.clearTimeoutId\n\n        // @ts-expect-error could be reassigned by the testing package\n        const { unstable_fn } = anAsync.__reatom\n        let res: Fn, rej: Fn\n        cached.promise = new Promise<AsyncResp<T>>((...a) => ([res, rej] = a))\n\n        return async (...a: Parameters<T>) => {\n          if (ignoreAbort) {\n            a[0] = unstable_dropController(a[0])\n          }\n\n          try {\n            const value = await unstable_fn(...a)\n            res(value)\n\n            if (isSame()) {\n              cacheAtom.set(ctx, key, {\n                ...cached,\n                promise: undefined,\n                value,\n                version: cached.version + 1,\n              })\n            }\n          } catch (error) {\n            rej(error)\n\n            if (isSame()) {\n              if (cached.version > 0) {\n                cacheAtom.set(ctx, key, {\n                  ...cached,\n                  promise: undefined,\n                })\n              } else {\n                cacheAtom.delete(ctx, key)\n              }\n            }\n          }\n          return cached.promise\n        }\n      }\n\n      // @ts-ignore\n      anAsync._handleCache = action(\n        // @ts-expect-error can't type the context\n        (...params: [AsyncCtx, ...ThisParams]): ControlledPromise => {\n          const [ctx] = params\n          const { controller } = ctx.cause.cause as AsyncCause\n          ctx.controller = ctx.cause.controller = controller\n\n          const paramsKey = params.slice(\n            1,\n            1 + (paramsLength ?? params.length),\n          ) as ThisParams\n\n          let {\n            cached = {\n              clearTimeoutId: NOOP_TIMEOUT_ID,\n              promise: undefined,\n              value: undefined,\n              version: 0,\n              lastUpdate: -1,\n              params: [],\n            },\n            key,\n          } = find(ctx, paramsKey)\n\n          cached = {\n            ...cached,\n            lastUpdate: Date.now(),\n            params: paramsKey,\n          }\n\n          const cache = cacheAtom.set(ctx, key, cached)\n          if (cache.size > length) deleteOldest(cache)\n\n          if (cached.version === 0 && !cached.promise) {\n            return handleEffect(anAsync, params, {\n              effect: handlePromise(ctx, key, cached),\n            })\n          }\n\n          // have a value\n          if (cached.version > 0) anAsync.onFulfill(ctx, cached.value)\n\n          if (cached.promise || !swr) {\n            return handleEffect(anAsync, params, {\n              effect: async () => cached.promise ?? cached.value,\n              shouldPending: false,\n              shouldFulfill,\n              shouldReject,\n            })\n          }\n\n          return handleEffect(anAsync, params, {\n            effect: handlePromise(ctx, key, cached),\n            shouldPending: false,\n            shouldFulfill,\n            shouldReject,\n          })\n        },\n        `${anAsync.__reatom.name}._handleCache`,\n      )\n\n      // TODO make it an option\n      if ('dataAtom' in anAsync) {\n        const { initState } = anAsync.dataAtom!.__reatom\n        anAsync.dataAtom!.__reatom.initState = (ctx) => {\n          const cached = findLatestWithValue(ctx)\n          return cached ? cached.value : initState(ctx)\n        }\n      }\n\n      // TODO handle it in dataAtom too to not couple to the order of operations\n      if ('dataAtom' in anAsync) {\n        onConnect(anAsync.dataAtom!, (ctx) =>\n          ctx.subscribe(cacheAtom, () => {}),\n        )\n      }\n    }\n\n    return anAsync\n  }\n","import { atom, Atom } from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\n\nimport { AsyncAction } from '.'\nimport { isShallowEqual } from '@reatom/utils'\n\nexport interface AsyncStatusesNeverPending {\n  isPending: false\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: false\n  // isNeverPending: true\n  isEverSettled: false\n  // isNeverSettled: true\n}\n\nexport interface AsyncStatusesFirstPending {\n  isPending: true\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: true\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: false\n  // isNeverSettled: true\n}\n\nexport interface AsyncStatusesFulfilled {\n  isPending: false\n  isFulfilled: true\n  isRejected: false\n  isSettled: true\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport interface AsyncStatusesRejected {\n  isPending: false\n  isFulfilled: false\n  isRejected: true\n  isSettled: true\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport interface AsyncStatusesAnotherPending {\n  isPending: true\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: false\n  // isAnotherPending: true\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport type AsyncStatusesPending =\n  | AsyncStatusesFirstPending\n  | AsyncStatusesAnotherPending\n\nexport type AsyncStatuses =\n  | AsyncStatusesNeverPending\n  | AsyncStatusesPending\n  | AsyncStatusesFulfilled\n  | AsyncStatusesRejected\n\nexport interface AsyncStatusesAtom extends Atom<AsyncStatuses> {\n  // TODO how to reset during pending?\n  // reset: Action<[], AsyncStatuses>\n}\n\nconst memo =\n  (reducer: (state: AsyncStatuses) => AsyncStatuses) =>\n  (state: AsyncStatuses): AsyncStatuses => {\n    const newState = reducer(state)\n    return isShallowEqual(state, newState) ? state : newState\n  }\n\nexport const withStatusesAtom =\n  <\n    T extends AsyncAction & {\n      statusesAtom?: AsyncStatusesAtom\n    },\n  >() =>\n  (anAsync: T): T & { statusesAtom: AsyncStatusesAtom } => {\n    if (!anAsync.statusesAtom) {\n      const statusesAtom = (anAsync.statusesAtom = atom<AsyncStatuses>(\n        {\n          isPending: false,\n          isFulfilled: false,\n          isRejected: false,\n          isSettled: false,\n\n          isFirstPending: false,\n          // isAnotherPending: false,\n          isEverPending: false,\n          // isNeverPending: true,\n          isEverSettled: false,\n          // isNeverSettled: true,\n        },\n        `${anAsync.__reatom.name}.statusesAtom`,\n      ))\n      anAsync.onCall((ctx, payload) => {\n        statusesAtom(\n          ctx,\n          memo((statuses) => {\n            return {\n              isPending: ctx.get(anAsync.pendingAtom) > 0,\n              isFulfilled: false,\n              isRejected: false,\n              isSettled: false,\n\n              isFirstPending: !statuses.isEverSettled,\n              // isAnotherPending: statuses.isEverPending,\n              isEverPending: true,\n              // isNeverPending: false,\n              isEverSettled: statuses.isEverSettled,\n              // isNeverSettled: statuses.isNeverSettled,\n            } as AsyncStatuses\n          }),\n        )\n\n        __thenReatomed(\n          ctx,\n          payload,\n          () =>\n            statusesAtom(\n              ctx,\n              memo(() => {\n                const isPending = ctx.get(anAsync.pendingAtom) > 0\n                return {\n                  isPending,\n                  isFulfilled: !isPending,\n                  isRejected: false,\n                  isSettled: !isPending,\n\n                  isFirstPending: false,\n                  // isAnotherPending: false,\n                  isEverPending: true,\n                  // isNeverPending: false,\n                  isEverSettled: true,\n                  // isNeverSettled: false,\n                } as AsyncStatuses\n              }),\n            ),\n          () =>\n            statusesAtom(\n              ctx,\n              memo(() => {\n                const isPending = ctx.get(anAsync.pendingAtom) > 0\n                return {\n                  isPending,\n                  isFulfilled: false,\n                  isRejected: !isPending,\n                  isSettled: !isPending,\n\n                  isFirstPending: false,\n                  // isAnotherPending: false,\n                  isEverPending: true,\n                  // isNeverPending: false,\n                  isEverSettled: true,\n                  // isNeverSettled: false,\n                } as AsyncStatuses\n              }),\n            ),\n        )\n      })\n    }\n\n    return anAsync as T & { statusesAtom: Atom<AsyncStatuses> }\n  }\n","// TODO https://hyperfetch.bettertyped.com/docs/Getting%20Started/Comparison/\n// TODO https://github.com/natemoo-re/ultrafetch\n\nimport {\n  action,\n  Action,\n  ActionParams,\n  ActionPayload,\n  atom,\n  Atom,\n  AtomMut,\n  Ctx,\n  CtxParams,\n  Fn,\n  throwReatomError,\n  __count,\n  AtomCache,\n  Unsubscribe,\n  AtomState,\n} from '@reatom/core'\nimport { __thenReatomed, onCtxAbort } from '@reatom/effects'\nimport { assign, isAbort, noop, sleep, toAbortError } from '@reatom/utils'\n\nimport { handleEffect } from './handleEffect'\nexport { withCache } from './withCache'\nexport { withStatusesAtom } from './withStatusesAtom'\nexport type {\n  AsyncStatusesNeverPending,\n  AsyncStatusesFirstPending,\n  AsyncStatusesFulfilled,\n  AsyncStatusesRejected,\n  AsyncStatusesAnotherPending,\n  AsyncStatusesPending,\n  AsyncStatuses,\n  AsyncStatusesAtom,\n} from './withStatusesAtom'\n\nexport interface AsyncAction<Params extends any[] = any[], Resp = any>\n  extends Action<Params, ControlledPromise<Resp>> {\n  onFulfill: Action<[Resp], Resp>\n  onReject: Action<[unknown], unknown>\n  onSettle: Action<[], void>\n  pendingAtom: Atom<number>\n\n  /** @deprecated @internal */\n  _handleCache?: Action<Params, ControlledPromise<Resp>>\n}\n\nexport type AsyncResp<T extends AsyncAction> = ActionPayload<T['onFulfill']>\n\nexport interface AsyncCause extends AtomCache {\n  controller: AbortController\n}\n\nexport interface AsyncCtx extends Ctx {\n  controller: AbortController\n  cause: AsyncCause\n}\n\nexport interface AsyncOptions<Params extends any[] = any[], Resp = any> {\n  name?: string\n  onEffect?: Fn<[Ctx, Params, ControlledPromise<Resp>]>\n  onFulfill?: Fn<[Ctx, Resp]>\n  onReject?: Fn<[Ctx, unknown]>\n  onSettle?: Fn<[Ctx]>\n}\n\nexport interface ControlledPromise<T = any> extends Promise<T> {\n  controller: AbortController\n}\n\nexport const isAbortError = isAbort\n\nconst getCache = (ctx: Ctx, anAtom: Atom): AtomCache => {\n  ctx.get(anAtom)\n  return anAtom.__reatom.patch ?? ctx.get((read) => read(anAtom.__reatom))!\n}\n\nexport const unstable_dropController = (ctx: Ctx): AsyncCtx => {\n  const controller = new AbortController()\n  return {\n    ...ctx,\n    cause: {\n      ...ctx.cause,\n      controller,\n    },\n    controller,\n  }\n}\n\nexport const reatomAsync = <\n  Params extends [AsyncCtx, ...any[]] = [AsyncCtx, ...any[]],\n  Resp = any,\n>(\n  effect: Fn<Params, Promise<Resp>>,\n  options: string | AsyncOptions<CtxParams<Params>, Resp> = {},\n): AsyncAction<CtxParams<Params>, Resp> => {\n  const {\n    name = __count('async'),\n    onEffect: onEffectHook,\n    onFulfill: onFulfillHook,\n    onReject: onRejectHook,\n    onSettle: onSettleHook,\n  } = typeof options === 'string'\n    ? ({ name: options } as AsyncOptions<CtxParams<Params>, Resp>)\n    : options\n\n  const pendingAtom = atom(0, `${name}.pendingAtom`)\n\n  // @ts-expect-error the missed properties assigned later\n  const onEffect: AsyncAction = Object.assign(\n    // do not put this function inside `action` to not broke effect mocking\n    (...params: Params) =>\n      params[0].get((read, actualize) => {\n        const { state } = actualize!(\n          params[0],\n          onEffect.__reatom,\n          (ctx: AsyncCtx, patch: AtomCache) => {\n            // userspace controller\n            ctx.controller = ctx.cause.controller = new AbortController()\n\n            onCtxAbort(params[0], (error) => ctx.controller.abort(error))\n\n            params[0] = ctx\n\n            patch.state = [\n              ...patch.state,\n              {\n                params: params.slice(1),\n                payload: onEffect._handleCache\n                  ? // @ts-expect-error\n                    onEffect._handleCache(...params)\n                  : handleEffect(onEffect, params),\n              },\n            ]\n          },\n        )\n        return state[state.length - 1]!.payload\n      }),\n    action(\n      // @ts-expect-error TODO need a better way to pass a custom Ctx.\n      effect,\n      name,\n    ),\n  )\n\n  const onFulfill = action<Resp>(`${name}.onFulfill`)\n  const onReject = action<unknown>(`${name}.onReject`)\n  const onSettle = action(`${name}._onSettle`)\n\n  onFulfill.onCall((ctx) => onSettle(ctx))\n  onReject.onCall((ctx) => onSettle(ctx))\n\n  if (onEffectHook) {\n    onEffect.onCall((ctx, promise, params) =>\n      onEffectHook(ctx, params as any, promise),\n    )\n  }\n  if (onFulfillHook) onFulfill.onCall(onFulfillHook)\n  if (onRejectHook) onReject.onCall(onRejectHook)\n  if (onSettleHook) onSettle.onCall(onSettleHook)\n\n  return assign(onEffect, {\n    onFulfill,\n    onReject,\n    onSettle,\n    pendingAtom,\n  })\n}\nreatomAsync.from = <Params extends any[], Resp = any>(\n  effect: Fn<Params, Promise<Resp>>,\n  options: string | AsyncOptions<Params, Resp> = {},\n): AsyncAction<Params, Resp> => {\n  // check uglification\n  if (effect.name.length > 2) {\n    if (typeof options === 'object') options.name ??= effect.name\n    else options ??= effect.name\n  }\n  // @ts-expect-error\n  return reatomAsync((ctx, ...a) => effect(...a), options)\n}\n\nexport interface AsyncDataAtom<State = any> extends AtomMut<State> {\n  reset: Action<[], void>\n}\n\n// TODO\n// @ts-ignore\nexport const withDataAtom: {\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(): Fn<[T], T & { dataAtom: AtomMut<undefined | AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(\n    initState: AsyncResp<T>,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<State | AsyncResp<T>>\n    },\n    State,\n  >(\n    initState: State,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<State | AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(\n    initState: AsyncResp<T>,\n    map?: Fn<\n      [ctx: Ctx, payload: AsyncResp<T>, state: AsyncResp<T>],\n      AsyncResp<T>\n    >,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<State>\n    },\n    State,\n  >(\n    initState: State,\n    map?: Fn<[ctx: Ctx, payload: AsyncResp<T>, state: State], State>,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<State> }>\n} =\n  (initState: any, map?: Fn) =>\n  // @ts-ignore\n  (anAsync: AsyncAction & { dataAtom?: AsyncDataAtom }) => {\n    if (!anAsync.dataAtom) {\n      const dataAtom: AsyncDataAtom = (anAsync.dataAtom = Object.assign(\n        atom(initState, `${anAsync.__reatom.name}.dataAtom`),\n        {\n          reset: action(\n            (ctx) => void dataAtom(ctx, initState),\n            `${anAsync.__reatom.name}.dataAtom.reset`,\n          ),\n        },\n      ) as AsyncDataAtom)\n      anAsync.onFulfill.onCall((ctx, payload) =>\n        dataAtom(ctx, (state: any) =>\n          map ? map(ctx, payload, state) : payload,\n        ),\n      )\n    }\n\n    return anAsync\n  }\n\nexport const withErrorAtom =\n  <\n    T extends AsyncAction & {\n      errorAtom?: AtomMut<undefined | Err> & { reset: Action }\n    },\n    Err = Error,\n  >(\n    parseError: Fn<[Ctx, unknown], Err> = (ctx, e) =>\n      (e instanceof Error ? e : new Error(String(e))) as Err,\n    {\n      resetTrigger,\n    }: {\n      resetTrigger:\n        | null\n        | 'onEffect'\n        | 'onFulfill'\n        | ('dataAtom' extends keyof T ? 'dataAtom' : null)\n    } = {\n      resetTrigger: 'onEffect',\n    },\n  ): Fn<[T], T & { errorAtom: Atom<undefined | Err> & { reset: Action } }> =>\n  (anAsync) => {\n    if (!anAsync.errorAtom) {\n      const errorAtomName = `${anAsync.__reatom.name}.errorAtom`\n      const errorAtom = (anAsync.errorAtom = assign(\n        atom<undefined | Err>(undefined, errorAtomName),\n        {\n          reset: action((ctx) => {\n            errorAtom(ctx, undefined)\n          }, `${errorAtomName}.reset`),\n        },\n      ))\n      anAsync.onReject.onCall((ctx, payload) =>\n        errorAtom(ctx, parseError(ctx, payload)),\n      )\n      if (resetTrigger) {\n        const resetTriggerAtom = { ...anAsync, onEffect: anAsync }[\n          resetTrigger\n        ] as Atom\n\n        resetTriggerAtom.onChange((ctx) => {\n          if (ctx.get(errorAtom) !== undefined) {\n            errorAtom.reset(ctx)\n          }\n        })\n      }\n    }\n\n    return anAsync as T & { errorAtom: Atom<undefined | Err> }\n  }\n\nexport const withAbort =\n  <\n    T extends AsyncAction & {\n      abort?: Action<[reason?: string], void>\n      onAbort?: Action<[Error], Error>\n      abortControllerAtom?: Atom<AbortController | null>\n    },\n  >({\n    strategy = 'last-in-win',\n  }: { strategy?: 'none' | 'last-in-win' | 'first-in-win' } = {}): Fn<\n    [T],\n    T & {\n      abort: Action<[reason?: string], void>\n      onAbort: Action<[Error], Error>\n      abortControllerAtom: Atom<AbortController | null>\n    }\n  > =>\n  (anAsync) => {\n    if (!anAsync.abort) {\n      const abortControllerAtom = (anAsync.abortControllerAtom = atom(\n        (\n          ctx,\n          state: AbortController & {\n            settled?: boolean\n          } = new AbortController(),\n        ) => {\n          ctx.spy(anAsync, ({ payload: promise }) => {\n            if (strategy === 'last-in-win' && state) {\n              const controller = state\n\n              ctx.schedule(() => {\n                controller.abort(\n                  toAbortError('concurrent request (last-in-win)'),\n                )\n              })\n            }\n\n            if (strategy === 'first-in-win' && state && !state.settled) {\n              promise.controller.abort(\n                toAbortError('concurrent request (first-in-win)'),\n              )\n              return\n            }\n\n            state = promise.controller\n\n            const handleAbort = () => {\n              state.settled = true\n              anAsync.onAbort!(ctx, toAbortError(state.signal.reason))\n            }\n\n            state.signal.addEventListener('abort', handleAbort)\n\n            const removeAbortHandler = () =>\n              state.signal.removeEventListener('abort', handleAbort)\n\n            __thenReatomed(ctx, promise, removeAbortHandler, removeAbortHandler)\n          })\n\n          return state\n        },\n        `${anAsync.__reatom.name}._abortControllerAtom`,\n      ))\n      // force track computed atom\n      anAsync.onCall((ctx) => void ctx.get(abortControllerAtom))\n      // addOnUpdate(anAsync.onSettle, (ctx) => void ctx.get(abortControllerAtom))\n\n      anAsync.abort = action((ctx, reason?: string) => {\n        const controller = ctx.get(abortControllerAtom)\n        if (controller) {\n          const error = toAbortError(reason)\n          ctx.schedule(() => controller.abort(error))\n        }\n      }, `${anAsync.__reatom.name}.abort`)\n      anAsync.onAbort = action<Error>(`${anAsync.__reatom.name}.onAbort`)\n    }\n\n    return anAsync as T & {\n      abort: Action<[reason?: string], void>\n      onAbort: Action<[Error], Error>\n      abortControllerAtom: Atom<AbortController | null>\n    }\n  }\n\nexport const withRetry =\n  <\n    T extends AsyncAction & {\n      paramsAtom?: Atom<Params | ActionParams<T>>\n      retry?: Action<[after?: number], ActionPayload<T>>\n      retriesAtom?: Atom<number>\n    },\n    Params extends ActionParams<T> | undefined = undefined,\n  >({\n    fallbackParams,\n    onReject,\n  }: {\n    fallbackParams?: Params\n    onReject?: Fn<[ctx: Ctx, error: unknown, retries: number], void | number>\n  } = {}): Fn<\n    [T],\n    T & {\n      paramsAtom: Atom<undefined | ActionParams<T>>\n      retry: Action<[after?: number], ActionPayload<T>>\n      retriesAtom: Atom<number>\n    }\n  > =>\n  (anAsync) => {\n    if (!anAsync.paramsAtom) {\n      const paramsAtom = (anAsync.paramsAtom = atom(\n        fallbackParams as Params,\n        `${anAsync.__reatom.name}._paramsAtom`,\n      ))\n      anAsync.onCall((ctx, payload, params) =>\n        paramsAtom(ctx, params as Params),\n      )\n\n      anAsync.retry = action((ctx, after = 0): ActionPayload<T> => {\n        throwReatomError(after < 0, 'wrong timeout')\n\n        const params = ctx.get(anAsync.paramsAtom!)\n        throwReatomError(!params, 'no cached params')\n\n        const asyncSnapshot = getCache(ctx, anAsync)\n        const hasOtherCall = () => asyncSnapshot !== getCache(ctx, anAsync)\n\n        retriesAtom(ctx, (s) => s + 1)\n\n        return ctx.schedule(async () => {\n          if (after > 0) await sleep(after)\n\n          if (hasOtherCall()) {\n            throw toAbortError('outdated retry')\n          }\n\n          return await anAsync(ctx, ...params!)\n        }) as ActionPayload<T>\n      }, `${anAsync.__reatom.name}.retry`)\n\n      const retriesAtom = (anAsync.retriesAtom = atom(\n        0,\n        `${anAsync.__reatom.name}.retriesAtom`,\n      ))\n\n      if (onReject) {\n        anAsync.onCall((ctx, payload) => {\n          __thenReatomed(\n            ctx,\n            payload,\n            () => retriesAtom(ctx, 0),\n            (error) => {\n              if (isAbort(error)) return\n              const timeout = onReject(ctx, error, ctx.get(retriesAtom)) ?? -1\n\n              if (timeout < 0) return\n\n              anAsync.retry!(unstable_dropController(ctx), timeout).catch(noop)\n            },\n          )\n        })\n      }\n    }\n\n    return anAsync as T & {\n      paramsAtom: Atom<undefined | ActionParams<T>>\n      retry: Action<[], ActionPayload<T>>\n      retriesAtom: Atom<number>\n    }\n  }\n\n/** @deprecated use `withRetry` instead */\nexport const withRetryAction = withRetry\n\nexport interface MappedAsyncAction<\n  Params extends any[] = unknown[],\n  Payload = unknown,\n> extends AsyncAction<Params, Payload> {\n  /**\n   * Function that unsubscribes from source atom\n   * @experimental\n   */\n  unstable_unhook: Unsubscribe\n}\n\n/**\n * Transform atom state into reatomAsync arguments\n */\nexport function mapToAsync<T extends Atom, Res>(\n  effect: Fn<[AsyncCtx, AtomState<T>], Promise<Res>>,\n  options: AsyncOptions<[AtomState<T>], Res> = {},\n): Fn<[T], MappedAsyncAction<[AtomState<T>], Res>> {\n  return (sourceAtom: Atom) => {\n    const asyncAction = reatomAsync(effect, {\n      ...options,\n      name: options.name ?? `${sourceAtom.__reatom.name}.mapToAsync`,\n    }) as MappedAsyncAction<[AtomState<T>], Res>\n    asyncAction.unstable_unhook = sourceAtom.onChange(asyncAction)\n\n    return asyncAction\n  }\n}\n"],"names":["handleEffect","anAsync","params","_temp","shouldPending","shouldFulfill","shouldReject","effect","__reatom","unstable_fn","pendingAtom","ctx","s","origin","schedule","Promise","res","rej","throwIfAborted","controller","then","signal","addEventListener","e","toAbortError","reason","assign","__thenReatomed","v","onFulfill","isAbort","onReject","NOOP_TIMEOUT_ID","withCache","ignoreAbort","length","paramsLength","staleTime","swr","swrOptions","withPersist","paramsToKey","isEqual","a","b","isDeepEqual","cacheAtom","Infinity","Math","min","MAX_SAFE_TIMEOUT","find","state","get","key","cached","undefined","findLatestWithValue","values","version","latestCached","lastUpdate","deleteOldest","cache","oldestCached","oldestKey","delete","planCleanup","time","clearTimeoutId","setTimeout","unref","clearTimeout","reatomMap","Map","name","invalidate","action","latest","clear","pipe","fromSnapshot","snapshot","size","every","_ref","value","newState","rec","Date","now","promise","set","toSnapshot","filter","_ref2","handlePromise","isSame","slice","call","arguments","_temp3","unstable_dropController","_temp2","resolve","_catch","error","reject","_handleCache","cause","paramsKey","initState","dataAtom","onConnect","subscribe","memo","reducer","isShallowEqual","withStatusesAtom","statusesAtom","atom","isPending","isFulfilled","isRejected","isSettled","isFirstPending","isEverPending","isEverSettled","onCall","payload","statuses","isAbortError","getCache","anAtom","patch","read","AbortController","reatomAsync","options","__count","onEffect","onEffectHook","onFulfillHook","onRejectHook","onSettle","onSettleHook","Object","actualize","onCtxAbort","abort","from","withDataAtom","map","reset","withErrorAtom","parseError","Error","String","resetTrigger","errorAtom","errorAtomName","onChange","withAbort","strategy","abortControllerAtom","spy","settled","handleAbort","onAbort","removeAbortHandler","removeEventListener","withRetry","fallbackParams","paramsAtom","retry","after","throwReatomError","asyncSnapshot","retriesAtom","_temp5","_temp4","sleep","timeout","catch","noop","withRetryAction","mapToAsync","sourceAtom","asyncAction","unstable_unhook"],"mappings":"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"}