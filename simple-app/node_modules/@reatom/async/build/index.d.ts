import { Action, ActionParams, ActionPayload, Atom, AtomMut, Ctx, CtxParams, Fn, AtomCache, Unsubscribe, AtomState } from '@reatom/core';
export { withCache } from './withCache';
export { withStatusesAtom } from './withStatusesAtom';
export type { AsyncStatusesNeverPending, AsyncStatusesFirstPending, AsyncStatusesFulfilled, AsyncStatusesRejected, AsyncStatusesAnotherPending, AsyncStatusesPending, AsyncStatuses, AsyncStatusesAtom, } from './withStatusesAtom';
export interface AsyncAction<Params extends any[] = any[], Resp = any> extends Action<Params, ControlledPromise<Resp>> {
    onFulfill: Action<[Resp], Resp>;
    onReject: Action<[unknown], unknown>;
    onSettle: Action<[], void>;
    pendingAtom: Atom<number>;
    /** @deprecated @internal */
    _handleCache?: Action<Params, ControlledPromise<Resp>>;
}
export type AsyncResp<T extends AsyncAction> = ActionPayload<T['onFulfill']>;
export interface AsyncCause extends AtomCache {
    controller: AbortController;
}
export interface AsyncCtx extends Ctx {
    controller: AbortController;
    cause: AsyncCause;
}
export interface AsyncOptions<Params extends any[] = any[], Resp = any> {
    name?: string;
    onEffect?: Fn<[Ctx, Params, ControlledPromise<Resp>]>;
    onFulfill?: Fn<[Ctx, Resp]>;
    onReject?: Fn<[Ctx, unknown]>;
    onSettle?: Fn<[Ctx]>;
}
export interface ControlledPromise<T = any> extends Promise<T> {
    controller: AbortController;
}
export declare const isAbortError: (thing: any) => thing is import("@reatom/utils").AbortError;
export declare const unstable_dropController: (ctx: Ctx) => AsyncCtx;
export declare const reatomAsync: {
    <Params extends [AsyncCtx, ...any[]] = [AsyncCtx, ...any[]], Resp = any>(effect: Fn<Params, Promise<Resp>>, options?: string | AsyncOptions<CtxParams<Params>, Resp>): AsyncAction<CtxParams<Params>, Resp>;
    from<Params_1 extends any[], Resp_1 = any>(effect: Fn<Params_1, Promise<Resp_1>>, options?: string | AsyncOptions<Params_1, Resp_1>): AsyncAction<Params_1, Resp_1>;
};
export interface AsyncDataAtom<State = any> extends AtomMut<State> {
    reset: Action<[], void>;
}
export declare const withDataAtom: {
    <T extends AsyncAction & {
        dataAtom?: AsyncDataAtom<AsyncResp<T>>;
    }>(): Fn<[T], T & {
        dataAtom: AtomMut<undefined | AsyncResp<T>>;
    }>;
    <T extends AsyncAction & {
        dataAtom?: AsyncDataAtom<AsyncResp<T>>;
    }>(initState: AsyncResp<T>): Fn<[T], T & {
        dataAtom: AsyncDataAtom<AsyncResp<T>>;
    }>;
    <T extends AsyncAction & {
        dataAtom?: AsyncDataAtom<State | AsyncResp<T>>;
    }, State>(initState: State): Fn<[T], T & {
        dataAtom: AsyncDataAtom<State | AsyncResp<T>>;
    }>;
    <T extends AsyncAction & {
        dataAtom?: AsyncDataAtom<AsyncResp<T>>;
    }>(initState: AsyncResp<T>, map?: Fn<[
        ctx: Ctx,
        payload: AsyncResp<T>,
        state: AsyncResp<T>
    ], AsyncResp<T>>): Fn<[T], T & {
        dataAtom: AsyncDataAtom<AsyncResp<T>>;
    }>;
    <T extends AsyncAction & {
        dataAtom?: AsyncDataAtom<State>;
    }, State>(initState: State, map?: Fn<[ctx: Ctx, payload: AsyncResp<T>, state: State], State>): Fn<[T], T & {
        dataAtom: AsyncDataAtom<State>;
    }>;
};
export declare const withErrorAtom: <T extends AsyncAction<any[], any> & {
    errorAtom?: (AtomMut<Err | undefined> & {
        reset: Action;
    }) | undefined;
}, Err = Error>(parseError?: Fn<[Ctx, unknown], Err>, { resetTrigger, }?: {
    resetTrigger: "onFulfill" | "onEffect" | ("dataAtom" extends keyof T ? "dataAtom" : null) | null;
}) => Fn<[T], T & {
    errorAtom: Atom<Err | undefined> & {
        reset: Action;
    };
}>;
export declare const withAbort: <T extends AsyncAction<any[], any> & {
    abort?: Action<[reason?: string | undefined], void> | undefined;
    onAbort?: Action<[Error], Error> | undefined;
    abortControllerAtom?: Atom<AbortController | null> | undefined;
}>({ strategy, }?: {
    strategy?: "none" | "last-in-win" | "first-in-win" | undefined;
}) => Fn<[T], T & {
    abort: Action<[reason?: string], void>;
    onAbort: Action<[Error], Error>;
    abortControllerAtom: Atom<AbortController | null>;
}>;
export declare const withRetry: <T extends AsyncAction<any[], any> & {
    paramsAtom?: Atom<Params | ActionParams<T>> | undefined;
    retry?: Action<[after?: number | undefined], ActionPayload<T>> | undefined;
    retriesAtom?: Atom<number> | undefined;
}, Params extends ActionParams<T> | undefined = undefined>({ fallbackParams, onReject, }?: {
    fallbackParams?: Params | undefined;
    onReject?: Fn<[ctx: Ctx, error: unknown, retries: number], number | void> | undefined;
}) => Fn<[T], T & {
    paramsAtom: Atom<ActionParams<T> | undefined>;
    retry: Action<[after?: number | undefined], ActionPayload<T>>;
    retriesAtom: Atom<number>;
}>;
/** @deprecated use `withRetry` instead */
export declare const withRetryAction: <T extends AsyncAction<any[], any> & {
    paramsAtom?: Atom<Params | ActionParams<T>> | undefined;
    retry?: Action<[after?: number | undefined], ActionPayload<T>> | undefined;
    retriesAtom?: Atom<number> | undefined;
}, Params extends ActionParams<T> | undefined = undefined>({ fallbackParams, onReject, }?: {
    fallbackParams?: Params | undefined;
    onReject?: Fn<[ctx: Ctx, error: unknown, retries: number], number | void> | undefined;
}) => Fn<[T], T & {
    paramsAtom: Atom<ActionParams<T> | undefined>;
    retry: Action<[after?: number | undefined], ActionPayload<T>>;
    retriesAtom: Atom<number>;
}>;
export interface MappedAsyncAction<Params extends any[] = unknown[], Payload = unknown> extends AsyncAction<Params, Payload> {
    /**
     * Function that unsubscribes from source atom
     * @experimental
     */
    unstable_unhook: Unsubscribe;
}
/**
 * Transform atom state into reatomAsync arguments
 */
export declare function mapToAsync<T extends Atom, Res>(effect: Fn<[AsyncCtx, AtomState<T>], Promise<Res>>, options?: AsyncOptions<[AtomState<T>], Res>): Fn<[T], MappedAsyncAction<[AtomState<T>], Res>>;
//# sourceMappingURL=index.d.ts.map