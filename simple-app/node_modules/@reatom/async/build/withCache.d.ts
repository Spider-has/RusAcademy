import { Action, ActionParams, AtomMut, AtomState, Ctx, Fn } from '@reatom/core';
import { MapAtom } from '@reatom/primitives';
import { type WithPersistOptions } from '@reatom/persist';
import { AsyncAction, AsyncResp, ControlledPromise } from '.';
export interface CacheRecord<T = any, Params extends any[] = unknown[]> {
    clearTimeoutId: ReturnType<typeof setTimeout>;
    /** It is more like **"lastRequest"**,
     * which is expected for failed fetching,
     * we don't want to remove the cache,
     * if we couldn't fetch new one. */
    lastUpdate: number;
    params: Params;
    promise: undefined | Promise<T>;
    value: undefined | T;
    /** value version */
    version: number;
}
export interface CacheAtom<T = any, Params extends any[] = unknown[]> extends MapAtom<unknown, CacheRecord<T, Params>> {
    /** Clear all records and call the effect with the last params. */
    invalidate: Action<[], null | ControlledPromise<T>>;
}
export type WithCacheOptions<T extends AsyncAction = AsyncAction> = {
    /** Define if the effect should be prevented from abort.
     * The outer abort strategy is not affected, which means that all hooks and returned promise will behave the same.
     * But the effect execution could be continued even if abort appears, to save the result in the cache.
     * @default true
     */
    ignoreAbort?: boolean;
    /** Maximum amount of cache records.
     * @default 5
     */
    length?: number;
    /** The number of excepted parameters, which will used as a cache key.
     * @default undefined (all)
     */
    paramsLength?: number;
    /** The amount of milliseconds after which a cache record cleanups.
     * @default 5 * 60 * 1000 ms (5 minutes)
     */
    staleTime?: number;
    /** (stale while revalidate) Define if fetching should be triggered even if the cache is exists.
     * A boolean value applies to all options
     * @default true
     */
    swr?: boolean | {
        /** success revalidation should trigger `onFulfill` to notify about the fresh data
         * @default true
         */
        shouldFulfill?: boolean;
        /** error revalidation trigger `onReject` to notify about the error
         * @default true
         */
        shouldReject?: boolean;
    };
    /** Persist adapter, which will used with predefined optimal parameters */
    withPersist?: (options: WithPersistOptions<AtomState<CacheAtom<AsyncResp<T>, ActionParams<T>>>>) => (anAsync: CacheAtom<AsyncResp<T>, ActionParams<T>>) => CacheAtom<AsyncResp<T>, ActionParams<T>>;
} & ({
    /** Convert params to stable string and use as a map key.
     * Alternative to `isEqual`.
     * Disabled by default.
     */
    paramsToKey?: (ctx: Ctx, params: ActionParams<T>) => string;
} | {
    /** Check the equality of a cache record and passed params to find the cache.
     * Alternative to `paramsToKey`.
     * @default `isDeepEqual` from @reatom/utils
     */
    isEqual?: (ctx: Ctx, prev: ActionParams<T>, next: ActionParams<T>) => boolean;
});
export declare const withCache: <T extends AsyncAction<any[], any> & {
    dataAtom?: AtomMut<any> | undefined;
    cacheAtom?: CacheAtom<AsyncResp<T>, ActionParams<T>> | undefined;
}>({ ignoreAbort, length, paramsLength, staleTime, swr: swrOptions, withPersist, paramsToKey, isEqual, }?: WithCacheOptions<T>) => Fn<[T], T & {
    cacheAtom: CacheAtom<AsyncResp<T>, ActionParams<T>>;
}>;
//# sourceMappingURL=withCache.d.ts.map