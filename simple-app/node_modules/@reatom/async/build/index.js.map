{"version":3,"file":"index.js","sources":["../src/handleEffect.ts","../src/withCache.ts","../src/withStatusesAtom.ts","../src/index.ts"],"sourcesContent":["import { AtomMut, Fn } from '@reatom/core'\nimport { AsyncAction, AsyncCtx, ControlledPromise } from '.'\nimport { assign, isAbort, throwIfAborted, toAbortError } from '@reatom/utils'\nimport { __thenReatomed } from '@reatom/effects'\n\nexport const handleEffect = (\n  anAsync: AsyncAction,\n  params: readonly [AsyncCtx, ...any[]],\n  {\n    shouldPending = true,\n    shouldFulfill = true,\n    shouldReject = true,\n    // @ts-expect-error could be reassigned by the testing package\n    effect = anAsync.__reatom.unstable_fn as Fn,\n  } = {},\n): ControlledPromise => {\n  const pendingAtom = anAsync.pendingAtom as AtomMut<number>\n  const [ctx] = params\n\n  if (shouldPending) pendingAtom(ctx, (s) => ++s)\n\n  const origin = ctx.schedule(\n    () =>\n      new Promise((res, rej) => {\n        throwIfAborted(ctx.controller)\n        effect(...params).then(res, rej)\n        ctx.controller.signal.addEventListener('abort', (e) =>\n          rej(toAbortError(ctx.controller.signal.reason)),\n        )\n      }),\n  )\n\n  return assign(\n    __thenReatomed(\n      ctx,\n      origin,\n      (v) => {\n        if (shouldFulfill) anAsync.onFulfill(ctx, v)\n        if (shouldPending) pendingAtom(ctx, (s) => --s)\n      },\n      (e) => {\n        if (shouldReject && !isAbort(e)) anAsync.onReject(ctx, e)\n        if (shouldPending) pendingAtom(ctx, (s) => --s)\n      },\n    ),\n    { controller: ctx.controller },\n  )\n}\n","import {\n  Action,\n  action,\n  ActionParams,\n  AtomMut,\n  AtomState,\n  Ctx,\n  Fn,\n} from '@reatom/core'\nimport { MapAtom, reatomMap } from '@reatom/primitives'\nimport { isDeepEqual, MAX_SAFE_TIMEOUT } from '@reatom/utils'\nimport { type WithPersistOptions } from '@reatom/persist'\n\nimport {\n  AsyncAction,\n  AsyncCause,\n  AsyncCtx,\n  AsyncResp,\n  ControlledPromise,\n  unstable_dropController,\n} from '.'\nimport { handleEffect } from './handleEffect'\nimport { onConnect } from '@reatom/hooks'\n\nexport interface CacheRecord<T = any, Params extends any[] = unknown[]> {\n  clearTimeoutId: ReturnType<typeof setTimeout>\n  /** It is more like **\"lastRequest\"**,\n   * which is expected for failed fetching,\n   * we don't want to remove the cache,\n   * if we couldn't fetch new one. */\n  lastUpdate: number\n  params: Params\n  promise: undefined | Promise<T>\n  value: undefined | T\n  /** value version */\n  version: number\n}\n\nexport interface CacheAtom<T = any, Params extends any[] = unknown[]>\n  extends MapAtom<unknown, CacheRecord<T, Params>> {\n  /** Clear all records and call the effect with the last params. */\n  invalidate: Action<[], null | ControlledPromise<T>>\n  // setWithParams: Action<[params: Params, value: T]>\n  // deleteWithParams: Action<[params: Params]>\n}\n\ntype CacheMapRecord<T extends AsyncAction = AsyncAction> =\n  | undefined\n  | CacheRecord<AsyncResp<T>, ActionParams<T>>\n\nexport type WithCacheOptions<T extends AsyncAction = AsyncAction> = {\n  /** Define if the effect should be prevented from abort.\n   * The outer abort strategy is not affected, which means that all hooks and returned promise will behave the same.\n   * But the effect execution could be continued even if abort appears, to save the result in the cache.\n   * @default true\n   */\n  ignoreAbort?: boolean\n\n  // TODO how to handle if `withDataAtom` defined after `withCache`?\n  // /** Define if the last cache should be used as init state of `dataAtom`.\n  //  * Useful when `withPersist` defined.\n  //  * @default true\n  //  */\n  // initData?: boolean\n\n  /** Maximum amount of cache records.\n   * @default 5\n   */\n  length?: number\n\n  /** The number of excepted parameters, which will used as a cache key.\n   * @default undefined (all)\n   */\n  paramsLength?: number\n\n  /** The amount of milliseconds after which a cache record cleanups.\n   * @default 5 * 60 * 1000 ms (5 minutes)\n   */\n  staleTime?: number\n\n  /** (stale while revalidate) Define if fetching should be triggered even if the cache is exists.\n   * A boolean value applies to all options\n   * @default true\n   */\n  swr?:\n    | boolean\n    | {\n        /** success revalidation should trigger `onFulfill` to notify about the fresh data\n         * @default true\n         */\n        shouldFulfill?: boolean\n        /** error revalidation trigger `onReject` to notify about the error\n         * @default true\n         */\n        shouldReject?: boolean\n      }\n\n  /** Persist adapter, which will used with predefined optimal parameters */\n  withPersist?: (\n    options: WithPersistOptions<\n      AtomState<CacheAtom<AsyncResp<T>, ActionParams<T>>>\n    >,\n  ) => (\n    anAsync: CacheAtom<AsyncResp<T>, ActionParams<T>>,\n  ) => CacheAtom<AsyncResp<T>, ActionParams<T>>\n} & (\n  | {\n      /** Convert params to stable string and use as a map key.\n       * Alternative to `isEqual`.\n       * Disabled by default.\n       */\n      paramsToKey?: (ctx: Ctx, params: ActionParams<T>) => string\n    }\n  | {\n      /** Check the equality of a cache record and passed params to find the cache.\n       * Alternative to `paramsToKey`.\n       * @default `isDeepEqual` from @reatom/utils\n       */\n      isEqual?: (\n        ctx: Ctx,\n        prev: ActionParams<T>,\n        next: ActionParams<T>,\n      ) => boolean\n    }\n)\n\ntype Find<T extends AsyncAction> = Fn<\n  [\n    ctx: Ctx,\n    params: ActionParams<T>,\n    state?: AtomState<CacheAtom<AsyncResp<T>, ActionParams<T>>>,\n  ],\n  { cached?: CacheMapRecord<T>; key: unknown }\n>\n\nconst NOOP_TIMEOUT_ID = -1 as unknown as ReturnType<typeof setTimeout>\n\nexport const withCache =\n  <\n    T extends AsyncAction & {\n      dataAtom?: AtomMut\n      cacheAtom?: CacheAtom<AsyncResp<T>, ActionParams<T>>\n    },\n  >({\n    ignoreAbort = true,\n    // initData = true,\n    length = 5,\n    paramsLength,\n    staleTime = 5 * 60 * 1000,\n    swr: swrOptions = true,\n    withPersist,\n    // @ts-expect-error\n    paramsToKey,\n    // @ts-expect-error\n    isEqual = (ctx: Ctx, a: any, b: any) => isDeepEqual(a, b),\n  }: WithCacheOptions<T> = {}): Fn<\n    [T],\n    T & {\n      cacheAtom: CacheAtom<AsyncResp<T>, ActionParams<T>>\n    }\n  > =>\n  // @ts-ignore\n  (anAsync) => {\n    if (!anAsync.cacheAtom) {\n      type ThisParams = ActionParams<T>\n      type ThisCacheAtom = CacheAtom<AsyncResp<T>, ThisParams>\n      type ThisCacheRecord = CacheRecord<AsyncResp<T>, ThisParams>\n\n      const swr = !!swrOptions\n      // @ts-expect-error valid and correct JS\n      const { shouldFulfill = swr, shouldReject = swr } = swrOptions\n      if (staleTime !== Infinity)\n        staleTime = Math.min(MAX_SAFE_TIMEOUT, staleTime)\n\n      const find: Find<T> = paramsToKey\n        ? (ctx, params, state = ctx.get(cacheAtom)) => {\n            const key = paramsToKey(ctx, params)\n            return { cached: state.get(key), key }\n          }\n        : (ctx, params, state = ctx.get(cacheAtom)) => {\n            for (const [key, cached] of state) {\n              if (isEqual(ctx, key, params)) return { cached, key }\n            }\n            return { cached: undefined, key: params }\n          }\n\n      const findLatestWithValue = (ctx: Ctx, state = ctx.get(cacheAtom)) => {\n        for (const cached of state.values()) {\n          if (\n            cached.version > 0 &&\n            (!latestCached || cached.lastUpdate > latestCached.lastUpdate)\n          ) {\n            var latestCached: undefined | ThisCacheRecord = cached\n          }\n        }\n        return latestCached\n      }\n\n      const deleteOldest = (cache: Map<unknown, ThisCacheRecord>) => {\n        for (const [key, cached] of cache) {\n          if (!oldestCached || oldestCached.lastUpdate > cached.lastUpdate) {\n            var oldestKey = key\n            var oldestCached: undefined | ThisCacheRecord = cached\n          }\n        }\n        // it is ok to mutate the cache,\n        // as it was just created from the set method\n        // and wasn't touched by anything.\n        if (oldestCached) cache.delete(oldestKey)\n      }\n\n      const planCleanup = (ctx: Ctx, key: unknown, time = staleTime) => {\n        const clearTimeoutId =\n          staleTime === Infinity\n            ? NOOP_TIMEOUT_ID\n            : setTimeout(() => {\n                if (\n                  cacheAtom.get(ctx, key)?.clearTimeoutId === clearTimeoutId\n                ) {\n                  cacheAtom.delete(ctx, key)\n                }\n              }, time)\n\n        clearTimeoutId.unref?.()\n        ctx.schedule(() => clearTimeout(clearTimeoutId), -1)\n\n        return clearTimeoutId\n      }\n\n      const cacheAtom = (anAsync.cacheAtom = reatomMap(\n        new Map(),\n        `${anAsync.__reatom.name}._cacheAtom`,\n      ) as ThisCacheAtom)\n\n      cacheAtom.invalidate = action((ctx) => {\n        const latest = findLatestWithValue(ctx)\n\n        cacheAtom.clear(ctx)\n\n        return latest ? anAsync(ctx, ...latest.params) : null\n      }, `${cacheAtom.__reatom.name}.invalidate`)\n\n      if (withPersist) {\n        // TODO the key could be provided by a decorator function\n        // like `withPersist: options => withLocalStorage({ ...options, key: 'key' })`\n        // how to check it??\n        // throwReatomError(\n        //   anAsync.__reatom.name!.includes('#'),\n        //   'the async name is not unique',\n        // )\n\n        cacheAtom.pipe(\n          withPersist({\n            key: cacheAtom.__reatom.name!,\n            // @ts-expect-error snapshot unknown type\n            fromSnapshot: (\n              ctx,\n              snapshot: Array<[unknown, ThisCacheRecord]>,\n              state = new Map(),\n            ) => {\n              if (\n                snapshot.length <= state?.size &&\n                snapshot.every(([, { params, value }]) => {\n                  const { cached } = find(ctx, params, state)\n                  return !!cached && isDeepEqual(cached.value, value)\n                })\n              ) {\n                return state\n              }\n\n              const newState = new Map(snapshot)\n\n              for (const [key, rec] of newState) {\n                const restStaleTime = staleTime - (Date.now() - rec.lastUpdate)\n                if (restStaleTime <= 0) {\n                  newState.delete(key)\n                } else {\n                  rec.clearTimeoutId = planCleanup(\n                    ctx,\n                    key,\n                    staleTime - (Date.now() - rec.lastUpdate),\n                  )\n                }\n              }\n\n              for (const [key, rec] of state) {\n                if (rec.promise) {\n                  const { cached } = find(ctx, rec.params, newState)\n                  if (cached) {\n                    cached.promise = rec.promise\n                  } else {\n                    newState.set(key, rec)\n                  }\n                }\n              }\n\n              return newState\n            },\n            time: Math.min(staleTime, MAX_SAFE_TIMEOUT),\n            toSnapshot: (ctx, cache) =>\n              [...cache].filter(([, rec]) => !rec.promise),\n          }),\n        )\n      }\n\n      const handlePromise = (\n        ctx: Ctx,\n        key: unknown,\n        cached: ThisCacheRecord,\n      ) => {\n        cached.clearTimeoutId = planCleanup(ctx, key)\n        // the case: the whole cache was cleared and a new fetching was started\n        const isSame = () =>\n          cacheAtom.get(ctx, key)?.clearTimeoutId === cached.clearTimeoutId\n\n        // @ts-expect-error could be reassigned by the testing package\n        const { unstable_fn } = anAsync.__reatom\n        let res: Fn, rej: Fn\n        cached.promise = new Promise<AsyncResp<T>>((...a) => ([res, rej] = a))\n\n        return async (...a: Parameters<T>) => {\n          if (ignoreAbort) {\n            a[0] = unstable_dropController(a[0])\n          }\n\n          try {\n            const value = await unstable_fn(...a)\n            res(value)\n\n            if (isSame()) {\n              cacheAtom.set(ctx, key, {\n                ...cached,\n                promise: undefined,\n                value,\n                version: cached.version + 1,\n              })\n            }\n          } catch (error) {\n            rej(error)\n\n            if (isSame()) {\n              if (cached.version > 0) {\n                cacheAtom.set(ctx, key, {\n                  ...cached,\n                  promise: undefined,\n                })\n              } else {\n                cacheAtom.delete(ctx, key)\n              }\n            }\n          }\n          return cached.promise\n        }\n      }\n\n      // @ts-ignore\n      anAsync._handleCache = action(\n        // @ts-expect-error can't type the context\n        (...params: [AsyncCtx, ...ThisParams]): ControlledPromise => {\n          const [ctx] = params\n          const { controller } = ctx.cause.cause as AsyncCause\n          ctx.controller = ctx.cause.controller = controller\n\n          const paramsKey = params.slice(\n            1,\n            1 + (paramsLength ?? params.length),\n          ) as ThisParams\n\n          let {\n            cached = {\n              clearTimeoutId: NOOP_TIMEOUT_ID,\n              promise: undefined,\n              value: undefined,\n              version: 0,\n              lastUpdate: -1,\n              params: [],\n            },\n            key,\n          } = find(ctx, paramsKey)\n\n          cached = {\n            ...cached,\n            lastUpdate: Date.now(),\n            params: paramsKey,\n          }\n\n          const cache = cacheAtom.set(ctx, key, cached)\n          if (cache.size > length) deleteOldest(cache)\n\n          if (cached.version === 0 && !cached.promise) {\n            return handleEffect(anAsync, params, {\n              effect: handlePromise(ctx, key, cached),\n            })\n          }\n\n          // have a value\n          if (cached.version > 0) anAsync.onFulfill(ctx, cached.value)\n\n          if (cached.promise || !swr) {\n            return handleEffect(anAsync, params, {\n              effect: async () => cached.promise ?? cached.value,\n              shouldPending: false,\n              shouldFulfill,\n              shouldReject,\n            })\n          }\n\n          return handleEffect(anAsync, params, {\n            effect: handlePromise(ctx, key, cached),\n            shouldPending: false,\n            shouldFulfill,\n            shouldReject,\n          })\n        },\n        `${anAsync.__reatom.name}._handleCache`,\n      )\n\n      // TODO make it an option\n      if ('dataAtom' in anAsync) {\n        const { initState } = anAsync.dataAtom!.__reatom\n        anAsync.dataAtom!.__reatom.initState = (ctx) => {\n          const cached = findLatestWithValue(ctx)\n          return cached ? cached.value : initState(ctx)\n        }\n      }\n\n      // TODO handle it in dataAtom too to not couple to the order of operations\n      if ('dataAtom' in anAsync) {\n        onConnect(anAsync.dataAtom!, (ctx) =>\n          ctx.subscribe(cacheAtom, () => {}),\n        )\n      }\n    }\n\n    return anAsync\n  }\n","import { atom, Atom } from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\n\nimport { AsyncAction } from '.'\nimport { isShallowEqual } from '@reatom/utils'\n\nexport interface AsyncStatusesNeverPending {\n  isPending: false\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: false\n  // isNeverPending: true\n  isEverSettled: false\n  // isNeverSettled: true\n}\n\nexport interface AsyncStatusesFirstPending {\n  isPending: true\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: true\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: false\n  // isNeverSettled: true\n}\n\nexport interface AsyncStatusesFulfilled {\n  isPending: false\n  isFulfilled: true\n  isRejected: false\n  isSettled: true\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport interface AsyncStatusesRejected {\n  isPending: false\n  isFulfilled: false\n  isRejected: true\n  isSettled: true\n\n  isFirstPending: false\n  // isAnotherPending: false\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport interface AsyncStatusesAnotherPending {\n  isPending: true\n  isFulfilled: false\n  isRejected: false\n  isSettled: false\n\n  isFirstPending: false\n  // isAnotherPending: true\n  isEverPending: true\n  // isNeverPending: false\n  isEverSettled: true\n  // isNeverSettled: false\n}\n\nexport type AsyncStatusesPending =\n  | AsyncStatusesFirstPending\n  | AsyncStatusesAnotherPending\n\nexport type AsyncStatuses =\n  | AsyncStatusesNeverPending\n  | AsyncStatusesPending\n  | AsyncStatusesFulfilled\n  | AsyncStatusesRejected\n\nexport interface AsyncStatusesAtom extends Atom<AsyncStatuses> {\n  // TODO how to reset during pending?\n  // reset: Action<[], AsyncStatuses>\n}\n\nconst memo =\n  (reducer: (state: AsyncStatuses) => AsyncStatuses) =>\n  (state: AsyncStatuses): AsyncStatuses => {\n    const newState = reducer(state)\n    return isShallowEqual(state, newState) ? state : newState\n  }\n\nexport const withStatusesAtom =\n  <\n    T extends AsyncAction & {\n      statusesAtom?: AsyncStatusesAtom\n    },\n  >() =>\n  (anAsync: T): T & { statusesAtom: AsyncStatusesAtom } => {\n    if (!anAsync.statusesAtom) {\n      const statusesAtom = (anAsync.statusesAtom = atom<AsyncStatuses>(\n        {\n          isPending: false,\n          isFulfilled: false,\n          isRejected: false,\n          isSettled: false,\n\n          isFirstPending: false,\n          // isAnotherPending: false,\n          isEverPending: false,\n          // isNeverPending: true,\n          isEverSettled: false,\n          // isNeverSettled: true,\n        },\n        `${anAsync.__reatom.name}.statusesAtom`,\n      ))\n      anAsync.onCall((ctx, payload) => {\n        statusesAtom(\n          ctx,\n          memo((statuses) => {\n            return {\n              isPending: ctx.get(anAsync.pendingAtom) > 0,\n              isFulfilled: false,\n              isRejected: false,\n              isSettled: false,\n\n              isFirstPending: !statuses.isEverSettled,\n              // isAnotherPending: statuses.isEverPending,\n              isEverPending: true,\n              // isNeverPending: false,\n              isEverSettled: statuses.isEverSettled,\n              // isNeverSettled: statuses.isNeverSettled,\n            } as AsyncStatuses\n          }),\n        )\n\n        __thenReatomed(\n          ctx,\n          payload,\n          () =>\n            statusesAtom(\n              ctx,\n              memo(() => {\n                const isPending = ctx.get(anAsync.pendingAtom) > 0\n                return {\n                  isPending,\n                  isFulfilled: !isPending,\n                  isRejected: false,\n                  isSettled: !isPending,\n\n                  isFirstPending: false,\n                  // isAnotherPending: false,\n                  isEverPending: true,\n                  // isNeverPending: false,\n                  isEverSettled: true,\n                  // isNeverSettled: false,\n                } as AsyncStatuses\n              }),\n            ),\n          () =>\n            statusesAtom(\n              ctx,\n              memo(() => {\n                const isPending = ctx.get(anAsync.pendingAtom) > 0\n                return {\n                  isPending,\n                  isFulfilled: false,\n                  isRejected: !isPending,\n                  isSettled: !isPending,\n\n                  isFirstPending: false,\n                  // isAnotherPending: false,\n                  isEverPending: true,\n                  // isNeverPending: false,\n                  isEverSettled: true,\n                  // isNeverSettled: false,\n                } as AsyncStatuses\n              }),\n            ),\n        )\n      })\n    }\n\n    return anAsync as T & { statusesAtom: Atom<AsyncStatuses> }\n  }\n","// TODO https://hyperfetch.bettertyped.com/docs/Getting%20Started/Comparison/\n// TODO https://github.com/natemoo-re/ultrafetch\n\nimport {\n  action,\n  Action,\n  ActionParams,\n  ActionPayload,\n  atom,\n  Atom,\n  AtomMut,\n  Ctx,\n  CtxParams,\n  Fn,\n  throwReatomError,\n  __count,\n  AtomCache,\n  Unsubscribe,\n  AtomState,\n} from '@reatom/core'\nimport { __thenReatomed, onCtxAbort } from '@reatom/effects'\nimport { assign, isAbort, noop, sleep, toAbortError } from '@reatom/utils'\n\nimport { handleEffect } from './handleEffect'\nexport { withCache } from './withCache'\nexport { withStatusesAtom } from './withStatusesAtom'\nexport type {\n  AsyncStatusesNeverPending,\n  AsyncStatusesFirstPending,\n  AsyncStatusesFulfilled,\n  AsyncStatusesRejected,\n  AsyncStatusesAnotherPending,\n  AsyncStatusesPending,\n  AsyncStatuses,\n  AsyncStatusesAtom,\n} from './withStatusesAtom'\n\nexport interface AsyncAction<Params extends any[] = any[], Resp = any>\n  extends Action<Params, ControlledPromise<Resp>> {\n  onFulfill: Action<[Resp], Resp>\n  onReject: Action<[unknown], unknown>\n  onSettle: Action<[], void>\n  pendingAtom: Atom<number>\n\n  /** @deprecated @internal */\n  _handleCache?: Action<Params, ControlledPromise<Resp>>\n}\n\nexport type AsyncResp<T extends AsyncAction> = ActionPayload<T['onFulfill']>\n\nexport interface AsyncCause extends AtomCache {\n  controller: AbortController\n}\n\nexport interface AsyncCtx extends Ctx {\n  controller: AbortController\n  cause: AsyncCause\n}\n\nexport interface AsyncOptions<Params extends any[] = any[], Resp = any> {\n  name?: string\n  onEffect?: Fn<[Ctx, Params, ControlledPromise<Resp>]>\n  onFulfill?: Fn<[Ctx, Resp]>\n  onReject?: Fn<[Ctx, unknown]>\n  onSettle?: Fn<[Ctx]>\n}\n\nexport interface ControlledPromise<T = any> extends Promise<T> {\n  controller: AbortController\n}\n\nexport const isAbortError = isAbort\n\nconst getCache = (ctx: Ctx, anAtom: Atom): AtomCache => {\n  ctx.get(anAtom)\n  return anAtom.__reatom.patch ?? ctx.get((read) => read(anAtom.__reatom))!\n}\n\nexport const unstable_dropController = (ctx: Ctx): AsyncCtx => {\n  const controller = new AbortController()\n  return {\n    ...ctx,\n    cause: {\n      ...ctx.cause,\n      controller,\n    },\n    controller,\n  }\n}\n\nexport const reatomAsync = <\n  Params extends [AsyncCtx, ...any[]] = [AsyncCtx, ...any[]],\n  Resp = any,\n>(\n  effect: Fn<Params, Promise<Resp>>,\n  options: string | AsyncOptions<CtxParams<Params>, Resp> = {},\n): AsyncAction<CtxParams<Params>, Resp> => {\n  const {\n    name = __count('async'),\n    onEffect: onEffectHook,\n    onFulfill: onFulfillHook,\n    onReject: onRejectHook,\n    onSettle: onSettleHook,\n  } = typeof options === 'string'\n    ? ({ name: options } as AsyncOptions<CtxParams<Params>, Resp>)\n    : options\n\n  const pendingAtom = atom(0, `${name}.pendingAtom`)\n\n  // @ts-expect-error the missed properties assigned later\n  const onEffect: AsyncAction = Object.assign(\n    // do not put this function inside `action` to not broke effect mocking\n    (...params: Params) =>\n      params[0].get((read, actualize) => {\n        const { state } = actualize!(\n          params[0],\n          onEffect.__reatom,\n          (ctx: AsyncCtx, patch: AtomCache) => {\n            // userspace controller\n            ctx.controller = ctx.cause.controller = new AbortController()\n\n            onCtxAbort(params[0], (error) => ctx.controller.abort(error))\n\n            params[0] = ctx\n\n            patch.state = [\n              ...patch.state,\n              {\n                params: params.slice(1),\n                payload: onEffect._handleCache\n                  ? // @ts-expect-error\n                    onEffect._handleCache(...params)\n                  : handleEffect(onEffect, params),\n              },\n            ]\n          },\n        )\n        return state[state.length - 1]!.payload\n      }),\n    action(\n      // @ts-expect-error TODO need a better way to pass a custom Ctx.\n      effect,\n      name,\n    ),\n  )\n\n  const onFulfill = action<Resp>(`${name}.onFulfill`)\n  const onReject = action<unknown>(`${name}.onReject`)\n  const onSettle = action(`${name}._onSettle`)\n\n  onFulfill.onCall((ctx) => onSettle(ctx))\n  onReject.onCall((ctx) => onSettle(ctx))\n\n  if (onEffectHook) {\n    onEffect.onCall((ctx, promise, params) =>\n      onEffectHook(ctx, params as any, promise),\n    )\n  }\n  if (onFulfillHook) onFulfill.onCall(onFulfillHook)\n  if (onRejectHook) onReject.onCall(onRejectHook)\n  if (onSettleHook) onSettle.onCall(onSettleHook)\n\n  return assign(onEffect, {\n    onFulfill,\n    onReject,\n    onSettle,\n    pendingAtom,\n  })\n}\nreatomAsync.from = <Params extends any[], Resp = any>(\n  effect: Fn<Params, Promise<Resp>>,\n  options: string | AsyncOptions<Params, Resp> = {},\n): AsyncAction<Params, Resp> => {\n  // check uglification\n  if (effect.name.length > 2) {\n    if (typeof options === 'object') options.name ??= effect.name\n    else options ??= effect.name\n  }\n  // @ts-expect-error\n  return reatomAsync((ctx, ...a) => effect(...a), options)\n}\n\nexport interface AsyncDataAtom<State = any> extends AtomMut<State> {\n  reset: Action<[], void>\n}\n\n// TODO\n// @ts-ignore\nexport const withDataAtom: {\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(): Fn<[T], T & { dataAtom: AtomMut<undefined | AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(\n    initState: AsyncResp<T>,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<State | AsyncResp<T>>\n    },\n    State,\n  >(\n    initState: State,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<State | AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<AsyncResp<T>>\n    },\n  >(\n    initState: AsyncResp<T>,\n    map?: Fn<\n      [ctx: Ctx, payload: AsyncResp<T>, state: AsyncResp<T>],\n      AsyncResp<T>\n    >,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<AsyncResp<T>> }>\n  <\n    T extends AsyncAction & {\n      dataAtom?: AsyncDataAtom<State>\n    },\n    State,\n  >(\n    initState: State,\n    map?: Fn<[ctx: Ctx, payload: AsyncResp<T>, state: State], State>,\n  ): Fn<[T], T & { dataAtom: AsyncDataAtom<State> }>\n} =\n  (initState: any, map?: Fn) =>\n  // @ts-ignore\n  (anAsync: AsyncAction & { dataAtom?: AsyncDataAtom }) => {\n    if (!anAsync.dataAtom) {\n      const dataAtom: AsyncDataAtom = (anAsync.dataAtom = Object.assign(\n        atom(initState, `${anAsync.__reatom.name}.dataAtom`),\n        {\n          reset: action(\n            (ctx) => void dataAtom(ctx, initState),\n            `${anAsync.__reatom.name}.dataAtom.reset`,\n          ),\n        },\n      ) as AsyncDataAtom)\n      anAsync.onFulfill.onCall((ctx, payload) =>\n        dataAtom(ctx, (state: any) =>\n          map ? map(ctx, payload, state) : payload,\n        ),\n      )\n    }\n\n    return anAsync\n  }\n\nexport const withErrorAtom =\n  <\n    T extends AsyncAction & {\n      errorAtom?: AtomMut<undefined | Err> & { reset: Action }\n    },\n    Err = Error,\n  >(\n    parseError: Fn<[Ctx, unknown], Err> = (ctx, e) =>\n      (e instanceof Error ? e : new Error(String(e))) as Err,\n    {\n      resetTrigger,\n    }: {\n      resetTrigger:\n        | null\n        | 'onEffect'\n        | 'onFulfill'\n        | ('dataAtom' extends keyof T ? 'dataAtom' : null)\n    } = {\n      resetTrigger: 'onEffect',\n    },\n  ): Fn<[T], T & { errorAtom: Atom<undefined | Err> & { reset: Action } }> =>\n  (anAsync) => {\n    if (!anAsync.errorAtom) {\n      const errorAtomName = `${anAsync.__reatom.name}.errorAtom`\n      const errorAtom = (anAsync.errorAtom = assign(\n        atom<undefined | Err>(undefined, errorAtomName),\n        {\n          reset: action((ctx) => {\n            errorAtom(ctx, undefined)\n          }, `${errorAtomName}.reset`),\n        },\n      ))\n      anAsync.onReject.onCall((ctx, payload) =>\n        errorAtom(ctx, parseError(ctx, payload)),\n      )\n      if (resetTrigger) {\n        const resetTriggerAtom = { ...anAsync, onEffect: anAsync }[\n          resetTrigger\n        ] as Atom\n\n        resetTriggerAtom.onChange((ctx) => {\n          if (ctx.get(errorAtom) !== undefined) {\n            errorAtom.reset(ctx)\n          }\n        })\n      }\n    }\n\n    return anAsync as T & { errorAtom: Atom<undefined | Err> }\n  }\n\nexport const withAbort =\n  <\n    T extends AsyncAction & {\n      abort?: Action<[reason?: string], void>\n      onAbort?: Action<[Error], Error>\n      abortControllerAtom?: Atom<AbortController | null>\n    },\n  >({\n    strategy = 'last-in-win',\n  }: { strategy?: 'none' | 'last-in-win' | 'first-in-win' } = {}): Fn<\n    [T],\n    T & {\n      abort: Action<[reason?: string], void>\n      onAbort: Action<[Error], Error>\n      abortControllerAtom: Atom<AbortController | null>\n    }\n  > =>\n  (anAsync) => {\n    if (!anAsync.abort) {\n      const abortControllerAtom = (anAsync.abortControllerAtom = atom(\n        (\n          ctx,\n          state: AbortController & {\n            settled?: boolean\n          } = new AbortController(),\n        ) => {\n          ctx.spy(anAsync, ({ payload: promise }) => {\n            if (strategy === 'last-in-win' && state) {\n              const controller = state\n\n              ctx.schedule(() => {\n                controller.abort(\n                  toAbortError('concurrent request (last-in-win)'),\n                )\n              })\n            }\n\n            if (strategy === 'first-in-win' && state && !state.settled) {\n              promise.controller.abort(\n                toAbortError('concurrent request (first-in-win)'),\n              )\n              return\n            }\n\n            state = promise.controller\n\n            const handleAbort = () => {\n              state.settled = true\n              anAsync.onAbort!(ctx, toAbortError(state.signal.reason))\n            }\n\n            state.signal.addEventListener('abort', handleAbort)\n\n            const removeAbortHandler = () =>\n              state.signal.removeEventListener('abort', handleAbort)\n\n            __thenReatomed(ctx, promise, removeAbortHandler, removeAbortHandler)\n          })\n\n          return state\n        },\n        `${anAsync.__reatom.name}._abortControllerAtom`,\n      ))\n      // force track computed atom\n      anAsync.onCall((ctx) => void ctx.get(abortControllerAtom))\n      // addOnUpdate(anAsync.onSettle, (ctx) => void ctx.get(abortControllerAtom))\n\n      anAsync.abort = action((ctx, reason?: string) => {\n        const controller = ctx.get(abortControllerAtom)\n        if (controller) {\n          const error = toAbortError(reason)\n          ctx.schedule(() => controller.abort(error))\n        }\n      }, `${anAsync.__reatom.name}.abort`)\n      anAsync.onAbort = action<Error>(`${anAsync.__reatom.name}.onAbort`)\n    }\n\n    return anAsync as T & {\n      abort: Action<[reason?: string], void>\n      onAbort: Action<[Error], Error>\n      abortControllerAtom: Atom<AbortController | null>\n    }\n  }\n\nexport const withRetry =\n  <\n    T extends AsyncAction & {\n      paramsAtom?: Atom<Params | ActionParams<T>>\n      retry?: Action<[after?: number], ActionPayload<T>>\n      retriesAtom?: Atom<number>\n    },\n    Params extends ActionParams<T> | undefined = undefined,\n  >({\n    fallbackParams,\n    onReject,\n  }: {\n    fallbackParams?: Params\n    onReject?: Fn<[ctx: Ctx, error: unknown, retries: number], void | number>\n  } = {}): Fn<\n    [T],\n    T & {\n      paramsAtom: Atom<undefined | ActionParams<T>>\n      retry: Action<[after?: number], ActionPayload<T>>\n      retriesAtom: Atom<number>\n    }\n  > =>\n  (anAsync) => {\n    if (!anAsync.paramsAtom) {\n      const paramsAtom = (anAsync.paramsAtom = atom(\n        fallbackParams as Params,\n        `${anAsync.__reatom.name}._paramsAtom`,\n      ))\n      anAsync.onCall((ctx, payload, params) =>\n        paramsAtom(ctx, params as Params),\n      )\n\n      anAsync.retry = action((ctx, after = 0): ActionPayload<T> => {\n        throwReatomError(after < 0, 'wrong timeout')\n\n        const params = ctx.get(anAsync.paramsAtom!)\n        throwReatomError(!params, 'no cached params')\n\n        const asyncSnapshot = getCache(ctx, anAsync)\n        const hasOtherCall = () => asyncSnapshot !== getCache(ctx, anAsync)\n\n        retriesAtom(ctx, (s) => s + 1)\n\n        return ctx.schedule(async () => {\n          if (after > 0) await sleep(after)\n\n          if (hasOtherCall()) {\n            throw toAbortError('outdated retry')\n          }\n\n          return await anAsync(ctx, ...params!)\n        }) as ActionPayload<T>\n      }, `${anAsync.__reatom.name}.retry`)\n\n      const retriesAtom = (anAsync.retriesAtom = atom(\n        0,\n        `${anAsync.__reatom.name}.retriesAtom`,\n      ))\n\n      if (onReject) {\n        anAsync.onCall((ctx, payload) => {\n          __thenReatomed(\n            ctx,\n            payload,\n            () => retriesAtom(ctx, 0),\n            (error) => {\n              if (isAbort(error)) return\n              const timeout = onReject(ctx, error, ctx.get(retriesAtom)) ?? -1\n\n              if (timeout < 0) return\n\n              anAsync.retry!(unstable_dropController(ctx), timeout).catch(noop)\n            },\n          )\n        })\n      }\n    }\n\n    return anAsync as T & {\n      paramsAtom: Atom<undefined | ActionParams<T>>\n      retry: Action<[], ActionPayload<T>>\n      retriesAtom: Atom<number>\n    }\n  }\n\n/** @deprecated use `withRetry` instead */\nexport const withRetryAction = withRetry\n\nexport interface MappedAsyncAction<\n  Params extends any[] = unknown[],\n  Payload = unknown,\n> extends AsyncAction<Params, Payload> {\n  /**\n   * Function that unsubscribes from source atom\n   * @experimental\n   */\n  unstable_unhook: Unsubscribe\n}\n\n/**\n * Transform atom state into reatomAsync arguments\n */\nexport function mapToAsync<T extends Atom, Res>(\n  effect: Fn<[AsyncCtx, AtomState<T>], Promise<Res>>,\n  options: AsyncOptions<[AtomState<T>], Res> = {},\n): Fn<[T], MappedAsyncAction<[AtomState<T>], Res>> {\n  return (sourceAtom: Atom) => {\n    const asyncAction = reatomAsync(effect, {\n      ...options,\n      name: options.name ?? `${sourceAtom.__reatom.name}.mapToAsync`,\n    }) as MappedAsyncAction<[AtomState<T>], Res>\n    asyncAction.unstable_unhook = sourceAtom.onChange(asyncAction)\n\n    return asyncAction\n  }\n}\n"],"names":["handleEffect","anAsync","params","_temp","shouldPending","shouldFulfill","shouldReject","effect","__reatom","unstable_fn","pendingAtom","ctx","s","origin","schedule","Promise","res","rej","throwIfAborted","controller","then","signal","addEventListener","e","toAbortError","reason","assign","__thenReatomed","v","onFulfill","isAbort","onReject","NOOP_TIMEOUT_ID","memo","reducer","state","newState","isShallowEqual","isAbortError","getCache","anAtom","get","patch","read","unstable_dropController","AbortController","cause","reatomAsync","options","name","__count","onEffect","onEffectHook","onFulfillHook","onRejectHook","onSettle","onSettleHook","atom","Object","slice","call","arguments","actualize","onCtxAbort","error","abort","payload","_handleCache","length","action","onCall","promise","from","withRetry","_temp3","fallbackParams","paramsAtom","retry","after","throwReatomError","asyncSnapshot","retriesAtom","_temp5","resolve","_temp4","sleep","reject","timeout","catch","noop","withRetryAction","sourceAtom","asyncAction","unstable_unhook","onChange","_temp2","strategy","abortControllerAtom","spy","_ref","settled","handleAbort","onAbort","removeAbortHandler","removeEventListener","ignoreAbort","paramsLength","staleTime","swr","swrOptions","withPersist","paramsToKey","isEqual","a","b","isDeepEqual","cacheAtom","Infinity","Math","min","MAX_SAFE_TIMEOUT","find","key","cached","undefined","findLatestWithValue","values","version","latestCached","lastUpdate","deleteOldest","cache","oldestCached","oldestKey","delete","planCleanup","time","clearTimeoutId","setTimeout","unref","clearTimeout","reatomMap","Map","invalidate","latest","clear","pipe","fromSnapshot","snapshot","size","every","value","rec","Date","now","set","toSnapshot","filter","_ref2","handlePromise","isSame","_catch","paramsKey","initState","dataAtom","onConnect","subscribe","withDataAtom","map","reset","parseError","Error","String","resetTrigger","errorAtom","errorAtomName","withStatusesAtom","statusesAtom","isPending","isFulfilled","isRejected","isSettled","isFirstPending","isEverPending","isEverSettled","statuses"],"mappings":"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"}