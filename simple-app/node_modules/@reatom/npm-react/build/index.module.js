import React from"react";import{useSyncExternalStore}from"use-sync-external-store/shim";import{throwReatomError,isAtom,isAction,createCtx,atom,action}from"@reatom/core";import{bind}from"@reatom/lens";let getName=type=>{let name=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED?.ReactCurrentOwner?.current?.type?.name;return name&&name.concat(".",type)||`_${type}`},batch=cb=>cb();const setupBatch=newBatch=>{batch=newBatch},withBatching=ctx=>{let queue=[];return{...ctx,subscribe:(anAtom,cb)=>ctx.subscribe(anAtom,cb&&(value=>Promise.resolve(queue.push(()=>cb(value))).then(length=>length===queue.length&&batch(()=>queue.splice(0).forEach(cb=>cb())))))}},reatomContext=React.createContext(null),useCtx=()=>{let ctx=React.useContext(reatomContext);return throwReatomError(!ctx,"ctx is not set, you probably forgot to specify the ctx provider"),ctx};let bindBind=(ctx,fn)=>bind(ctx,fn);const useCtxBind=()=>bind(useCtx(),bindBind),useRefSetup=(deps,setup)=>{let ref=React.useRef();return(void 0===ref.current||ref.current.deps.length!==deps.length||ref.current.deps.some((v,i)=>!Object.is(v,deps[i])))&&(ref.current=setup()),ref},useAtom=function(anAtom,userDeps,options){void 0===userDeps&&(userDeps=[]),void 0===options&&(options={});let{name:name,subscribe:subscribe=!0}="boolean"==typeof options?{subscribe:options}:options,ctx=useCtx(),deps=[ctx];isAtom(anAtom)&&deps.push(anAtom);let{theAtom:theAtom,depsAtom:depsAtom,update:update,sub:sub,get:get}=useRefSetup(deps,()=>{let atomName=getName(name??"useAtom#"+typeof anAtom),depsAtom=atom([],`${atomName}._depsAtom`),theAtom=anAtom;isAtom(theAtom)||(theAtom=atom("function"==typeof anAtom?(ctx,state)=>(ctx.spy(depsAtom),anAtom(ctx,state)):anAtom,atomName));let update="function"==typeof theAtom?function(){return batch(()=>theAtom(ctx,...[].slice.call(arguments)))}:void 0;return{theAtom:theAtom,depsAtom:depsAtom,update:update,deps:deps,sub:cb=>ctx.subscribe(theAtom,cb),get:()=>ctx.get(theAtom),subscribe:subscribe}}).current;return ctx.get(()=>{if(!isAtom(anAtom)){const prevDeps=ctx.get(depsAtom);(userDeps.length!==prevDeps.length||userDeps.some((dep,i)=>!Object.is(dep,prevDeps[i])))&&("function"==typeof anAtom?depsAtom(ctx,userDeps):update(ctx,anAtom))}return[subscribe?useSyncExternalStore(sub,get,get):get(),update,theAtom,ctx]})},useAtomCreator=function(creator,deps,options){void 0===deps&&(deps=[]);const ref=useRefSetup(deps,()=>({deps:deps,theAtom:creator()}));return useAtom(ref.current.theAtom,[],options)},useUpdate=(cb,deps)=>{const ctx=useCtx();return React.useEffect(()=>{const call=ctx=>{cb(ctx,...deps.map(thing=>isAtom(thing)?ctx.get(thing):thing))};return call(ctx),deps.forEach((thing,i)=>isAtom(thing)&&(thing.__reatom.updateHooks??=new Set).add(call)),()=>deps.forEach((thing,i)=>isAtom(thing)&&thing.__reatom.updateHooks.delete(call))},deps.concat(ctx)),null},useAction=function(fn,deps,name){void 0===deps&&(deps=[]),deps??=[];let ctx=useCtx();deps.push(ctx),isAction(fn)&&deps.push(fn);let ref=useRefSetup(deps,()=>{let theAction=isAction(fn)?fn:action(function(){return ref.current.fn(...[].slice.call(arguments))},name??getName("useAction"));return{fn:fn,deps:deps,cb:function(){return batch(()=>theAction(ctx,...[].slice.call(arguments)))}}});return React.useLayoutEffect(()=>{ref.current.fn=fn}),ref.current.cb},useCreateCtx=extension=>{const ctxRef=React.useRef(null);return ctxRef.current||(ctxRef.current=createCtx(),extension?.(ctxRef.current)),ctxRef.current};export{reatomContext,setupBatch,useAction,useAtom,useAtomCreator,useCreateCtx,useCtx,useCtxBind,useUpdate,withBatching};
//# sourceMappingURL=index.module.js.map
