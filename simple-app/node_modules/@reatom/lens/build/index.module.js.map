{"version":3,"file":"index.module.js","sources":["../src/utils.ts","../src/bind.ts","../src/delay.ts","../src/effect.ts","../src/filter.ts","../src/onLensUpdate.ts","../src/parseAtoms.ts","../src/sample.ts","../src/withReset.ts","../src/index.ts"],"sourcesContent":["import { Atom } from '@reatom/core'\n\nexport const mapName = ({ __reatom: proto }: Atom, operator: string, name?: string) =>\n  name ?? `${proto.name}.${operator}`\n","import { Ctx, CtxParams, Fn } from '@reatom/core'\n\nexport type Binded<T extends Fn> = Fn<CtxParams<T>, ReturnType<T>>\n// & {\n//   [K in keyof T]: T[K]\n// }\n\nconst ctxMap = new WeakMap<Ctx, WeakMap<Fn, Binded<Fn>>>()\nexport const bind = <T extends Fn>(ctx: Ctx, fn: T): Binded<T> => {\n  let fnMap = ctxMap.get(ctx)\n  if (!fnMap) ctxMap.set(ctx, (fnMap = new WeakMap()))\n\n  let bfn = fnMap.get(fn)\n  if (!bfn) fnMap.set(fn, (bfn = fn.bind(null, ctx)))\n\n  return bfn as Binded<T>\n}\n","import {\n  Action,\n  atom,\n  Atom,\n  AtomCache,\n  AtomState,\n  Ctx,\n  Fn,\n  isAtom,\n  throwReatomError,\n} from '@reatom/core'\nimport { onCtxAbort } from '@reatom/effects'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\nexport interface DelayOptions {\n  /** The minimum amount of the delay (debounce-like)\n   * @default `max`\n   */\n  min?: number | Atom<number>\n  /** The maximum amount of the delay (throttle-like)\n   * @default `min`\n   */\n  max?: number | Atom<number>\n  /** Should the first update be captured (throttle-like)?\n   * @default true\n   */\n  leading?: boolean\n  /** Should the last update be captured (debounce-like)?\n   * @default true\n   */\n  trailing?: boolean\n  /** Should subscribe to an AbortController from the cause?\n   * @default true\n   */\n  abortable?: boolean\n}\n\n/** Flexible updates delayer */\nexport const delay: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(options: DelayOptions, name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} = (options, name) => (anAtom: Atom) => {\n  // listeners is a unique object for each atom instance\n  const running = new WeakMap<AtomCache['listeners'], number>()\n  let {\n    min: minOption,\n    max: maxOption,\n    leading = true,\n    trailing = true,\n    abortable = true,\n  } = options\n\n  throwReatomError(\n    minOption === undefined && maxOption === undefined,\n    'wrong options',\n  )\n\n  minOption ??= maxOption\n  maxOption ??= Number.MAX_SAFE_INTEGER\n\n  name = mapName(anAtom, 'delay', name)\n\n  const minAtom = isAtom(minOption)\n    ? minOption\n    : atom(minOption, `${name}._minAtom`)\n  const maxAtom = isAtom(maxOption)\n    ? maxOption\n    : atom(maxOption, `${name}._maxAtom`)\n\n  // @ts-expect-error\n  const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n    const min = ctx.get(minAtom)\n    const max = ctx.get(maxAtom)\n    const startsKey = ctx.cause.listeners\n    const depState = ctx.spy(anAtom)\n    let state = ctx.cause.pubs.length\n      ? prevState\n      : proto.isAction\n      ? []\n      : depState\n\n    if (!ctx.cause.pubs.length) {\n      state = proto.isAction ? [] : depState\n    } else {\n      const now = Date.now()\n      const isRunning = running.has(startsKey)\n      const start = running.get(startsKey) ?? now\n      const skip = isRunning || !leading\n\n      state = skip ? prevState : proto.isAction ? [depState[0]] : depState\n\n      const delay = Math.max(0, Math.min(min!, max! - (now - start)))\n\n      running.set(startsKey, start!)\n      ctx.schedule(() => running.delete(startsKey), -1)\n\n      const timeoutId = setTimeout(\n        () =>\n          ctx.get((read, acualize) => {\n            if (read(proto) === ctx.cause) {\n              running.delete(startsKey)\n              if (trailing && skip) {\n                acualize!(ctx, proto, (patchCtx: Ctx, patch: AtomCache) => {\n                  patch.state = proto.isAction ? [depState.at(-1)] : depState\n                })\n              }\n            }\n          }),\n        delay,\n      )\n      timeoutId.unref?.()\n      ctx.schedule(() => clearTimeout(timeoutId), -1)\n      if (abortable) onCtxAbort(ctx, () => clearTimeout(timeoutId))\n    }\n\n    return state\n  }, name)\n  const proto = theAtom.__reatom\n  proto.isAction = anAtom.__reatom.isAction\n  theAtom.deps = [anAtom]\n\n  return theAtom as any\n}\n\n/** Delay updates by timeout */\nexport const debounce: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(wait: DelayOptions['min'], name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  (min = 1, name) =>\n  (anAtom) =>\n    // @ts-expect-error\n    delay(\n      { min, leading: false, trailing: true },\n      mapName(anAtom, 'debounce', name),\n    )(anAtom)\n\n/** Skip updates by interval */\nexport const throttle: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(wait: DelayOptions['max'], name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  (max = 1, name) =>\n  (anAtom) =>\n    // @ts-expect-error\n    delay(\n      { max, leading: true, trailing: false },\n      mapName(anAtom, 'throttle', name),\n    )(anAtom)\n","import {\n  Action,\n  atom,\n  Atom,\n  AtomCache,\n  AtomState,\n  Ctx,\n  Fn,\n  Unsubscribe,\n} from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\nimport { mapName } from './utils'\nimport { type LensAction } from './'\nimport { onUpdate } from '@reatom/hooks'\nimport { noop } from '@reatom/utils'\n\nexport interface LensEffect<Params extends any[] = any[], Payload = any>\n  extends LensAction<Params, Payload> {\n  unstable_unhook: Unsubscribe\n}\n\n/** Create action which will invoked with the result of effect */\n// @ts-expect-error\nexport const effect: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom, Res>(\n    fn: T extends Action<infer Params, infer Payload>\n      ? Fn<[Ctx, Awaited<Payload>, Params], Res>\n      : Fn<[Ctx, AtomState<T>], Res>,\n    name?: string,\n  ): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensEffect<\n          [\n            {\n              params: [{ params: Params; payload: Awaited<Payload> }]\n              payload: Awaited<Res>\n            },\n          ],\n          Awaited<Res>\n        >\n      : LensEffect<\n          [{ params: [AtomState<T>]; payload: AtomState<T> }],\n          Awaited<Res>\n        >\n  >\n} = (fn: Fn, name?: string) => (anAtom: Atom) => {\n  const { isAction } = anAtom.__reatom\n  // TODO better error handling\n  // @ts-expect-error\n  const theAtom: LensEffect = atom((ctx, state = []) => {\n    const resolve = (params: any[], payload: any) =>\n      ctx.get((read, acualize) => {\n        if (payload instanceof Promise) {\n          payload.then((payload) => resolve(params, payload))\n        } else {\n          acualize!(ctx, ctx.cause.proto, (patchCtx: Ctx, patch: AtomCache) => {\n            patch.state = [{ params, payload }]\n          })\n        }\n      })\n\n    ctx.spy(anAtom, (value) => {\n      if (isAction && value.payload instanceof Promise) {\n        __thenReatomed(ctx, value.payload, (payload) =>\n          ctx.schedule(() =>\n            resolve(\n              [{ params: value.params, payload }],\n              fn(ctx, payload, value.params),\n            ),\n          ),\n        )\n      } else {\n        ctx.schedule(() =>\n          resolve(\n            [value],\n            isAction ? fn(ctx, value.payload, value.params) : fn(ctx, value),\n          ),\n        )\n      }\n    })\n\n    return state ?? []\n  }, mapName(anAtom, 'effect', name))\n  theAtom.__reatom.isAction = true\n  theAtom.deps = [anAtom]\n  theAtom.unstable_unhook = onUpdate(theAtom, noop)\n\n  return theAtom\n}\n","import { Action, atom, Atom, AtomState, Ctx, CtxSpy, Fn } from '@reatom/core'\nimport { isShallowEqual } from '@reatom/utils'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\n/** Filter updates by comparator function (\"shallow equal\" for atoms by default) */\nexport const filter: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(\n    predicate?: T extends Action<infer Params, infer Payload>\n      ? Fn<[Ctx, Payload, Params], boolean>\n      : Fn<[CtxSpy, AtomState<T>, AtomState<T>], boolean>,\n    name?: string,\n  ): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : T extends Atom<infer State>\n      ? LensAtom<State>\n      : never\n  >\n} =\n  (predicate?: Fn, name?: string) =>\n  (anAtom: Atom): any => {\n    name = mapName(anAtom, 'filter', name)\n    const { isAction } = anAtom.__reatom\n\n    predicate ??= isAction ? () => true : (ctx, a, b) => !isShallowEqual(a, b)\n\n    // @ts-expect-error\n    const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n      const isInit = ctx.cause.pubs.length === 0\n      const state = ctx.spy(anAtom)\n\n      return isAction\n        ? state.reduce(\n            (acc: any, call: any) =>\n              predicate!(ctx, call.payload, call.params) ? [call] : acc,\n            prevState ?? [],\n          )\n        : isInit || predicate!(ctx, state, prevState)\n        ? state\n        : prevState\n    })\n    theAtom.deps = [anAtom]\n    theAtom.__reatom.isAction = isAction\n\n    return theAtom\n  }\n","import { Atom } from '@reatom/core'\nimport { onUpdate } from '@reatom/hooks'\nimport { assign } from '@reatom/utils'\nimport { type LensAtom } from './'\n\n/** @deprecated use regular `onUpdate` instead */\nexport const onLensUpdate: typeof onUpdate = onUpdate\n\nexport const toLens =\n  <T extends Atom>(deps: Array<Atom>) =>\n  (\n    anAtom: T,\n  ): T & {\n    deps: Array<Atom>\n  } =>\n    assign(anAtom, {\n      deps: ((anAtom as Atom as LensAtom).deps ?? []).concat(deps),\n    })\n","import { Atom, Ctx, isAtom, Rec } from '@reatom/core'\n\nexport type ParseAtoms<T> = T extends Atom<infer T>\n  ? ParseAtoms<T>\n  : T extends Map<infer K, infer T>\n  ? Map<K, ParseAtoms<T>>\n  : T extends Set<infer T>\n  ? Set<ParseAtoms<T>>\n  : T extends Rec\n  ? {\n      [K in keyof T]: ParseAtoms<T[K]>\n    }\n  : T\n\nexport const parseAtoms = <Value>(\n  ctx: Ctx,\n  value: Value,\n): ParseAtoms<Value> => {\n  const state = isAtom(value)\n    ? ctx.spy\n      ? ctx.spy(value)\n      : ctx.get(value)\n    : value\n\n  if (typeof state !== 'object' || state === null) return state\n\n  if (state instanceof Map) {\n    const map = new Map()\n    for (const [k, value] of state) map.set(k, parseAtoms(ctx, value))\n    return map as ParseAtoms<Value>\n  }\n\n  if (state instanceof Set) {\n    const set = new Set()\n    for (const value of state) set.add(parseAtoms(ctx, value))\n    return set as ParseAtoms<Value>\n  }\n\n  const res: Rec = Array.isArray(state) ? [] : {}\n\n  for (const k in state) res[k] = parseAtoms(ctx, state[k])\n\n  return res as ParseAtoms<Value>\n}\n","import { Action, atom, Atom, AtomState, Fn } from '@reatom/core'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\n/** Delay updates until other atom update / action call */\n// https://rxjs.dev/api/operators/sample\n// https://effector.dev/docs/api/effector/sample\n// @ts-expect-error\nexport const sample: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(signal: Atom, name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<[], Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  <T>(signal: Atom, name?: string) =>\n  // @ts-ignore\n  (anAtom) => {\n    name = mapName(anAtom, 'sample', name)\n    const { isAction } = anAtom.__reatom\n    const _cacheAtom = atom<unknown>(null, `${name}._cacheAtom`)\n\n    // @ts-expect-error\n    const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n      const patch = ctx.cause\n      const isInit = patch.pubs.length === 0\n\n      ctx.spy(anAtom, (v) => _cacheAtom(ctx, isAction ? [v] : v))\n\n      let changed = false\n      ctx.spy(signal, () => (changed = true))\n\n      if (changed && !(isInit && !signal.__reatom.isAction)) {\n        const state = ctx.get(_cacheAtom)\n        // drop action cache\n        _cacheAtom(ctx, ctx.get(anAtom))\n        return state\n      }\n\n      return isInit && !(signal.__reatom.isAction && changed)\n        ? isAction\n          ? []\n          : ctx.get(anAtom)\n        : changed\n        ? ctx.get(_cacheAtom)\n        : prevState\n    })\n    theAtom.__reatom.isAction = isAction\n    theAtom.deps = [anAtom, signal]\n\n    return theAtom\n  }\n","import { action, Action, Atom, AtomCache, AtomState, Ctx } from '@reatom/core'\n\nexport const withReset =\n  <T extends Atom>() =>\n  (anAtom: T): T & { reset: Action<[], AtomState<T>> } =>\n    Object.assign(anAtom, {\n      reset: action(\n        (ctx) =>\n          ctx.get(\n            (read, actualize) =>\n              actualize!(\n                ctx,\n                anAtom.__reatom,\n                (patchCtx: Ctx, patch: AtomCache) =>\n                  (patch.state = patch.proto.initState(ctx)),\n              ).state,\n          ),\n        `${anAtom.__reatom.name}._reset`,\n      ),\n    })\n","import {\n  action,\n  Action,\n  ActionPayload,\n  atom,\n  Atom,\n  AtomCache,\n  AtomMut,\n  AtomState,\n  Ctx,\n  CtxParams,\n  CtxSpy,\n  Fn,\n  Rec,\n  throwReatomError,\n} from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\nimport { onUpdate } from '@reatom/hooks'\nimport { Plain } from '@reatom/utils'\nimport { mapName } from './utils'\n\nexport * from './bind'\nexport * from './delay'\nexport * from './effect'\nexport * from './filter'\nexport * from './onLensUpdate'\nexport * from './parseAtoms'\nexport * from './sample'\nexport * from './withReset'\n\nexport interface LensAtom<State = any> extends Atom<State> {\n  deps: Array<Atom>\n}\nexport interface LensAction<Params extends any[] = any[], Payload = any>\n  extends Action<Params, Payload> {\n  deps: Array<Atom>\n}\n\ntype Combined<Shape extends Rec<Atom>> = Plain<{\n  [K in keyof Shape]: AtomState<Shape[K]>\n}>\n\nexport const combine = <Shape extends Rec<Atom>>(\n  shape: Shape,\n): LensAtom<Combined<Shape>> => {\n  // @ts-expect-error\n  const theAtom: LensAtom = atom((ctx) => {\n    const newState = {} as Combined<Shape>\n    for (const key in shape) newState[key] = ctx.spy(shape[key]!)\n    return newState\n  }, '_combine')\n  theAtom.deps = Object.values(shape)\n\n  return theAtom\n}\n\n/**\n * Skip mark to stop reactive propagation and use previous state\n * (`never` helps to infer correct type)\n * @internal\n * @deprecated\n */\nexport const SKIP: never = 'REATOM_SKIP_MARK' as any as never\n\n/** Remove callable signature to prevent the atom update from outside */\nexport const readonly = <T extends Atom & { deps?: Array<Atom> }>({\n  __reatom,\n  pipe,\n  onChange,\n  // @ts-expect-error the atom could be an action\n  onCall,\n  deps,\n}: T): LensAtom<AtomState<T>> =>\n  Object.assign(\n    {\n      __reatom,\n      pipe,\n      onChange,\n    },\n    deps ? { deps } : {},\n    onCall ? { onCall } : {},\n  ) as LensAtom<AtomState<T>>\n\n/** Remove all extra properties from the atom to pick the essence */\nexport const plain = <T extends Atom>(\n  anAtom: T,\n): T extends Action<infer Params, infer Payload>\n  ? Action<Params, Payload>\n  : T extends AtomMut<infer State>\n  ? AtomMut<State>\n  : Atom<AtomState<T>> => {\n  const theAtom =\n    typeof anAtom === 'function'\n      ? // @ts-expect-error\n        anAtom.bind()\n      : {}\n  theAtom.__reatom = anAtom.__reatom\n  theAtom.pipe = anAtom.pipe\n  theAtom.pipe = anAtom.pipe\n  theAtom.onChange = anAtom.onChange\n  if ('onCall' in anAtom) theAtom.onCall = anAtom.onCall\n\n  return theAtom\n}\n\n/** Transform atom state */\nexport const mapState =\n  <T extends Atom, Res>(\n    mapper: Fn<[CtxSpy, AtomState<T>, undefined | AtomState<T>, unknown], Res>,\n    name?: string,\n  ): Fn<[T], LensAtom<Res>> =>\n  (anAtom: Atom) => {\n    const theAtom = atom(\n      (ctx, state?: any) =>\n        mapper(ctx, ctx.spy(anAtom), ctx.cause!.pubs.at(0)?.state, state),\n      mapName(anAtom, 'mapState', name),\n    ) as LensAtom<Res>\n    theAtom.deps = [anAtom]\n\n    return theAtom\n  }\n\n/** Transform action payload */\nexport const mapPayload: {\n  <Payload, T, Params extends any[] = any[]>(\n    map: Fn<[Ctx, Payload, Params], T>,\n    name?: string,\n  ): Fn<[Action<Params, Payload>], LensAction<[], T>>\n  <T extends Action>(fallback: ActionPayload<T>, name?: string): Fn<\n    [T],\n    LensAtom<ActionPayload<T>>\n  >\n  <T, State>(fallback: State, name?: string): Fn<\n    [Action<any[], T>],\n    LensAtom<State | T>\n  >\n  <Payload, State, Params extends any[] = any[]>(\n    fallback: State,\n    map: Fn<[Ctx, Payload, Params, State], State>,\n    name?: string,\n  ): Fn<[Action<Params, Payload>], LensAtom<State>>\n} =\n  (fallbackOrMapper: any, mapOrName?: any, name?: string) =>\n  (anAction: Action): any => {\n    throwReatomError(!anAction.__reatom.isAction, 'action expected')\n\n    const isAction = typeof fallbackOrMapper === 'function'\n    // isAtom\n    let fallback = fallbackOrMapper\n    // isAtom\n    let map = mapOrName ?? ((ctx: Ctx, v: any) => v)\n    if (isAction) {\n      fallback = []\n      map = fallbackOrMapper\n      name = mapOrName\n    }\n\n    const theAtom = Object.assign(\n      () => throwReatomError(1, 'derived action call'),\n      anAction.pipe(\n        mapState((ctx, depState, prevDepState, prevState = fallback) => {\n          return isAction\n            ? // @ts-expect-error\n              ((ctx.spy = undefined),\n              depState.reduce((acc: any, v) => {\n                const payload = map(ctx, v.payload, v.params)\n                return payload === SKIP\n                  ? acc\n                  : [...acc, { params: [v], payload }]\n              }, prevState))\n            : depState.reduce((acc, { payload, params }) => {\n                const state = map(ctx, payload, params, acc)\n                return state === SKIP ? acc : state\n              }, prevState)\n        }, name || (anAction.__reatom.name && 'mapPayload')),\n      ),\n    )\n    theAtom.__reatom.isAction = isAction\n\n    return theAtom\n  }\n\n/** Transform async action payload */\nexport const mapPayloadAwaited: {\n  <T, Payload = Awaited<T>>(\n    mapper?: Fn<[Ctx, Awaited<T>], Payload>,\n    name?: string,\n  ): Fn<[Action<any[], T>], LensAction<[], Payload>>\n  <T extends Action>(fallback: Awaited<ActionPayload<T>>, name?: string): Fn<\n    [T],\n    LensAtom<Awaited<ActionPayload<T>>>\n  >\n  <T, State>(fallback: State, name?: string): Fn<\n    [Action<any[], T>],\n    LensAtom<State | Awaited<T>>\n  >\n  <T, State>(\n    fallback: State,\n    map: Fn<[Ctx, Awaited<T>], State>,\n    name?: string,\n  ): Fn<[Action<any[], T>], LensAtom<State>>\n} =\n  (...a: [any?, any?, any?]) =>\n  (anAction: Action): any => {\n    const isAction = a.length === 0 || typeof a[0] === 'function'\n    const [fallback, map = (ctx: Ctx, v: any) => v, name] = isAction\n      ? [[], a[0], a[1]]\n      : a\n    const params = isAction ? [] : [fallback]\n    params.push((ctx: Ctx, promise: any) => {\n      if (promise instanceof Promise) {\n        __thenReatomed(ctx, promise, (v, read, actualize) =>\n          actualize!(\n            ctx,\n            ctx.cause!.proto,\n            (patchCtx: Ctx, patch: AtomCache) => {\n              patch.cause = ctx.cause.cause\n              const payload = map(ctx, v)\n              patch.state = isAction\n                ? [...patch.state, { params: [v], payload }]\n                : payload\n            },\n          ),\n        )\n\n        return SKIP\n      } else {\n        return map(ctx, promise)\n      }\n    }, name || (anAction.__reatom.name && 'mapPayloadAwaited'))\n\n    // @ts-expect-error reatomAsync\n    return (anAction.onFulfill ?? anAction).pipe(\n      mapPayload(\n        // @ts-ignore\n        ...params,\n      ),\n    )\n  }\n\n/** Transform atom update */\nexport const mapInput =\n  <T extends AtomMut | Action<[any]>, Args extends [Ctx, ...any[]]>(\n    mapper: Fn<Args, Parameters<T>[1]>,\n    name?: string,\n  ): Fn<[T], Action<CtxParams<Args>, AtomState<T>>> =>\n  (anAtom): any =>\n    action(\n      (ctx, ...args) =>\n        anAtom(\n          ctx,\n          // @ts-ignore\n          mapper(ctx, ...args),\n        ),\n      mapName(anAtom, 'mapInput', name),\n    )\n\n/** Convert action to atom with optional fallback state */\n// @ts-expect-error\nexport const toAtom: {\n  <T extends Action>(fallback: ReturnType<T>, name?: string): Fn<\n    [T],\n    LensAtom<ReturnType<T>>\n  >\n  <T extends Action>(fallback?: undefined, name?: string): Fn<\n    [T],\n    LensAtom<undefined | ReturnType<T>>\n  >\n  <T extends Action, State>(fallback: State, name?: string): Fn<\n    [T],\n    LensAtom<State | ReturnType<T>>\n  >\n} =\n  (fallback?: any, name?: string): Fn<[Action], Atom> =>\n  (anAction) =>\n    mapPayload(\n      fallback,\n      (ctx, v: any) => v,\n      mapName(anAction, 'toAtom', name),\n    )(anAction)\n\n// https://rxjs.dev/api/operators/tap\nexport const withOnUpdate =\n  <T extends Atom>(\n    cb: T extends Action<infer Params, infer Payload>\n      ? Fn<\n          [\n            Ctx,\n            Payload,\n            AtomCache<AtomState<Action<Params, Payload>>> & { params: Params },\n          ]\n        >\n      : Fn<[Ctx, AtomState<T>, AtomCache<AtomState<T>>]>,\n  ) =>\n  (anAtom: T): T => {\n    onUpdate(anAtom, cb)\n    return anAtom\n  }\n\n/** Convert an atom to action */\nexport const toAction: {\n  <State, T>(map: Fn<[ctx: Ctx, state: State], T>, name?: string): Fn<\n    [Atom<State>],\n    LensAction<[State], T>\n  >\n  <T>(name?: string): Fn<[Atom<T>], LensAction<[T], T>>\n} = (map?: string | Fn, name?: string) => (anAtom: Atom) => {\n  throwReatomError(anAtom.__reatom.isAction, 'atom expected')\n\n  if (typeof map === 'string') {\n    name = map\n    map = undefined\n  }\n  map ??= (ctx: Ctx, v: any) => v\n\n  // @ts-expect-error\n  const theAction: LensAction<[T], T> = atom((ctx) => {\n    // TODO handle atom mutation in the same transaction\n    const isInit = ctx.cause.pubs.length === 0\n    const state = ctx.spy(anAtom)\n    return isInit ? [] : [{ params: [state], payload: (map as Fn)(ctx, state) }]\n  }, mapName(anAtom, 'toAction', name))\n  theAction.__reatom.isAction = true\n  theAction.deps = [anAtom]\n\n  return theAction\n}\n"],"names":["mapName","_ref","operator","name","__reatom","proto","ctxMap","WeakMap","bind","ctx","fn","fnMap","get","set","bfn","delay","options","anAtom","running","min","minOption","max","maxOption","leading","trailing","abortable","throwReatomError","undefined","Number","MAX_SAFE_INTEGER","minAtom","isAtom","atom","maxAtom","theAtom","prevState","startsKey","cause","listeners","depState","spy","state","pubs","length","isAction","now","Date","isRunning","has","start","skip","Math","schedule","delete","timeoutId","setTimeout","read","acualize","patchCtx","patch","at","unref","clearTimeout","onCtxAbort","deps","debounce","throttle","effect","resolve","params","payload","Promise","then","value","__thenReatomed","unstable_unhook","onUpdate","noop","filter","predicate","a","b","isShallowEqual","isInit","reduce","acc","call","onLensUpdate","toLens","assign","concat","parseAtoms","Map","map","k","Set","add","res","Array","isArray","sample","signal","_cacheAtom","v","changed","withReset","Object","reset","action","actualize","initState","combine","shape","newState","key","values","SKIP","readonly","pipe","onChange","onCall","plain","mapState","mapper","mapPayload","fallbackOrMapper","mapOrName","anAction","fallback","prevDepState","_ref2","mapPayloadAwaited","slice","arguments","push","promise","onFulfill","mapInput","toAtom","withOnUpdate","cb","toAction","theAction"],"mappings":"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"}