import{throwReatomError,isAtom,atom,action}from"@reatom/core";import{onCtxAbort,__thenReatomed}from"@reatom/effects";import{onUpdate}from"@reatom/hooks";import{noop,isShallowEqual,assign}from"@reatom/utils";const mapName=(_ref,operator,name)=>{let{__reatom:proto}=_ref;return name??`${proto.name}.${operator}`},ctxMap=new WeakMap,bind=(ctx,fn)=>{let fnMap=ctxMap.get(ctx);fnMap||ctxMap.set(ctx,fnMap=new WeakMap);let bfn=fnMap.get(fn);return bfn||fnMap.set(fn,bfn=fn.bind(null,ctx)),bfn},delay=(options,name)=>anAtom=>{const running=new WeakMap;let{min:minOption,max:maxOption,leading:leading=!0,trailing:trailing=!0,abortable:abortable=!0}=options;throwReatomError(void 0===minOption&&void 0===maxOption,"wrong options"),minOption??=maxOption,maxOption??=Number.MAX_SAFE_INTEGER,name=mapName(anAtom,"delay",name);const minAtom=isAtom(minOption)?minOption:atom(minOption,`${name}._minAtom`),maxAtom=isAtom(maxOption)?maxOption:atom(maxOption,`${name}._maxAtom`),theAtom=atom((ctx,prevState)=>{const min=ctx.get(minAtom),max=ctx.get(maxAtom),startsKey=ctx.cause.listeners,depState=ctx.spy(anAtom);let state=ctx.cause.pubs.length?prevState:proto.isAction?[]:depState;if(ctx.cause.pubs.length){const now=Date.now(),isRunning=running.has(startsKey),start=running.get(startsKey)??now,skip=isRunning||!leading;state=skip?prevState:proto.isAction?[depState[0]]:depState;const delay=Math.max(0,Math.min(min,max-(now-start)));running.set(startsKey,start),ctx.schedule(()=>running.delete(startsKey),-1);const timeoutId=setTimeout(()=>ctx.get((read,acualize)=>{read(proto)===ctx.cause&&(running.delete(startsKey),trailing&&skip&&acualize(ctx,proto,(patchCtx,patch)=>{patch.state=proto.isAction?[depState.at(-1)]:depState}))}),delay);timeoutId.unref?.(),ctx.schedule(()=>clearTimeout(timeoutId),-1),abortable&&onCtxAbort(ctx,()=>clearTimeout(timeoutId))}else state=proto.isAction?[]:depState;return state},name),proto=theAtom.__reatom;return proto.isAction=anAtom.__reatom.isAction,theAtom.deps=[anAtom],theAtom},debounce=function(min,name){return void 0===min&&(min=1),anAtom=>delay({min:min,leading:!1,trailing:!0},mapName(anAtom,"debounce",name))(anAtom)},throttle=function(max,name){return void 0===max&&(max=1),anAtom=>delay({max:max,leading:!0,trailing:!1},mapName(anAtom,"throttle",name))(anAtom)},effect=(fn,name)=>anAtom=>{const{isAction:isAction}=anAtom.__reatom,theAtom=atom(function(ctx,state){void 0===state&&(state=[]);const resolve=(params,payload)=>ctx.get((read,acualize)=>{payload instanceof Promise?payload.then(payload=>resolve(params,payload)):acualize(ctx,ctx.cause.proto,(patchCtx,patch)=>{patch.state=[{params:params,payload:payload}]})});return ctx.spy(anAtom,value=>{isAction&&value.payload instanceof Promise?__thenReatomed(ctx,value.payload,payload=>ctx.schedule(()=>resolve([{params:value.params,payload:payload}],fn(ctx,payload,value.params)))):ctx.schedule(()=>resolve([value],isAction?fn(ctx,value.payload,value.params):fn(ctx,value)))}),state??[]},mapName(anAtom,"effect",name));return theAtom.__reatom.isAction=!0,theAtom.deps=[anAtom],theAtom.unstable_unhook=onUpdate(theAtom,noop),theAtom},filter=(predicate,name)=>anAtom=>{const{isAction:isAction}=anAtom.__reatom;predicate??=isAction?()=>!0:(ctx,a,b)=>!isShallowEqual(a,b);const theAtom=atom((ctx,prevState)=>{const isInit=0===ctx.cause.pubs.length,state=ctx.spy(anAtom);return isAction?state.reduce((acc,call)=>predicate(ctx,call.payload,call.params)?[call]:acc,prevState??[]):isInit||predicate(ctx,state,prevState)?state:prevState});return theAtom.deps=[anAtom],theAtom.__reatom.isAction=isAction,theAtom},onLensUpdate=onUpdate,toLens=deps=>anAtom=>assign(anAtom,{deps:(anAtom.deps??[]).concat(deps)}),parseAtoms=(ctx,value)=>{const state=isAtom(value)?ctx.spy?ctx.spy(value):ctx.get(value):value;if("object"!=typeof state||null===state)return state;if(state instanceof Map){const map=new Map;for(const[k,value]of state)map.set(k,parseAtoms(ctx,value));return map}if(state instanceof Set){const set=new Set;for(const value of state)set.add(parseAtoms(ctx,value));return set}const res=Array.isArray(state)?[]:{};for(const k in state)res[k]=parseAtoms(ctx,state[k]);return res},sample=(signal,name)=>anAtom=>{name=mapName(anAtom,"sample",name);const{isAction:isAction}=anAtom.__reatom,_cacheAtom=atom(null,`${name}._cacheAtom`),theAtom=atom((ctx,prevState)=>{const isInit=0===ctx.cause.pubs.length;ctx.spy(anAtom,v=>_cacheAtom(ctx,isAction?[v]:v));let changed=!1;if(ctx.spy(signal,()=>changed=!0),changed&&(!isInit||signal.__reatom.isAction)){const state=ctx.get(_cacheAtom);return _cacheAtom(ctx,ctx.get(anAtom)),state}return!isInit||signal.__reatom.isAction&&changed?changed?ctx.get(_cacheAtom):prevState:isAction?[]:ctx.get(anAtom)});return theAtom.__reatom.isAction=isAction,theAtom.deps=[anAtom,signal],theAtom},withReset=()=>anAtom=>Object.assign(anAtom,{reset:action(ctx=>ctx.get((read,actualize)=>actualize(ctx,anAtom.__reatom,(patchCtx,patch)=>patch.state=patch.proto.initState(ctx)).state),`${anAtom.__reatom.name}._reset`)}),combine=shape=>{const theAtom=atom(ctx=>{const newState={};for(const key in shape)newState[key]=ctx.spy(shape[key]);return newState},"_combine");return theAtom.deps=Object.values(shape),theAtom},SKIP="REATOM_SKIP_MARK",readonly=_ref=>{let{__reatom:__reatom,pipe:pipe,onChange:onChange,onCall:onCall,deps:deps}=_ref;return Object.assign({__reatom:__reatom,pipe:pipe,onChange:onChange},deps?{deps:deps}:{},onCall?{onCall:onCall}:{})},plain=anAtom=>{const theAtom="function"==typeof anAtom?anAtom.bind():{};return theAtom.__reatom=anAtom.__reatom,theAtom.pipe=anAtom.pipe,theAtom.pipe=anAtom.pipe,theAtom.onChange=anAtom.onChange,"onCall"in anAtom&&(theAtom.onCall=anAtom.onCall),theAtom},mapState=(mapper,name)=>anAtom=>{const theAtom=atom((ctx,state)=>mapper(ctx,ctx.spy(anAtom),ctx.cause.pubs.at(0)?.state,state),mapName(anAtom,"mapState",name));return theAtom.deps=[anAtom],theAtom},mapPayload=(fallbackOrMapper,mapOrName,name)=>anAction=>{throwReatomError(!anAction.__reatom.isAction,"action expected");const isAction="function"==typeof fallbackOrMapper;let fallback=fallbackOrMapper,map=mapOrName??((ctx,v)=>v);isAction&&(fallback=[],map=fallbackOrMapper,name=mapOrName);const theAtom=Object.assign(()=>throwReatomError(1,"derived action call"),anAction.pipe(mapState(function(ctx,depState,prevDepState,prevState){return void 0===prevState&&(prevState=fallback),isAction?(ctx.spy=void 0,depState.reduce((acc,v)=>{const payload=map(ctx,v.payload,v.params);return payload===SKIP?acc:[...acc,{params:[v],payload:payload}]},prevState)):depState.reduce((acc,_ref2)=>{let{payload:payload,params:params}=_ref2;const state=map(ctx,payload,params,acc);return state===SKIP?acc:state},prevState)},name||anAction.__reatom.name&&"mapPayload")));return theAtom.__reatom.isAction=isAction,theAtom},mapPayloadAwaited=function(){var a=[].slice.call(arguments);return anAction=>{const isAction=0===a.length||"function"==typeof a[0],[fallback,map=((ctx,v)=>v),name]=isAction?[[],a[0],a[1]]:a,params=isAction?[]:[fallback];return params.push((ctx,promise)=>promise instanceof Promise?(__thenReatomed(ctx,promise,(v,read,actualize)=>actualize(ctx,ctx.cause.proto,(patchCtx,patch)=>{patch.cause=ctx.cause.cause;const payload=map(ctx,v);patch.state=isAction?[...patch.state,{params:[v],payload:payload}]:payload})),SKIP):map(ctx,promise),name||anAction.__reatom.name&&"mapPayloadAwaited"),(anAction.onFulfill??anAction).pipe(mapPayload(...params))}},mapInput=(mapper,name)=>anAtom=>action(function(ctx){return anAtom(ctx,mapper(ctx,...[].slice.call(arguments,1)))},mapName(anAtom,"mapInput",name)),toAtom=(fallback,name)=>anAction=>mapPayload(fallback,(ctx,v)=>v,mapName(anAction,"toAtom",name))(anAction),withOnUpdate=cb=>anAtom=>(onUpdate(anAtom,cb),anAtom),toAction=(map,name)=>anAtom=>{throwReatomError(anAtom.__reatom.isAction,"atom expected"),"string"==typeof map&&(name=map,map=void 0),map??=(ctx,v)=>v;const theAction=atom(ctx=>{const isInit=0===ctx.cause.pubs.length,state=ctx.spy(anAtom);return isInit?[]:[{params:[state],payload:map(ctx,state)}]},mapName(anAtom,"toAction",name));return theAction.__reatom.isAction=!0,theAction.deps=[anAtom],theAction};export{SKIP,bind,combine,debounce,delay,effect,filter,mapInput,mapPayload,mapPayloadAwaited,mapState,onLensUpdate,parseAtoms,plain,readonly,sample,throttle,toAction,toAtom,toLens,withOnUpdate,withReset};
//# sourceMappingURL=index.module.js.map
