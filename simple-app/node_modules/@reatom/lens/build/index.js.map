{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/bind.ts","../src/delay.ts","../src/onLensUpdate.ts","../src/parseAtoms.ts","../src/index.ts","../src/effect.ts","../src/filter.ts","../src/sample.ts","../src/withReset.ts"],"sourcesContent":["import { Atom } from '@reatom/core'\n\nexport const mapName = ({ __reatom: proto }: Atom, operator: string, name?: string) =>\n  name ?? `${proto.name}.${operator}`\n","import { Ctx, CtxParams, Fn } from '@reatom/core'\n\nexport type Binded<T extends Fn> = Fn<CtxParams<T>, ReturnType<T>>\n// & {\n//   [K in keyof T]: T[K]\n// }\n\nconst ctxMap = new WeakMap<Ctx, WeakMap<Fn, Binded<Fn>>>()\nexport const bind = <T extends Fn>(ctx: Ctx, fn: T): Binded<T> => {\n  let fnMap = ctxMap.get(ctx)\n  if (!fnMap) ctxMap.set(ctx, (fnMap = new WeakMap()))\n\n  let bfn = fnMap.get(fn)\n  if (!bfn) fnMap.set(fn, (bfn = fn.bind(null, ctx)))\n\n  return bfn as Binded<T>\n}\n","import {\n  Action,\n  atom,\n  Atom,\n  AtomCache,\n  AtomState,\n  Ctx,\n  Fn,\n  isAtom,\n  throwReatomError,\n} from '@reatom/core'\nimport { onCtxAbort } from '@reatom/effects'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\nexport interface DelayOptions {\n  /** The minimum amount of the delay (debounce-like)\n   * @default `max`\n   */\n  min?: number | Atom<number>\n  /** The maximum amount of the delay (throttle-like)\n   * @default `min`\n   */\n  max?: number | Atom<number>\n  /** Should the first update be captured (throttle-like)?\n   * @default true\n   */\n  leading?: boolean\n  /** Should the last update be captured (debounce-like)?\n   * @default true\n   */\n  trailing?: boolean\n  /** Should subscribe to an AbortController from the cause?\n   * @default true\n   */\n  abortable?: boolean\n}\n\n/** Flexible updates delayer */\nexport const delay: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(options: DelayOptions, name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} = (options, name) => (anAtom: Atom) => {\n  // listeners is a unique object for each atom instance\n  const running = new WeakMap<AtomCache['listeners'], number>()\n  let {\n    min: minOption,\n    max: maxOption,\n    leading = true,\n    trailing = true,\n    abortable = true,\n  } = options\n\n  throwReatomError(\n    minOption === undefined && maxOption === undefined,\n    'wrong options',\n  )\n\n  minOption ??= maxOption\n  maxOption ??= Number.MAX_SAFE_INTEGER\n\n  name = mapName(anAtom, 'delay', name)\n\n  const minAtom = isAtom(minOption)\n    ? minOption\n    : atom(minOption, `${name}._minAtom`)\n  const maxAtom = isAtom(maxOption)\n    ? maxOption\n    : atom(maxOption, `${name}._maxAtom`)\n\n  // @ts-expect-error\n  const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n    const min = ctx.get(minAtom)\n    const max = ctx.get(maxAtom)\n    const startsKey = ctx.cause.listeners\n    const depState = ctx.spy(anAtom)\n    let state = ctx.cause.pubs.length\n      ? prevState\n      : proto.isAction\n      ? []\n      : depState\n\n    if (!ctx.cause.pubs.length) {\n      state = proto.isAction ? [] : depState\n    } else {\n      const now = Date.now()\n      const isRunning = running.has(startsKey)\n      const start = running.get(startsKey) ?? now\n      const skip = isRunning || !leading\n\n      state = skip ? prevState : proto.isAction ? [depState[0]] : depState\n\n      const delay = Math.max(0, Math.min(min!, max! - (now - start)))\n\n      running.set(startsKey, start!)\n      ctx.schedule(() => running.delete(startsKey), -1)\n\n      const timeoutId = setTimeout(\n        () =>\n          ctx.get((read, acualize) => {\n            if (read(proto) === ctx.cause) {\n              running.delete(startsKey)\n              if (trailing && skip) {\n                acualize!(ctx, proto, (patchCtx: Ctx, patch: AtomCache) => {\n                  patch.state = proto.isAction ? [depState.at(-1)] : depState\n                })\n              }\n            }\n          }),\n        delay,\n      )\n      timeoutId.unref?.()\n      ctx.schedule(() => clearTimeout(timeoutId), -1)\n      if (abortable) onCtxAbort(ctx, () => clearTimeout(timeoutId))\n    }\n\n    return state\n  }, name)\n  const proto = theAtom.__reatom\n  proto.isAction = anAtom.__reatom.isAction\n  theAtom.deps = [anAtom]\n\n  return theAtom as any\n}\n\n/** Delay updates by timeout */\nexport const debounce: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(wait: DelayOptions['min'], name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  (min = 1, name) =>\n  (anAtom) =>\n    // @ts-expect-error\n    delay(\n      { min, leading: false, trailing: true },\n      mapName(anAtom, 'debounce', name),\n    )(anAtom)\n\n/** Skip updates by interval */\nexport const throttle: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(wait: DelayOptions['max'], name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  (max = 1, name) =>\n  (anAtom) =>\n    // @ts-expect-error\n    delay(\n      { max, leading: true, trailing: false },\n      mapName(anAtom, 'throttle', name),\n    )(anAtom)\n","import { Atom } from '@reatom/core'\nimport { onUpdate } from '@reatom/hooks'\nimport { assign } from '@reatom/utils'\nimport { type LensAtom } from './'\n\n/** @deprecated use regular `onUpdate` instead */\nexport const onLensUpdate: typeof onUpdate = onUpdate\n\nexport const toLens =\n  <T extends Atom>(deps: Array<Atom>) =>\n  (\n    anAtom: T,\n  ): T & {\n    deps: Array<Atom>\n  } =>\n    assign(anAtom, {\n      deps: ((anAtom as Atom as LensAtom).deps ?? []).concat(deps),\n    })\n","import { Atom, Ctx, isAtom, Rec } from '@reatom/core'\n\nexport type ParseAtoms<T> = T extends Atom<infer T>\n  ? ParseAtoms<T>\n  : T extends Map<infer K, infer T>\n  ? Map<K, ParseAtoms<T>>\n  : T extends Set<infer T>\n  ? Set<ParseAtoms<T>>\n  : T extends Rec\n  ? {\n      [K in keyof T]: ParseAtoms<T[K]>\n    }\n  : T\n\nexport const parseAtoms = <Value>(\n  ctx: Ctx,\n  value: Value,\n): ParseAtoms<Value> => {\n  const state = isAtom(value)\n    ? ctx.spy\n      ? ctx.spy(value)\n      : ctx.get(value)\n    : value\n\n  if (typeof state !== 'object' || state === null) return state\n\n  if (state instanceof Map) {\n    const map = new Map()\n    for (const [k, value] of state) map.set(k, parseAtoms(ctx, value))\n    return map as ParseAtoms<Value>\n  }\n\n  if (state instanceof Set) {\n    const set = new Set()\n    for (const value of state) set.add(parseAtoms(ctx, value))\n    return set as ParseAtoms<Value>\n  }\n\n  const res: Rec = Array.isArray(state) ? [] : {}\n\n  for (const k in state) res[k] = parseAtoms(ctx, state[k])\n\n  return res as ParseAtoms<Value>\n}\n","import {\n  action,\n  Action,\n  ActionPayload,\n  atom,\n  Atom,\n  AtomCache,\n  AtomMut,\n  AtomState,\n  Ctx,\n  CtxParams,\n  CtxSpy,\n  Fn,\n  Rec,\n  throwReatomError,\n} from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\nimport { onUpdate } from '@reatom/hooks'\nimport { Plain } from '@reatom/utils'\nimport { mapName } from './utils'\n\nexport * from './bind'\nexport * from './delay'\nexport * from './effect'\nexport * from './filter'\nexport * from './onLensUpdate'\nexport * from './parseAtoms'\nexport * from './sample'\nexport * from './withReset'\n\nexport interface LensAtom<State = any> extends Atom<State> {\n  deps: Array<Atom>\n}\nexport interface LensAction<Params extends any[] = any[], Payload = any>\n  extends Action<Params, Payload> {\n  deps: Array<Atom>\n}\n\ntype Combined<Shape extends Rec<Atom>> = Plain<{\n  [K in keyof Shape]: AtomState<Shape[K]>\n}>\n\nexport const combine = <Shape extends Rec<Atom>>(\n  shape: Shape,\n): LensAtom<Combined<Shape>> => {\n  // @ts-expect-error\n  const theAtom: LensAtom = atom((ctx) => {\n    const newState = {} as Combined<Shape>\n    for (const key in shape) newState[key] = ctx.spy(shape[key]!)\n    return newState\n  }, '_combine')\n  theAtom.deps = Object.values(shape)\n\n  return theAtom\n}\n\n/**\n * Skip mark to stop reactive propagation and use previous state\n * (`never` helps to infer correct type)\n * @internal\n * @deprecated\n */\nexport const SKIP: never = 'REATOM_SKIP_MARK' as any as never\n\n/** Remove callable signature to prevent the atom update from outside */\nexport const readonly = <T extends Atom & { deps?: Array<Atom> }>({\n  __reatom,\n  pipe,\n  onChange,\n  // @ts-expect-error the atom could be an action\n  onCall,\n  deps,\n}: T): LensAtom<AtomState<T>> =>\n  Object.assign(\n    {\n      __reatom,\n      pipe,\n      onChange,\n    },\n    deps ? { deps } : {},\n    onCall ? { onCall } : {},\n  ) as LensAtom<AtomState<T>>\n\n/** Remove all extra properties from the atom to pick the essence */\nexport const plain = <T extends Atom>(\n  anAtom: T,\n): T extends Action<infer Params, infer Payload>\n  ? Action<Params, Payload>\n  : T extends AtomMut<infer State>\n  ? AtomMut<State>\n  : Atom<AtomState<T>> => {\n  const theAtom =\n    typeof anAtom === 'function'\n      ? // @ts-expect-error\n        anAtom.bind()\n      : {}\n  theAtom.__reatom = anAtom.__reatom\n  theAtom.pipe = anAtom.pipe\n  theAtom.pipe = anAtom.pipe\n  theAtom.onChange = anAtom.onChange\n  if ('onCall' in anAtom) theAtom.onCall = anAtom.onCall\n\n  return theAtom\n}\n\n/** Transform atom state */\nexport const mapState =\n  <T extends Atom, Res>(\n    mapper: Fn<[CtxSpy, AtomState<T>, undefined | AtomState<T>, unknown], Res>,\n    name?: string,\n  ): Fn<[T], LensAtom<Res>> =>\n  (anAtom: Atom) => {\n    const theAtom = atom(\n      (ctx, state?: any) =>\n        mapper(ctx, ctx.spy(anAtom), ctx.cause!.pubs.at(0)?.state, state),\n      mapName(anAtom, 'mapState', name),\n    ) as LensAtom<Res>\n    theAtom.deps = [anAtom]\n\n    return theAtom\n  }\n\n/** Transform action payload */\nexport const mapPayload: {\n  <Payload, T, Params extends any[] = any[]>(\n    map: Fn<[Ctx, Payload, Params], T>,\n    name?: string,\n  ): Fn<[Action<Params, Payload>], LensAction<[], T>>\n  <T extends Action>(fallback: ActionPayload<T>, name?: string): Fn<\n    [T],\n    LensAtom<ActionPayload<T>>\n  >\n  <T, State>(fallback: State, name?: string): Fn<\n    [Action<any[], T>],\n    LensAtom<State | T>\n  >\n  <Payload, State, Params extends any[] = any[]>(\n    fallback: State,\n    map: Fn<[Ctx, Payload, Params, State], State>,\n    name?: string,\n  ): Fn<[Action<Params, Payload>], LensAtom<State>>\n} =\n  (fallbackOrMapper: any, mapOrName?: any, name?: string) =>\n  (anAction: Action): any => {\n    throwReatomError(!anAction.__reatom.isAction, 'action expected')\n\n    const isAction = typeof fallbackOrMapper === 'function'\n    // isAtom\n    let fallback = fallbackOrMapper\n    // isAtom\n    let map = mapOrName ?? ((ctx: Ctx, v: any) => v)\n    if (isAction) {\n      fallback = []\n      map = fallbackOrMapper\n      name = mapOrName\n    }\n\n    const theAtom = Object.assign(\n      () => throwReatomError(1, 'derived action call'),\n      anAction.pipe(\n        mapState((ctx, depState, prevDepState, prevState = fallback) => {\n          return isAction\n            ? // @ts-expect-error\n              ((ctx.spy = undefined),\n              depState.reduce((acc: any, v) => {\n                const payload = map(ctx, v.payload, v.params)\n                return payload === SKIP\n                  ? acc\n                  : [...acc, { params: [v], payload }]\n              }, prevState))\n            : depState.reduce((acc, { payload, params }) => {\n                const state = map(ctx, payload, params, acc)\n                return state === SKIP ? acc : state\n              }, prevState)\n        }, name || (anAction.__reatom.name && 'mapPayload')),\n      ),\n    )\n    theAtom.__reatom.isAction = isAction\n\n    return theAtom\n  }\n\n/** Transform async action payload */\nexport const mapPayloadAwaited: {\n  <T, Payload = Awaited<T>>(\n    mapper?: Fn<[Ctx, Awaited<T>], Payload>,\n    name?: string,\n  ): Fn<[Action<any[], T>], LensAction<[], Payload>>\n  <T extends Action>(fallback: Awaited<ActionPayload<T>>, name?: string): Fn<\n    [T],\n    LensAtom<Awaited<ActionPayload<T>>>\n  >\n  <T, State>(fallback: State, name?: string): Fn<\n    [Action<any[], T>],\n    LensAtom<State | Awaited<T>>\n  >\n  <T, State>(\n    fallback: State,\n    map: Fn<[Ctx, Awaited<T>], State>,\n    name?: string,\n  ): Fn<[Action<any[], T>], LensAtom<State>>\n} =\n  (...a: [any?, any?, any?]) =>\n  (anAction: Action): any => {\n    const isAction = a.length === 0 || typeof a[0] === 'function'\n    const [fallback, map = (ctx: Ctx, v: any) => v, name] = isAction\n      ? [[], a[0], a[1]]\n      : a\n    const params = isAction ? [] : [fallback]\n    params.push((ctx: Ctx, promise: any) => {\n      if (promise instanceof Promise) {\n        __thenReatomed(ctx, promise, (v, read, actualize) =>\n          actualize!(\n            ctx,\n            ctx.cause!.proto,\n            (patchCtx: Ctx, patch: AtomCache) => {\n              patch.cause = ctx.cause.cause\n              const payload = map(ctx, v)\n              patch.state = isAction\n                ? [...patch.state, { params: [v], payload }]\n                : payload\n            },\n          ),\n        )\n\n        return SKIP\n      } else {\n        return map(ctx, promise)\n      }\n    }, name || (anAction.__reatom.name && 'mapPayloadAwaited'))\n\n    // @ts-expect-error reatomAsync\n    return (anAction.onFulfill ?? anAction).pipe(\n      mapPayload(\n        // @ts-ignore\n        ...params,\n      ),\n    )\n  }\n\n/** Transform atom update */\nexport const mapInput =\n  <T extends AtomMut | Action<[any]>, Args extends [Ctx, ...any[]]>(\n    mapper: Fn<Args, Parameters<T>[1]>,\n    name?: string,\n  ): Fn<[T], Action<CtxParams<Args>, AtomState<T>>> =>\n  (anAtom): any =>\n    action(\n      (ctx, ...args) =>\n        anAtom(\n          ctx,\n          // @ts-ignore\n          mapper(ctx, ...args),\n        ),\n      mapName(anAtom, 'mapInput', name),\n    )\n\n/** Convert action to atom with optional fallback state */\n// @ts-expect-error\nexport const toAtom: {\n  <T extends Action>(fallback: ReturnType<T>, name?: string): Fn<\n    [T],\n    LensAtom<ReturnType<T>>\n  >\n  <T extends Action>(fallback?: undefined, name?: string): Fn<\n    [T],\n    LensAtom<undefined | ReturnType<T>>\n  >\n  <T extends Action, State>(fallback: State, name?: string): Fn<\n    [T],\n    LensAtom<State | ReturnType<T>>\n  >\n} =\n  (fallback?: any, name?: string): Fn<[Action], Atom> =>\n  (anAction) =>\n    mapPayload(\n      fallback,\n      (ctx, v: any) => v,\n      mapName(anAction, 'toAtom', name),\n    )(anAction)\n\n// https://rxjs.dev/api/operators/tap\nexport const withOnUpdate =\n  <T extends Atom>(\n    cb: T extends Action<infer Params, infer Payload>\n      ? Fn<\n          [\n            Ctx,\n            Payload,\n            AtomCache<AtomState<Action<Params, Payload>>> & { params: Params },\n          ]\n        >\n      : Fn<[Ctx, AtomState<T>, AtomCache<AtomState<T>>]>,\n  ) =>\n  (anAtom: T): T => {\n    onUpdate(anAtom, cb)\n    return anAtom\n  }\n\n/** Convert an atom to action */\nexport const toAction: {\n  <State, T>(map: Fn<[ctx: Ctx, state: State], T>, name?: string): Fn<\n    [Atom<State>],\n    LensAction<[State], T>\n  >\n  <T>(name?: string): Fn<[Atom<T>], LensAction<[T], T>>\n} = (map?: string | Fn, name?: string) => (anAtom: Atom) => {\n  throwReatomError(anAtom.__reatom.isAction, 'atom expected')\n\n  if (typeof map === 'string') {\n    name = map\n    map = undefined\n  }\n  map ??= (ctx: Ctx, v: any) => v\n\n  // @ts-expect-error\n  const theAction: LensAction<[T], T> = atom((ctx) => {\n    // TODO handle atom mutation in the same transaction\n    const isInit = ctx.cause.pubs.length === 0\n    const state = ctx.spy(anAtom)\n    return isInit ? [] : [{ params: [state], payload: (map as Fn)(ctx, state) }]\n  }, mapName(anAtom, 'toAction', name))\n  theAction.__reatom.isAction = true\n  theAction.deps = [anAtom]\n\n  return theAction\n}\n","import {\n  Action,\n  atom,\n  Atom,\n  AtomCache,\n  AtomState,\n  Ctx,\n  Fn,\n  Unsubscribe,\n} from '@reatom/core'\nimport { __thenReatomed } from '@reatom/effects'\nimport { mapName } from './utils'\nimport { type LensAction } from './'\nimport { onUpdate } from '@reatom/hooks'\nimport { noop } from '@reatom/utils'\n\nexport interface LensEffect<Params extends any[] = any[], Payload = any>\n  extends LensAction<Params, Payload> {\n  unstable_unhook: Unsubscribe\n}\n\n/** Create action which will invoked with the result of effect */\n// @ts-expect-error\nexport const effect: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom, Res>(\n    fn: T extends Action<infer Params, infer Payload>\n      ? Fn<[Ctx, Awaited<Payload>, Params], Res>\n      : Fn<[Ctx, AtomState<T>], Res>,\n    name?: string,\n  ): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensEffect<\n          [\n            {\n              params: [{ params: Params; payload: Awaited<Payload> }]\n              payload: Awaited<Res>\n            },\n          ],\n          Awaited<Res>\n        >\n      : LensEffect<\n          [{ params: [AtomState<T>]; payload: AtomState<T> }],\n          Awaited<Res>\n        >\n  >\n} = (fn: Fn, name?: string) => (anAtom: Atom) => {\n  const { isAction } = anAtom.__reatom\n  // TODO better error handling\n  // @ts-expect-error\n  const theAtom: LensEffect = atom((ctx, state = []) => {\n    const resolve = (params: any[], payload: any) =>\n      ctx.get((read, acualize) => {\n        if (payload instanceof Promise) {\n          payload.then((payload) => resolve(params, payload))\n        } else {\n          acualize!(ctx, ctx.cause.proto, (patchCtx: Ctx, patch: AtomCache) => {\n            patch.state = [{ params, payload }]\n          })\n        }\n      })\n\n    ctx.spy(anAtom, (value) => {\n      if (isAction && value.payload instanceof Promise) {\n        __thenReatomed(ctx, value.payload, (payload) =>\n          ctx.schedule(() =>\n            resolve(\n              [{ params: value.params, payload }],\n              fn(ctx, payload, value.params),\n            ),\n          ),\n        )\n      } else {\n        ctx.schedule(() =>\n          resolve(\n            [value],\n            isAction ? fn(ctx, value.payload, value.params) : fn(ctx, value),\n          ),\n        )\n      }\n    })\n\n    return state ?? []\n  }, mapName(anAtom, 'effect', name))\n  theAtom.__reatom.isAction = true\n  theAtom.deps = [anAtom]\n  theAtom.unstable_unhook = onUpdate(theAtom, noop)\n\n  return theAtom\n}\n","import { Action, atom, Atom, AtomState, Ctx, CtxSpy, Fn } from '@reatom/core'\nimport { isShallowEqual } from '@reatom/utils'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\n/** Filter updates by comparator function (\"shallow equal\" for atoms by default) */\nexport const filter: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(\n    predicate?: T extends Action<infer Params, infer Payload>\n      ? Fn<[Ctx, Payload, Params], boolean>\n      : Fn<[CtxSpy, AtomState<T>, AtomState<T>], boolean>,\n    name?: string,\n  ): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<Params, Payload>\n      : T extends Atom<infer State>\n      ? LensAtom<State>\n      : never\n  >\n} =\n  (predicate?: Fn, name?: string) =>\n  (anAtom: Atom): any => {\n    name = mapName(anAtom, 'filter', name)\n    const { isAction } = anAtom.__reatom\n\n    predicate ??= isAction ? () => true : (ctx, a, b) => !isShallowEqual(a, b)\n\n    // @ts-expect-error\n    const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n      const isInit = ctx.cause.pubs.length === 0\n      const state = ctx.spy(anAtom)\n\n      return isAction\n        ? state.reduce(\n            (acc: any, call: any) =>\n              predicate!(ctx, call.payload, call.params) ? [call] : acc,\n            prevState ?? [],\n          )\n        : isInit || predicate!(ctx, state, prevState)\n        ? state\n        : prevState\n    })\n    theAtom.deps = [anAtom]\n    theAtom.__reatom.isAction = isAction\n\n    return theAtom\n  }\n","import { Action, atom, Atom, AtomState, Fn } from '@reatom/core'\nimport { mapName } from './utils'\nimport { type LensAtom, type LensAction } from './'\n\n/** Delay updates until other atom update / action call */\n// https://rxjs.dev/api/operators/sample\n// https://effector.dev/docs/api/effector/sample\n// @ts-expect-error\nexport const sample: {\n  // TODO for some reason an atom not handled by overloads, if an action overload is first\n  <T extends Atom>(signal: Atom, name?: string): Fn<\n    [T],\n    T extends Action<infer Params, infer Payload>\n      ? LensAction<[], Payload>\n      : LensAtom<AtomState<T>>\n  >\n} =\n  <T>(signal: Atom, name?: string) =>\n  // @ts-ignore\n  (anAtom) => {\n    name = mapName(anAtom, 'sample', name)\n    const { isAction } = anAtom.__reatom\n    const _cacheAtom = atom<unknown>(null, `${name}._cacheAtom`)\n\n    // @ts-expect-error\n    const theAtom: LensAtom & LensAction = atom((ctx, prevState?: any) => {\n      const patch = ctx.cause\n      const isInit = patch.pubs.length === 0\n\n      ctx.spy(anAtom, (v) => _cacheAtom(ctx, isAction ? [v] : v))\n\n      let changed = false\n      ctx.spy(signal, () => (changed = true))\n\n      if (changed && !(isInit && !signal.__reatom.isAction)) {\n        const state = ctx.get(_cacheAtom)\n        // drop action cache\n        _cacheAtom(ctx, ctx.get(anAtom))\n        return state\n      }\n\n      return isInit && !(signal.__reatom.isAction && changed)\n        ? isAction\n          ? []\n          : ctx.get(anAtom)\n        : changed\n        ? ctx.get(_cacheAtom)\n        : prevState\n    })\n    theAtom.__reatom.isAction = isAction\n    theAtom.deps = [anAtom, signal]\n\n    return theAtom\n  }\n","import { action, Action, Atom, AtomCache, AtomState, Ctx } from '@reatom/core'\n\nexport const withReset =\n  <T extends Atom>() =>\n  (anAtom: T): T & { reset: Action<[], AtomState<T>> } =>\n    Object.assign(anAtom, {\n      reset: action(\n        (ctx) =>\n          ctx.get(\n            (read, actualize) =>\n              actualize!(\n                ctx,\n                anAtom.__reatom,\n                (patchCtx: Ctx, patch: AtomCache) =>\n                  (patch.state = patch.proto.initState(ctx)),\n              ).state,\n          ),\n        `${anAtom.__reatom.name}._reset`,\n      ),\n    })\n"],"names":["mapName","_ref","operator","name","__reatom","proto","ctxMap","WeakMap","delay","options","anAtom","running","min","minOption","max","maxOption","leading","trailing","abortable","throwReatomError","undefined","Number","MAX_SAFE_INTEGER","minAtom","isAtom","atom","maxAtom","theAtom","ctx","prevState","get","startsKey","cause","listeners","depState","spy","state","pubs","length","isAction","now","Date","isRunning","has","start","skip","Math","set","schedule","delete","timeoutId","setTimeout","read","acualize","patchCtx","patch","at","unref","clearTimeout","onCtxAbort","deps","onLensUpdate","onUpdate","parseAtoms","value","Map","map","k","Set","add","res","Array","isArray","SKIP","mapState","mapper","mapPayload","fallbackOrMapper","mapOrName","anAction","fallback","v","Object","assign","pipe","prevDepState","reduce","acc","payload","params","_ref2","bind","fn","fnMap","bfn","shape","newState","key","values","effect","resolve","Promise","then","__thenReatomed","unstable_unhook","noop","filter","predicate","a","b","isShallowEqual","isInit","call","mapInput","action","slice","arguments","push","promise","actualize","onFulfill","onChange","onCall","sample","signal","_cacheAtom","changed","toAction","theAction","toAtom","concat","cb","withReset","reset","initState"],"mappings":"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"}