import { Action, ActionPayload, Atom, AtomCache, AtomMut, AtomState, Ctx, CtxParams, CtxSpy, Fn, Rec } from '@reatom/core';
import { Plain } from '@reatom/utils';
export * from './bind';
export * from './delay';
export * from './effect';
export * from './filter';
export * from './onLensUpdate';
export * from './parseAtoms';
export * from './sample';
export * from './withReset';
export interface LensAtom<State = any> extends Atom<State> {
    deps: Array<Atom>;
}
export interface LensAction<Params extends any[] = any[], Payload = any> extends Action<Params, Payload> {
    deps: Array<Atom>;
}
type Combined<Shape extends Rec<Atom>> = Plain<{
    [K in keyof Shape]: AtomState<Shape[K]>;
}>;
export declare const combine: <Shape extends Rec<Atom<any>>>(shape: Shape) => LensAtom<Plain<{ [K in keyof Shape]: AtomState<Shape[K]>; }>>;
/**
 * Skip mark to stop reactive propagation and use previous state
 * (`never` helps to infer correct type)
 * @internal
 * @deprecated
 */
export declare const SKIP: never;
/** Remove callable signature to prevent the atom update from outside */
export declare const readonly: <T extends Atom<any> & {
    deps?: Atom<any>[] | undefined;
}>({ __reatom, pipe, onChange, onCall, deps, }: T) => LensAtom<AtomState<T>>;
/** Remove all extra properties from the atom to pick the essence */
export declare const plain: <T extends Atom<any>>(anAtom: T) => T extends Action<infer Params extends any[], infer Payload> ? Action<Params, Payload> : T extends AtomMut<infer State> ? AtomMut<State> : Atom<AtomState<T>>;
/** Transform atom state */
export declare const mapState: <T extends Atom<any>, Res>(mapper: Fn<[CtxSpy, AtomState<T>, AtomState<T> | undefined, unknown], Res>, name?: string) => Fn<[T], LensAtom<Res>>;
/** Transform action payload */
export declare const mapPayload: {
    <Payload, T, Params extends any[] = any[]>(map: Fn<[Ctx, Payload, Params], T>, name?: string): Fn<[Action<Params, Payload>], LensAction<[], T>>;
    <T extends Action>(fallback: ActionPayload<T>, name?: string): Fn<[
        T
    ], LensAtom<ActionPayload<T>>>;
    <T, State>(fallback: State, name?: string): Fn<[
        Action<any[], T>
    ], LensAtom<State | T>>;
    <Payload, State, Params extends any[] = any[]>(fallback: State, map: Fn<[Ctx, Payload, Params, State], State>, name?: string): Fn<[Action<Params, Payload>], LensAtom<State>>;
};
/** Transform async action payload */
export declare const mapPayloadAwaited: {
    <T, Payload = Awaited<T>>(mapper?: Fn<[Ctx, Awaited<T>], Payload>, name?: string): Fn<[Action<any[], T>], LensAction<[], Payload>>;
    <T extends Action>(fallback: Awaited<ActionPayload<T>>, name?: string): Fn<[
        T
    ], LensAtom<Awaited<ActionPayload<T>>>>;
    <T, State>(fallback: State, name?: string): Fn<[
        Action<any[], T>
    ], LensAtom<State | Awaited<T>>>;
    <T, State>(fallback: State, map: Fn<[Ctx, Awaited<T>], State>, name?: string): Fn<[Action<any[], T>], LensAtom<State>>;
};
/** Transform atom update */
export declare const mapInput: <T extends AtomMut<any> | Action<[any], any>, Args extends [Ctx, ...any[]]>(mapper: Fn<Args, Parameters<T>[1]>, name?: string) => Fn<[T], Action<CtxParams<Args>, AtomState<T>>>;
/** Convert action to atom with optional fallback state */
export declare const toAtom: {
    <T extends Action>(fallback: ReturnType<T>, name?: string): Fn<[
        T
    ], LensAtom<ReturnType<T>>>;
    <T extends Action>(fallback?: undefined, name?: string): Fn<[
        T
    ], LensAtom<undefined | ReturnType<T>>>;
    <T extends Action, State>(fallback: State, name?: string): Fn<[
        T
    ], LensAtom<State | ReturnType<T>>>;
};
export declare const withOnUpdate: <T extends Atom<any>>(cb: T extends Action<infer Params extends any[], infer Payload> ? Fn<[Ctx, Payload, AtomCache<{
    params: Params;
    payload: Payload;
}[]> & {
    params: Params;
}], any> : Fn<[Ctx, AtomState<T>, AtomCache<AtomState<T>>], any>) => (anAtom: T) => T;
/** Convert an atom to action */
export declare const toAction: {
    <State, T>(map: Fn<[ctx: Ctx, state: State], T>, name?: string): Fn<[
        Atom<State>
    ], LensAction<[State], T>>;
    <T>(name?: string): Fn<[Atom<T>], LensAction<[T], T>>;
};
//# sourceMappingURL=index.d.ts.map