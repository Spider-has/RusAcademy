{"version":3,"file":"index.module.js","sources":["../../utils/build/index.module.js","../src/index.ts"],"sourcesContent":["const noop=()=>{},sleep=function(ms){return void 0===ms&&(ms=0),new Promise(r=>setTimeout(r,ms))},isObject=thing=>\"object\"==typeof thing&&null!==thing,isShallowEqual=function(a,b,is){if(void 0===is&&(is=Object.is),Object.is(a,b))return!0;if(!isObject(a)||!isObject(b)||a.__proto__!==b.__proto__||a instanceof Error)return!1;if(Symbol.iterator in a){let equal=a instanceof Map?(a,b)=>is(a[0],b[0])&&is(a[1],b[1]):is,aIter=a[Symbol.iterator](),bIter=b[Symbol.iterator]();for(;;){let aNext=aIter.next(),bNext=bIter.next();if(aNext.done||bNext.done||!equal(aNext.value,bNext.value))return aNext.done&&bNext.done}}if(a instanceof Date)return a.getTime()===b.getTime();if(a instanceof RegExp)return String(a)===String(b);for(let k in a)if(k in b==0||!is(a[k],b[k]))return!1;return Object.keys(a).length===Object.keys(b).length},isDeepEqual=(a,b)=>{const visited=new WeakMap,is=(a,b)=>{if(isObject(a)){if(visited.has(a))return visited.get(a)===b;visited.set(a,b)}return isShallowEqual(a,b,is)};return isShallowEqual(a,b,is)},assign=Object.assign,merge=function(){return Object.assign({},...[].slice.call(arguments))},pick=(target,keys)=>{const result={};for(const key of keys)result[key]=target[key];return result},omit=(target,keys)=>{const result={};for(const key in target)keys.includes(key)||(result[key]=target[key]);return result},jsonClone=value=>JSON.parse(JSON.stringify(value)),random=function(min,max){return void 0===min&&(min=0),void 0===max&&(max=Number.MAX_SAFE_INTEGER-1),Math.floor(Math.random()*(max-min+1))+min},nonNullable=(value,message)=>{if(null!=value)return value;throw new TypeError(message||\"Value is null or undefined\")},{toString:toString}=Object.prototype,visited=new WeakMap,toStringKey=function(thing,immutable){void 0===immutable&&(immutable=!0);var tag=typeof thing,isNominal=\"function\"===tag||\"symbol\"===tag;if(!isNominal&&(\"object\"!==tag||null===thing||thing instanceof Date||thing instanceof RegExp))return tag+thing;if(visited.has(thing))return visited.get(thing);var result=toString.call(thing),unique=result+random();if(visited.set(thing,unique),isNominal||thing.constructor!==Object&&Symbol.iterator in thing==0)return unique;for(let item of Symbol.iterator in thing?thing:Object.entries(thing).sort((_ref,_ref2)=>{let[a]=_ref,[b]=_ref2;return a.localeCompare(b)}))result+=toStringKey(item,immutable);return immutable?visited.set(thing,result):visited.delete(thing),result},toAbortError=reason=>{if(reason instanceof Error==0||\"AbortError\"!==reason.name){if(reason instanceof Error){var options={cause:reason};reason=reason.message}else reason=isObject(reason)?toString.call(reason):String(reason);\"undefined\"==typeof DOMException?(reason=new Error(reason,options)).name=\"AbortError\":reason=assign(new DOMException(reason,\"AbortError\"),options)}return reason},throwIfAborted=controller=>{if(controller?.signal.aborted)throw toAbortError(controller.signal.reason)},isAbort=thing=>thing instanceof Error&&\"AbortError\"===thing.name,MAX_SAFE_TIMEOUT=2**31-1;export{MAX_SAFE_TIMEOUT,assign,isAbort,isDeepEqual,isObject,isShallowEqual,jsonClone,merge,nonNullable,noop,omit,pick,random,sleep,throwIfAborted,toAbortError,toStringKey};\n//# sourceMappingURL=index.module.js.map\n","import { AtomCache, AtomProto, Ctx, Fn, Rec, __root } from '@reatom/core'\nimport { isShallowEqual } from '@reatom/utils'\n\nexport interface unstable_ChangeMsg {\n  newState?: any\n  oldState?: any\n  payload?: any\n  patch: AtomCache\n  cause?: string\n  history: Array<AtomCache>\n  params?: Array<any>\n}\nexport interface LogMsg {\n  error: undefined | Error\n  changes: Rec<unstable_ChangeMsg>\n  logs: Array<AtomCache>\n  ctx: Ctx\n}\n\n// use recursion to drop stack limit error for circle causes\nexport const getCause = (patch: AtomCache, log = ''): string =>\n  patch.cause !== null && patch.cause.proto !== __root\n    ? getCause(patch.cause, log + ' <-- ' + patch.cause.proto.name ?? 'unnamed')\n    : log || 'root'\n\nconst getTimeStampDefault = () => {\n  let ms: number | string = new Date().getMilliseconds()\n  ms = ms.toString().padStart(3, '0')\n  return `${new Date().toLocaleTimeString()} ${ms}ms`\n}\n\nexport const createLogBatched = ({\n  debounce = 500,\n  getTimeStamp = getTimeStampDefault,\n  limit = 5000,\n  log = console.log,\n  domain = '',\n  shouldGroup = false,\n}: {\n  debounce?: number\n  getTimeStamp?: () => string\n  limit?: number\n  log?: typeof console.log\n  domain?: string\n  shouldGroup?: boolean\n} = {}) => {\n  if (domain) domain = `(${domain}) `\n  let queue: Array<LogMsg & { time: string }> = []\n  let isBatching = false\n  let batchingStart = Date.now()\n  const logBatched = (msg: LogMsg) => {\n    if (Object.keys(msg.changes).length === 0) return\n\n    if (!isBatching) {\n      isBatching = true\n      batchingStart = Date.now()\n    }\n\n    setTimeout(\n      (length) => {\n        isBatching =\n          queue.length !== length && Date.now() - batchingStart < limit\n\n        if (isBatching) return\n\n        const isFewTransactions = queue.length > 0\n\n        console.groupCollapsed(\n          `Reatom ${domain}${length} transaction${length > 1 ? 's' : ''}`,\n        )\n\n        for (const { changes, time, error } of queue) {\n          console.log(\n            `%c ${time}`,\n            `padding-left: calc(50% - ${\n              time.length / 2\n            }em); font-size: 0.7rem;`,\n          )\n\n          if (error) console.error(error)\n\n          let inGroup = false\n          Object.entries(changes).forEach(([k, change], i, arr) => {\n            const isAction = 'payload' in change\n            const color = isAction\n              ? 'background: #ffff80; color: #151134;'\n              : 'background: #151134; color: white;'\n            const style = `${color}font-weight: 400; padding: 0.15em;  padding-right: 1ch;`\n\n            const name = k.replace(/(\\d)*\\./, '')\n            const head = name.replace(/\\..*/, '')\n            const nextK = arr[i + 1]?.[0]\n            const nextName = nextK?.replace(/(\\d)*\\./, '')\n            const isGroup = nextName?.startsWith(head)\n            if (shouldGroup && !inGroup && isGroup && isFewTransactions) {\n              inGroup = true\n              // TODO show name?\n              console.groupCollapsed(`%c ${head}`, style)\n            }\n            const title = `%c ${name}`\n            const data = isAction ? change!.payload : change!.newState\n            console.groupCollapsed(title, style)\n            console.log(change)\n            console.groupEnd()\n            // do not log the same data twice if action just pass the data\n            if (isAction && !isShallowEqual(change.params, [data])) {\n              log(...change.params!)\n            }\n            log(data)\n\n            if (shouldGroup && !isGroup && inGroup) {\n              inGroup = false\n              console.groupEnd()\n            }\n          })\n        }\n        console.log('\\n\\n', 'transactions:', queue)\n        console.groupEnd()\n        queue = []\n      },\n      debounce,\n      queue.push(Object.assign(msg, { time: getTimeStamp() })),\n    )\n  }\n\n  return logBatched\n}\n\n// export const log = action((ctx, message: any, name?: string) => ({\n//   message,\n//   name,\n// }), '@reatom/logger.log')\n\n// declare global {\n//   REATOM_LOG: typeof log\n// }\n\n// globalThis.REATOM_LOG = log\n\nexport const connectLogger = (\n  ctx: Ctx,\n  {\n    historyLength = 10,\n    domain = '',\n    log = createLogBatched({ domain }),\n    showCause = true,\n    skip = () => false,\n    skipUnnamed = true,\n  }: {\n    historyLength?: number\n    log?: Fn<[LogMsg]>\n    domain?: string\n    showCause?: boolean\n    skipUnnamed?: boolean\n    skip?: (patch: AtomCache) => boolean\n  } = {},\n) => {\n  const history = new WeakMap<AtomProto, Array<AtomCache>>()\n  let read: Fn<[AtomProto], undefined | AtomCache>\n  ctx.get((r) => (read = r))\n\n  return ctx.subscribe((logs, error) => {\n    const states = new WeakMap<AtomProto, any>()\n    const changes = logs.reduce((acc, patch, i) => {\n      const { proto, state } = patch\n      const { isAction } = proto\n      let { name } = proto\n\n      if (skip(patch)) return acc\n\n      if (!name || name.startsWith('_') || /\\._/.test(name)) {\n        if (skipUnnamed) return acc\n        name ??= 'unnamed'\n      }\n\n      const oldCache = read(proto)\n      const oldState = states.has(proto) ? states.get(proto) : oldCache?.state\n      states.set(proto, state)\n\n      const isConnection =\n        !oldCache &&\n        patch.cause!.proto.name === 'root' &&\n        (!isAction || state.length === 0)\n\n      let atomHistory = history.get(proto) ?? []\n      if (!Object.is(state, oldState) && historyLength) {\n        atomHistory = atomHistory.slice(0, historyLength - 1)\n        atomHistory.unshift(isAction ? { ...patch, state: [...state] } : patch)\n        history.set(proto, atomHistory)\n      }\n\n      if (isConnection || Object.is(state, oldState)) {\n        return acc\n      }\n\n      const changeMsg: unstable_ChangeMsg = (acc[`${i + 1}.${name}`] = {\n        patch,\n        history: atomHistory,\n      })\n\n      if (isAction) {\n        const call = state.at(-1) as { params: Array<any>; payload: any }\n        changeMsg.params = call.params\n        changeMsg.payload = call.payload\n      } else {\n        changeMsg.newState = state\n        changeMsg.oldState = oldState\n      }\n      changeMsg.patch = patch\n      if (showCause) changeMsg.cause = getCause(patch)\n\n      return acc\n    }, {} as LogMsg['changes'])\n\n    log({\n      error,\n      changes,\n      logs,\n      ctx,\n    })\n  })\n}\n"],"names":["noop","isObject","thing","isShallowEqual","a","b","is","Object","__proto__","Error","Symbol","iterator","equal","Map","aIter","bIter","aNext","next","bNext","done","value","Date","getTime","RegExp","String","k","keys","length","getCause","patch","log","cause","proto","__root","name","getTimeStampDefault","ms","getMilliseconds","toString","padStart","toLocaleTimeString","createLogBatched","_temp","debounce","getTimeStamp","limit","console","domain","shouldGroup","queue","isBatching","batchingStart","now","msg","changes","setTimeout","isFewTransactions","groupCollapsed","time","error","inGroup","entries","forEach","_ref","i","arr","change","isAction","style","replace","head","nextK","nextName","isGroup","startsWith","data","payload","newState","groupEnd","params","push","assign","connectLogger","ctx","_temp2","historyLength","showCause","skip","skipUnnamed","history","WeakMap","read","get","r","subscribe","logs","states","reduce","acc","state","test","oldCache","oldState","has","set","isConnection","atomHistory","slice","unshift","changeMsg","call","at"],"mappings":"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"}